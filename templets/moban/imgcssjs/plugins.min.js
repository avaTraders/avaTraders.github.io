/** assistance.js
 *
 *	The assistance component is a means of showing modal-style help features in the page the first time they are viewed. After they are viewed
 *	and closed a value is written to local storage to prevent the assistant panel from displaying again.
 *	
 *  TODO: make local storage also support cookies (currently only provides support for browsers that support the Storage.localStorage API)
 */


var PIE;

jQuery(document).ready(function ($) {

    try {
        if (window.localStorage != undefined || navigator.cookieEnabled) {
            $.Storage.local.setItem("ImmiLocalStorageDetect", 'true');
            setTimeout(function () { RenderDataAssistance(); }, $.Delay.Assistance);
        }
    }
    catch (e) { }

    function RenderDataAssistance() {
        try {
            var dataAssistance = UserAssistanceField;

            var CloseButton = function () {
                this.__construct('button');
                this.generateTextNode('Close');
                return this;
            }
            CloseButton.prototype = new $.Element();

            var Popover = function (properties) {
                this.__construct('div');
                this.setCssClass([$.CssClassNames.popover, $.CssClassNames.assistance]);
                var h2 = document.createElement('h2'),
                        //p = new $.Paragraph(properties.text).getElement(),
                        p = $("<p>" + properties.text + "<br/></p>")[0],
                        link = new $.Link(properties.link.url, properties.link.text).getElement(),
                        div = document.createElement('div'),
                        close_button = new CloseButton().getElement();
                //this.skip_link = new $.Link('#' + properties.id, '[Jump to element]').getElement();

                h2.appendChild(document.createTextNode(properties.title));
                p.appendChild(link);
                //div.appendChild(this.skip_link);
                this.phantom = { first: new $.PhantomLink('a').getElement(), last: new $.PhantomLink('b').getElement() };
                this.element.appendChild(this.phantom.first);
                this.element.appendChild(h2);
                this.element.appendChild(p);
                this.element.appendChild(div);
                this.element.appendChild(close_button);
                this.element.appendChild(this.phantom.last);
                this.focus = function () {
                    $(link).trigger('focus');
                };
                return this;
            }
            Popover.prototype = new $.Element(); // set and call the "superclass" <- the Element "class" is invoked once when first encountered making it more 'efficient' (especially when creating many instances)

            if ($.Storage) {
                var shim = null,
                        shims = [],
                        popover = null,
                        initial_element_position_state = null,
                        initial_element_z_index = null,
                        clearAssistance = function (element, storage) {
                            //$.Storage.local.setItem(storage, 'true');
                            //$.Storage.local.setItem(storage, 'true'); // set the 'visited' local storage item to true to stop the popover/shade from showing for this user in the future
                            $(shim).safeFadeOut({ duration: 400, callback: function () { $(this).remove(); } });
                            $(popover.getElement()).safeFadeOut({
                                duration: 400,
                                callback: function () {
                                    $(this).remove();
                                }
                            });
                            shim = null; // delete the objects
                            popover = null;
                            $(document).unbind('keydown'); // .unbind('click');
                            $(window).unbind('resize');
                            $('body').removeClass('stop-scrolling');
                            $('body').unbind('touchmove');

                            try {
                                $.Storage.local.setItem(storage, 'true');
                                setTimeout(function () { RenderDataAssistance(); }, 500);
                            }
                            catch (e) { }

                        };

                for (var iAssistance in dataAssistance) {

                    var data = dataAssistance[iAssistance],
                            $element = $("#" + iAssistance),
                            $body = $.Elements.$Body,
                            key = "assistance-" + iAssistance,
                            id = iAssistance || null,
                            user_assistance = { buffer: 24, arrow: { width: 65, height: 106 } };

                    if ($element[0]) {


                        if (!$.Storage.local.getItem(key) && $element.is(':visible')) {

                            // check if the position is fixed at the bottom, hence for mobile
                            if (iAssistance == "select_country" && $(".immi-tools").css("position") == "fixed") {
                                $('html,body').scrollTop(0); //scroll to the top of the view-port
                                $('body').addClass('stop-scrolling');
                            }

                            initial_element_position_state = $element.css('position');
                            initial_element_z_index = $element.css('z-index');

                            shim = new $.Shim().getElement();
                            popover = new Popover(data);

                            var $shim = $(shim),
                                    $popover = $(popover.getElement());

                            $body.prepend(popover.getElement());
                            if (typeof PIE != "undefined") {
                                $popover.each(function () {
                                    PIE.attach(this);
                                });
                            }

                            // set the popover position based on its size and the element it applies to
                            var element_left = $element.offset().left,
                                    element_top = $element.offset().top,
                                    element_width = $element.outerWidth(),
                                    element_height = $element.outerHeight(),
                                    popover_height = $popover.outerHeight() + user_assistance.arrow.height + user_assistance.buffer,
                                    popover_width = $popover.outerWidth(),
                                    popover_top = (element_top > popover_height ? element_top - popover_height + user_assistance.buffer : element_top + element_height + user_assistance.arrow.height);
                            popover_left = (element_width - popover_width) / 2 + element_left - (user_assistance.arrow.width / 2);
                            if (popover_left < 15) {
                                $popover.addClass('immi-assistance-left');
                                popover_left = 15;
                            }

                            $popover.css({
                                'top': popover_top + 'px', // when there is enough room above the element the popover sits above, otherwise it goes underneath
                                'left': popover_left + 'px'
                            });

                            if (element_top > popover_height) {
                                $popover.addClass('immi-before-element'); // change class to rotate the the assistance arrow (pseudo-element)
                            }

                            for (var i = 0; i < 4; i++) {
                                shims.push(document.createElement('div'));
                                $shim.append(shims[i]);
                            }
                            $body.prepend(shim);
                            $shim.hide();
                            $popover.hide();

                            // show the shade and popover after the page and its sub-resources has fully loaded avoiding the potential for a race condition
                            //$(window).load(function (event) {

                            // fade in shade and help popover
                            //setTimeout(function () {
                            // $('.subnav').fadeOut(); // TODO: create a high-level method of the jQuery object to clear all modal and tab stuff
                            //$('html,body').animate({ scrollTop: 0 }, 400); //scroll to the top of the view-port
                            var help_delay = !jQuery.support.changeBubbles ? 0 : 500, // IE8 = 0
                                viewport_height = $(document).height(),
                                viewport_width = $("body").width();
                            $shim.css({ height: viewport_height + 'px' });

                            $(shims[0]).css({ top: 0, left: 0, width: element_left + 'px', height: viewport_height + 'px' });
                            $(shims[1]).css({ top: 0, left: element_left + 'px', width: element_width + 'px', height: element_top + 'px' });
                            $(shims[2]).css({ top: 0, left: (element_left + element_width) + 'px', width: (viewport_width - (element_left + element_width)) + 'px', height: viewport_height + 'px' });
                            $(shims[3]).css({ top: (element_top + element_height) + 'px', left: element_left + 'px', width: element_width + 'px', height: (viewport_height - (element_top + element_height)) + 'px' });
                            $shim.safeFadeIn({ duration: 400 });
                            setTimeout(function () {

                                // Setup up the "phantom" links that are styled out of the view port to handle focus/blur on the top and bottom
                                // of the popover. When the first phantom is focused it focuses the last button in the popover whereas the last
                                // phantom focuses on the first button in the popover.
                                $(popover.phantom.first).bind('focus', function (event) {
                                    $popover.find('button,a').not('[href="#phantom"]').filter(':last').focus(); //$.log('event.target: ' + event.target.firstChild.nodeValue);
                                });
                                $(popover.phantom.last).bind('focus', function (event) {
                                    $popover.find('button,a').not('[href="#phantom"]').filter(':first').focus(); //$.log('event.target: ' + event.target.firstChild.nodeValue);
                                });
                                //$(popover.skip_link).bind('click', function (event) {
                                $popover.find('.skip_link').bind('click', function (event) {
                                    event.preventDefault();
                                    $element.focusFirstInteractiveControl();
                                });

                                if (!$("immi-popover")[0])
                                    $popover.safeFadeIn({ duration: $.Effects.Assistance });

                                popover.focus();

                                $('body').bind('touchmove', function (e) { e.preventDefault() });

                            }, help_delay);
                            /*
                                                        $(document).bind('click', function (event) {
                                                            if (popover) {
                                                                clearAssistance($element, key);
                                                            }
                                                        });
                            */
                            $popover.bind("clickoutside", function (event) {
                                if (popover) {
                                    clearAssistance($element, key);
                                }
                            });

                            $popover.find("button").bind('click', function (event) {
                                clearAssistance($element, key);
                            });

                            $(window).bind('resize', function (event) {
                                if (popover) {
                                    clearAssistance($element, key);
                                }
                            });

                            //bind event handlers
                            $(document).bind('keydown', function (event) {
                                if (event.which == 27) { // escape key pressed
                                    if (popover) {
                                        $.log('esc key pressed');
                                        clearAssistance($element, key);
                                    }
                                }
                            });


                            //}, $.Delay.Assistance);
                            //}); // Window.load
                            $(".trap").trap();
                            return false; // prevents more than one assistance component from running at the same time (page view)

                        } // if !$.Storage.local.getItem(key)
                    } // if ($element[0])
                    // return true;
                }  // for dataAssistance
            }  // If $.Storage
        }
        catch (e) { }

    } // RenderDataAssistance

});
/*
 *	jQuery carouFredSel 6.2.1
 *	Demo's and documentation:
 *	caroufredsel.dev7studios.com
 *
 *	Copyright (c) 2013 Fred Heusschen
 *	www.frebsite.nl
 *
 *	Dual licensed under the MIT and GPL licenses.
 *	http://en.wikipedia.org/wiki/MIT_License
 *	http://en.wikipedia.org/wiki/GNU_General_Public_License
 */


(function ($) {


    //	LOCAL

    if ($.fn.carouFredSel) {
        return;
    }

    $.fn.caroufredsel = $.fn.carouFredSel = function (options, configs) {

        //	no element
        if (this.length == 0) {
            debug(true, 'No element found for "' + this.selector + '".');
            return this;
        }

        //	multiple elements
        if (this.length > 1) {
            return this.each(function () {
                $(this).carouFredSel(options, configs);
            });
        }


        var $cfs = this,
			$tt0 = this[0],
			starting_position = false;

        if ($cfs.data('_cfs_isCarousel')) {
            starting_position = $cfs.triggerHandler('_cfs_triggerEvent', 'currentPosition');
            $cfs.trigger('_cfs_triggerEvent', ['destroy', true]);
        }

        var FN = {};

        FN._init = function (o, setOrig, start) {
            o = go_getObject($tt0, o);

            o.items = go_getItemsObject($tt0, o.items);
            o.scroll = go_getScrollObject($tt0, o.scroll);
            o.auto = go_getAutoObject($tt0, o.auto);
            o.prev = go_getPrevNextObject($tt0, o.prev);
            o.next = go_getPrevNextObject($tt0, o.next);
            o.pagination = go_getPaginationObject($tt0, o.pagination);
            o.swipe = go_getSwipeObject($tt0, o.swipe);
            o.mousewheel = go_getMousewheelObject($tt0, o.mousewheel);

            if (setOrig) {
                opts_orig = $.extend(true, {}, $.fn.carouFredSel.defaults, o);
            }

            opts = $.extend(true, {}, $.fn.carouFredSel.defaults, o);
            opts.d = cf_getDimensions(opts);

            crsl.direction = (opts.direction == 'up' || opts.direction == 'left') ? 'next' : 'prev';

            var a_itm = $cfs.children(),
				avail_primary = ms_getParentSize($wrp, opts, 'width');

            if (is_true(opts.cookie)) {
                opts.cookie = 'caroufredsel_cookie_' + conf.serialNumber;
            }

            opts.maxDimension = ms_getMaxDimension(opts, avail_primary);

            //	complement items and sizes
            opts.items = in_complementItems(opts.items, opts, a_itm, start);
            opts[opts.d['width']] = in_complementPrimarySize(opts[opts.d['width']], opts, a_itm);
            opts[opts.d['height']] = in_complementSecondarySize(opts[opts.d['height']], opts, a_itm);

            //	primary size not set for a responsive carousel
            if (opts.responsive) {
                if (!is_percentage(opts[opts.d['width']])) {
                    opts[opts.d['width']] = '100%';
                }
            }

            //	primary size is percentage
            if (is_percentage(opts[opts.d['width']])) {
                crsl.upDateOnWindowResize = true;
                crsl.primarySizePercentage = opts[opts.d['width']];
                opts[opts.d['width']] = ms_getPercentage(avail_primary, crsl.primarySizePercentage);
                if (!opts.items.visible) {
                    opts.items.visibleConf.variable = true;
                }
            }

            if (opts.responsive) {
                opts.usePadding = false;
                opts.padding = [0, 0, 0, 0];
                opts.align = false;
                opts.items.visibleConf.variable = false;
            }
            else {
                //	visible-items not set
                if (!opts.items.visible) {
                    opts = in_complementVisibleItems(opts, avail_primary);
                }

                //	primary size not set -> calculate it or set to "variable"
                if (!opts[opts.d['width']]) {
                    if (!opts.items.visibleConf.variable && is_number(opts.items[opts.d['width']]) && opts.items.filter == '*') {
                        opts[opts.d['width']] = opts.items.visible * opts.items[opts.d['width']];
                        opts.align = false;
                    }
                    else {
                        opts[opts.d['width']] = 'variable';
                    }
                }
                //	align not set -> set to center if primary size is number
                if (is_undefined(opts.align)) {
                    opts.align = (is_number(opts[opts.d['width']]))
						? 'center'
						: false;
                }
                //	set variabe visible-items
                if (opts.items.visibleConf.variable) {
                    opts.items.visible = gn_getVisibleItemsNext(a_itm, opts, 0);
                }
            }

            //	set visible items by filter
            if (opts.items.filter != '*' && !opts.items.visibleConf.variable) {
                opts.items.visibleConf.org = opts.items.visible;
                opts.items.visible = gn_getVisibleItemsNextFilter(a_itm, opts, 0);
            }

            opts.items.visible = cf_getItemsAdjust(opts.items.visible, opts, opts.items.visibleConf.adjust, $tt0);
            opts.items.visibleConf.old = opts.items.visible;

            if (opts.responsive) {
                if (!opts.items.visibleConf.min) {
                    opts.items.visibleConf.min = opts.items.visible;
                }
                if (!opts.items.visibleConf.max) {
                    opts.items.visibleConf.max = opts.items.visible;
                }
                opts = in_getResponsiveValues(opts, a_itm, avail_primary);
            }
            else {
                opts.padding = cf_getPadding(opts.padding);

                if (opts.align == 'top') {
                    opts.align = 'left';
                }
                else if (opts.align == 'bottom') {
                    opts.align = 'right';
                }

                switch (opts.align) {
                    //	align: center, left or right
                    case 'center':
                    case 'left':
                    case 'right':
                        if (opts[opts.d['width']] != 'variable') {
                            opts = in_getAlignPadding(opts, a_itm);
                            opts.usePadding = true;
                        }
                        break;

                        //	padding
                    default:
                        opts.align = false;
                        opts.usePadding = (
							opts.padding[0] == 0 &&
							opts.padding[1] == 0 &&
							opts.padding[2] == 0 &&
							opts.padding[3] == 0
						) ? false : true;
                        break;
                }
            }

            if (!is_number(opts.scroll.duration)) {
                opts.scroll.duration = 500;
            }
            if (is_undefined(opts.scroll.items)) {
                opts.scroll.items = (opts.responsive || opts.items.visibleConf.variable || opts.items.filter != '*')
					? 'visible'
					: opts.items.visible;
            }

            opts.auto = $.extend(true, {}, opts.scroll, opts.auto);
            opts.prev = $.extend(true, {}, opts.scroll, opts.prev);
            opts.next = $.extend(true, {}, opts.scroll, opts.next);
            opts.pagination = $.extend(true, {}, opts.scroll, opts.pagination);
            //	swipe and mousewheel extend later on, per direction

            opts.auto = go_complementAutoObject($tt0, opts.auto);
            opts.prev = go_complementPrevNextObject($tt0, opts.prev);
            opts.next = go_complementPrevNextObject($tt0, opts.next);
            opts.pagination = go_complementPaginationObject($tt0, opts.pagination);
            opts.swipe = go_complementSwipeObject($tt0, opts.swipe);
            opts.mousewheel = go_complementMousewheelObject($tt0, opts.mousewheel);

            if (opts.synchronise) {
                opts.synchronise = cf_getSynchArr(opts.synchronise);
            }


            //	DEPRECATED
            if (opts.auto.onPauseStart) {
                opts.auto.onTimeoutStart = opts.auto.onPauseStart;
                deprecated('auto.onPauseStart', 'auto.onTimeoutStart');
            }
            if (opts.auto.onPausePause) {
                opts.auto.onTimeoutPause = opts.auto.onPausePause;
                deprecated('auto.onPausePause', 'auto.onTimeoutPause');
            }
            if (opts.auto.onPauseEnd) {
                opts.auto.onTimeoutEnd = opts.auto.onPauseEnd;
                deprecated('auto.onPauseEnd', 'auto.onTimeoutEnd');
            }
            if (opts.auto.pauseDuration) {
                opts.auto.timeoutDuration = opts.auto.pauseDuration;
                deprecated('auto.pauseDuration', 'auto.timeoutDuration');
            }
            //	/DEPRECATED


        };	//	/init


        FN._build = function () {
            $cfs.data('_cfs_isCarousel', true);

            var a_itm = $cfs.children(),
				orgCSS = in_mapCss($cfs, ['textAlign', 'float', 'position', 'top', 'right', 'bottom', 'left', 'zIndex', 'width', 'height', 'marginTop', 'marginRight', 'marginBottom', 'marginLeft']),
				newPosition = 'relative';

            switch (orgCSS.position) {
                case 'absolute':
                case 'fixed':
                    newPosition = orgCSS.position;
                    break;
            }

            if (conf.wrapper == 'parent') {
                sz_storeOrigCss($wrp);
            }
            else {
                $wrp.css(orgCSS);
            }
            $wrp.css({
                'overflow': 'hidden',
                'position': newPosition
            });

            sz_storeOrigCss($cfs);
            $cfs.data('_cfs_origCssZindex', orgCSS.zIndex);
            $cfs.css({
                'textAlign': 'left',
                'float': 'none',
                'position': 'absolute',
                'top': 0,
                'right': 'auto',
                'bottom': 'auto',
                'left': 0,
                'marginTop': 0,
                'marginRight': 0,
                'marginBottom': 0,
                'marginLeft': 0
            });

            sz_storeMargin(a_itm, opts);
            sz_storeOrigCss(a_itm);
            if (opts.responsive) {
                sz_setResponsiveSizes(opts, a_itm);
            }

        };	//	/build


        FN._bind_events = function () {
            FN._unbind_events();


            //	stop event
            $cfs.bind(cf_e('stop', conf), function (e, imm) {
                e.stopPropagation();

                //	button
                if (!crsl.isStopped) {
                    if (opts.auto.button) {
                        opts.auto.button.addClass(cf_c('stopped', conf));
                    }
                }

                //	set stopped
                crsl.isStopped = true;

                if (opts.auto.play) {
                    opts.auto.play = false;
                    $cfs.trigger(cf_e('pause', conf), imm);
                }
                return true;
            });


            //	finish event
            $cfs.bind(cf_e('finish', conf), function (e) {
                e.stopPropagation();
                if (crsl.isScrolling) {
                    sc_stopScroll(scrl);
                }
                return true;
            });


            //	pause event
            $cfs.bind(cf_e('pause', conf), function (e, imm, res) {
                e.stopPropagation();
                tmrs = sc_clearTimers(tmrs);

                //	immediately pause
                if (imm && crsl.isScrolling) {
                    scrl.isStopped = true;
                    var nst = getTime() - scrl.startTime;
                    scrl.duration -= nst;
                    if (scrl.pre) {
                        scrl.pre.duration -= nst;
                    }
                    if (scrl.post) {
                        scrl.post.duration -= nst;
                    }
                    sc_stopScroll(scrl, false);
                }

                //	update remaining pause-time
                if (!crsl.isPaused && !crsl.isScrolling) {
                    if (res) {
                        tmrs.timePassed += getTime() - tmrs.startTime;
                    }
                }

                //	button
                if (!crsl.isPaused) {
                    if (opts.auto.button) {
                        opts.auto.button.addClass(cf_c('paused', conf));
                    }
                }

                //	set paused
                crsl.isPaused = true;

                //	pause pause callback
                if (opts.auto.onTimeoutPause) {
                    var dur1 = opts.auto.timeoutDuration - tmrs.timePassed,
						perc = 100 - Math.ceil(dur1 * 100 / opts.auto.timeoutDuration);

                    opts.auto.onTimeoutPause.call($tt0, perc, dur1);
                }
                return true;
            });


            //	play event
            $cfs.bind(cf_e('play', conf), function (e, dir, del, res) {
                e.stopPropagation();
                tmrs = sc_clearTimers(tmrs);

                //	sort params
                var v = [dir, del, res],
					t = ['string', 'number', 'boolean'],
					a = cf_sortParams(v, t);

                dir = a[0];
                del = a[1];
                res = a[2];

                if (dir != 'prev' && dir != 'next') {
                    dir = crsl.direction;
                }
                if (!is_number(del)) {
                    del = 0;
                }
                if (!is_boolean(res)) {
                    res = false;
                }

                //	stopped?
                if (res) {
                    crsl.isStopped = false;
                    opts.auto.play = true;
                }
                if (!opts.auto.play) {
                    e.stopImmediatePropagation();
                    return debug(conf, 'Carousel stopped: Not scrolling.');
                }

                //	button
                if (crsl.isPaused) {
                    if (opts.auto.button) {
                        opts.auto.button.removeClass(cf_c('stopped', conf));
                        opts.auto.button.removeClass(cf_c('paused', conf));
                    }
                }

                //	set playing
                crsl.isPaused = false;
                tmrs.startTime = getTime();

                //	timeout the scrolling
                var dur1 = opts.auto.timeoutDuration + del;
                dur2 = dur1 - tmrs.timePassed;
                perc = 100 - Math.ceil(dur2 * 100 / dur1);

                if (opts.auto.progress) {
                    tmrs.progress = setInterval(function () {
                        var pasd = getTime() - tmrs.startTime + tmrs.timePassed,
							perc = Math.ceil(pasd * 100 / dur1);
                        opts.auto.progress.updater.call(opts.auto.progress.bar[0], perc);
                    }, opts.auto.progress.interval);
                }

                tmrs.auto = setTimeout(function () {
                    if (opts.auto.progress) {
                        opts.auto.progress.updater.call(opts.auto.progress.bar[0], 100);
                    }
                    if (opts.auto.onTimeoutEnd) {
                        opts.auto.onTimeoutEnd.call($tt0, perc, dur2);
                    }
                    if (crsl.isScrolling) {
                        $cfs.trigger(cf_e('play', conf), dir);
                    }
                    else {
                        $cfs.trigger(cf_e(dir, conf), opts.auto);
                    }
                }, dur2);

                //	pause start callback
                if (opts.auto.onTimeoutStart) {
                    opts.auto.onTimeoutStart.call($tt0, perc, dur2);
                }

                return true;
            });


            //	resume event
            $cfs.bind(cf_e('resume', conf), function (e) {
                e.stopPropagation();
                if (scrl.isStopped) {
                    scrl.isStopped = false;
                    crsl.isPaused = false;
                    crsl.isScrolling = true;
                    scrl.startTime = getTime();
                    sc_startScroll(scrl, conf);
                }
                else {
                    $cfs.trigger(cf_e('play', conf));
                }
                return true;
            });


            //	prev + next events
            $cfs.bind(cf_e('prev', conf) + ' ' + cf_e('next', conf), function (e, obj, num, clb, que) {
                e.stopPropagation();

                //	stopped or hidden carousel, don't scroll, don't queue
                if (crsl.isStopped || $cfs.is(':hidden')) {
                    e.stopImmediatePropagation();
                    return debug(conf, 'Carousel stopped or hidden: Not scrolling.');
                }

                //	not enough items
                var minimum = (is_number(opts.items.minimum)) ? opts.items.minimum : opts.items.visible + 1;
                if (minimum > itms.total) {
                    e.stopImmediatePropagation();
                    return debug(conf, 'Not enough items (' + itms.total + ' total, ' + minimum + ' needed): Not scrolling.');
                }

                //	get config
                var v = [obj, num, clb, que],
					t = ['object', 'number/string', 'function', 'boolean'],
					a = cf_sortParams(v, t);

                obj = a[0];
                num = a[1];
                clb = a[2];
                que = a[3];

                var eType = e.type.slice(conf.events.prefix.length);

                if (!is_object(obj)) {
                    obj = {};
                }
                if (is_function(clb)) {
                    obj.onAfter = clb;
                }
                if (is_boolean(que)) {
                    obj.queue = que;
                }
                obj = $.extend(true, {}, opts[eType], obj);

                //	test conditions callback
                if (obj.conditions && !obj.conditions.call($tt0, eType)) {
                    e.stopImmediatePropagation();
                    return debug(conf, 'Callback "conditions" returned false.');
                }

                if (!is_number(num)) {
                    if (opts.items.filter != '*') {
                        num = 'visible';
                    }
                    else {
                        var arr = [num, obj.items, opts[eType].items];
                        for (var a = 0, l = arr.length; a < l; a++) {
                            if (is_number(arr[a]) || arr[a] == 'page' || arr[a] == 'visible') {
                                num = arr[a];
                                break;
                            }
                        }
                    }
                    switch (num) {
                        case 'page':
                            e.stopImmediatePropagation();
                            return $cfs.triggerHandler(cf_e(eType + 'Page', conf), [obj, clb]);
                            break;

                        case 'visible':
                            if (!opts.items.visibleConf.variable && opts.items.filter == '*') {
                                num = opts.items.visible;
                            }
                            break;
                    }
                }

                //	resume animation, add current to queue
                if (scrl.isStopped) {
                    $cfs.trigger(cf_e('resume', conf));
                    $cfs.trigger(cf_e('queue', conf), [eType, [obj, num, clb]]);
                    e.stopImmediatePropagation();
                    return debug(conf, 'Carousel resumed scrolling.');
                }

                //	queue if scrolling
                if (obj.duration > 0) {
                    if (crsl.isScrolling) {
                        if (obj.queue) {
                            if (obj.queue == 'last') {
                                queu = [];
                            }
                            if (obj.queue != 'first' || queu.length == 0) {
                                $cfs.trigger(cf_e('queue', conf), [eType, [obj, num, clb]]);
                            }
                        }
                        e.stopImmediatePropagation();
                        return debug(conf, 'Carousel currently scrolling.');
                    }
                }

                tmrs.timePassed = 0;
                $cfs.trigger(cf_e('slide_' + eType, conf), [obj, num]);

                //	synchronise
                if (opts.synchronise) {
                    var s = opts.synchronise,
						c = [obj, num];

                    for (var j = 0, l = s.length; j < l; j++) {
                        var d = eType;
                        if (!s[j][2]) {
                            d = (d == 'prev') ? 'next' : 'prev';
                        }
                        if (!s[j][1]) {
                            c[0] = s[j][0].triggerHandler('_cfs_triggerEvent', ['configuration', d]);
                        }
                        c[1] = num + s[j][3];
                        s[j][0].trigger('_cfs_triggerEvent', ['slide_' + d, c]);
                    }
                }
                return true;
            });


            //	prev event
            $cfs.bind(cf_e('slide_prev', conf), function (e, sO, nI) {
                e.stopPropagation();
                var a_itm = $cfs.children();

                //	non-circular at start, scroll to end
                if (!opts.circular) {
                    if (itms.first == 0) {
                        if (opts.infinite) {
                            $cfs.trigger(cf_e('next', conf), itms.total - 1);
                        }
                        return e.stopImmediatePropagation();
                    }
                }

                sz_resetMargin(a_itm, opts);

                //	find number of items to scroll
                if (!is_number(nI)) {
                    if (opts.items.visibleConf.variable) {
                        nI = gn_getVisibleItemsPrev(a_itm, opts, itms.total - 1);
                    }
                    else if (opts.items.filter != '*') {
                        var xI = (is_number(sO.items)) ? sO.items : gn_getVisibleOrg($cfs, opts);
                        nI = gn_getScrollItemsPrevFilter(a_itm, opts, itms.total - 1, xI);
                    }
                    else {
                        nI = opts.items.visible;
                    }
                    nI = cf_getAdjust(nI, opts, sO.items, $tt0);
                }

                //	prevent non-circular from scrolling to far
                if (!opts.circular) {
                    if (itms.total - nI < itms.first) {
                        nI = itms.total - itms.first;
                    }
                }

                //	set new number of visible items
                opts.items.visibleConf.old = opts.items.visible;
                if (opts.items.visibleConf.variable) {
                    var vI = cf_getItemsAdjust(gn_getVisibleItemsNext(a_itm, opts, itms.total - nI), opts, opts.items.visibleConf.adjust, $tt0);
                    if (opts.items.visible + nI <= vI && nI < itms.total) {
                        nI++;
                        vI = cf_getItemsAdjust(gn_getVisibleItemsNext(a_itm, opts, itms.total - nI), opts, opts.items.visibleConf.adjust, $tt0);
                    }
                    opts.items.visible = vI;
                }
                else if (opts.items.filter != '*') {
                    var vI = gn_getVisibleItemsNextFilter(a_itm, opts, itms.total - nI);
                    opts.items.visible = cf_getItemsAdjust(vI, opts, opts.items.visibleConf.adjust, $tt0);
                }

                sz_resetMargin(a_itm, opts, true);

                //	scroll 0, don't scroll
                if (nI == 0) {
                    e.stopImmediatePropagation();
                    return debug(conf, '0 items to scroll: Not scrolling.');
                }
                debug(conf, 'Scrolling ' + nI + ' items backward.');


                //	save new config
                itms.first += nI;
                while (itms.first >= itms.total) {
                    itms.first -= itms.total;
                }

                //	non-circular callback
                if (!opts.circular) {
                    if (itms.first == 0 && sO.onEnd) {
                        sO.onEnd.call($tt0, 'prev');
                    }
                    if (!opts.infinite) {
                        nv_enableNavi(opts, itms.first, conf);
                    }
                }

                //	rearrange items
                $cfs.children().slice(itms.total - nI, itms.total).prependTo($cfs);
                if (itms.total < opts.items.visible + nI) {
                    $cfs.children().slice(0, (opts.items.visible + nI) - itms.total).clone(true).appendTo($cfs);
                }

                //	the needed items
                var a_itm = $cfs.children(),
					i_old = gi_getOldItemsPrev(a_itm, opts, nI),
					i_new = gi_getNewItemsPrev(a_itm, opts),
					i_cur_l = a_itm.eq(nI - 1),
					i_old_l = i_old.last(),
					i_new_l = i_new.last();

                sz_resetMargin(a_itm, opts);

                var pL = 0,
					pR = 0;

                if (opts.align) {
                    var p = cf_getAlignPadding(i_new, opts);
                    pL = p[0];
                    pR = p[1];
                }
                var oL = (pL < 0) ? opts.padding[opts.d[3]] : 0;

                //	hide items for fx directscroll
                var hiddenitems = false,
					i_skp = $();
                if (opts.items.visible < nI) {
                    i_skp = a_itm.slice(opts.items.visibleConf.old, nI);
                    if (sO.fx == 'directscroll') {
                        var orgW = opts.items[opts.d['width']];
                        hiddenitems = i_skp;
                        i_cur_l = i_new_l;
                        sc_hideHiddenItems(hiddenitems);
                        opts.items[opts.d['width']] = 'variable';
                    }
                }

                //	save new sizes
                var $cf2 = false,
					i_siz = ms_getTotalSize(a_itm.slice(0, nI), opts, 'width'),
					w_siz = cf_mapWrapperSizes(ms_getSizes(i_new, opts, true), opts, !opts.usePadding),
					i_siz_vis = 0,
					a_cfs = {},
					a_wsz = {},
					a_cur = {},
					a_old = {},
					a_new = {},
					a_lef = {},
					a_lef_vis = {},
					a_dur = sc_getDuration(sO, opts, nI, i_siz);

                switch (sO.fx) {
                    case 'cover':
                    case 'cover-fade':
                        i_siz_vis = ms_getTotalSize(a_itm.slice(0, opts.items.visible), opts, 'width');
                        break;
                }

                if (hiddenitems) {
                    opts.items[opts.d['width']] = orgW;
                }

                sz_resetMargin(a_itm, opts, true);
                if (pR >= 0) {
                    sz_resetMargin(i_old_l, opts, opts.padding[opts.d[1]]);
                }
                if (pL >= 0) {
                    sz_resetMargin(i_cur_l, opts, opts.padding[opts.d[3]]);
                }

                if (opts.align) {
                    opts.padding[opts.d[1]] = pR;
                    opts.padding[opts.d[3]] = pL;
                }

                a_lef[opts.d['left']] = -(i_siz - oL);
                a_lef_vis[opts.d['left']] = -(i_siz_vis - oL);
                a_wsz[opts.d['left']] = w_siz[opts.d['width']];

                //	scrolling functions
                var _s_wrapper = function () { },
					_a_wrapper = function () { },
					_s_paddingold = function () { },
					_a_paddingold = function () { },
					_s_paddingnew = function () { },
					_a_paddingnew = function () { },
					_s_paddingcur = function () { },
					_a_paddingcur = function () { },
					_onafter = function () { },
					_moveitems = function () { },
					_position = function () { };

                //	clone carousel
                switch (sO.fx) {
                    case 'crossfade':
                    case 'cover':
                    case 'cover-fade':
                    case 'uncover':
                    case 'uncover-fade':
                        $cf2 = $cfs.clone(true).appendTo($wrp);
                        break;
                }
                switch (sO.fx) {
                    case 'crossfade':
                    case 'uncover':
                    case 'uncover-fade':
                        $cf2.children().slice(0, nI).remove();
                        $cf2.children().slice(opts.items.visibleConf.old).remove();
                        break;

                    case 'cover':
                    case 'cover-fade':
                        $cf2.children().slice(opts.items.visible).remove();
                        $cf2.css(a_lef_vis);
                        break;
                }

                $cfs.css(a_lef);

                //	reset all scrolls
                scrl = sc_setScroll(a_dur, sO.easing, conf);

                //	animate / set carousel
                a_cfs[opts.d['left']] = (opts.usePadding) ? opts.padding[opts.d[3]] : 0;

                //	animate / set wrapper
                if (opts[opts.d['width']] == 'variable' || opts[opts.d['height']] == 'variable') {
                    _s_wrapper = function () {
                        $wrp.css(w_siz);
                    };
                    _a_wrapper = function () {
                        scrl.anims.push([$wrp, w_siz]);
                    };
                }

                //	animate / set items
                if (opts.usePadding) {
                    if (i_new_l.not(i_cur_l).length) {
                        a_cur[opts.d['marginRight']] = i_cur_l.data('_cfs_origCssMargin');

                        if (pL < 0) {
                            i_cur_l.css(a_cur);
                        }
                        else {
                            _s_paddingcur = function () {
                                i_cur_l.css(a_cur);
                            };
                            _a_paddingcur = function () {
                                scrl.anims.push([i_cur_l, a_cur]);
                            };
                        }
                    }
                    switch (sO.fx) {
                        case 'cover':
                        case 'cover-fade':
                            $cf2.children().eq(nI - 1).css(a_cur);
                            break;
                    }

                    if (i_new_l.not(i_old_l).length) {
                        a_old[opts.d['marginRight']] = i_old_l.data('_cfs_origCssMargin');
                        _s_paddingold = function () {
                            i_old_l.css(a_old);
                        };
                        _a_paddingold = function () {
                            scrl.anims.push([i_old_l, a_old]);
                        };
                    }

                    if (pR >= 0) {
                        a_new[opts.d['marginRight']] = i_new_l.data('_cfs_origCssMargin') + opts.padding[opts.d[1]];
                        _s_paddingnew = function () {
                            i_new_l.css(a_new);
                        };
                        _a_paddingnew = function () {
                            scrl.anims.push([i_new_l, a_new]);
                        };
                    }
                }

                //	set position
                _position = function () {
                    $cfs.css(a_cfs);
                };


                var overFill = opts.items.visible + nI - itms.total;

                //	rearrange items
                _moveitems = function () {
                    if (overFill > 0) {
                        $cfs.children().slice(itms.total).remove();
                        i_old = $($cfs.children().slice(itms.total - (opts.items.visible - overFill)).get().concat($cfs.children().slice(0, overFill).get()));
                    }
                    sc_showHiddenItems(hiddenitems);

                    if (opts.usePadding) {
                        var l_itm = $cfs.children().eq(opts.items.visible + nI - 1);
                        l_itm.css(opts.d['marginRight'], l_itm.data('_cfs_origCssMargin'));
                    }
                };


                var cb_arguments = sc_mapCallbackArguments(i_old, i_skp, i_new, nI, 'prev', a_dur, w_siz);

                //	fire onAfter callbacks
                _onafter = function () {
                    sc_afterScroll($cfs, $cf2, sO);
                    crsl.isScrolling = false;
                    clbk.onAfter = sc_fireCallbacks($tt0, sO, 'onAfter', cb_arguments, clbk);
                    queu = sc_fireQueue($cfs, queu, conf);

                    if (!crsl.isPaused) {
                        $cfs.trigger(cf_e('play', conf));
                    }
                };

                //	fire onBefore callback
                crsl.isScrolling = true;
                tmrs = sc_clearTimers(tmrs);
                clbk.onBefore = sc_fireCallbacks($tt0, sO, 'onBefore', cb_arguments, clbk);

                switch (sO.fx) {
                    case 'none':
                        $cfs.css(a_cfs);
                        _s_wrapper();
                        _s_paddingold();
                        _s_paddingnew();
                        _s_paddingcur();
                        _position();
                        _moveitems();
                        _onafter();
                        break;

                    case 'fade':
                        scrl.anims.push([$cfs, { 'opacity': 0 }, function () {
                            _s_wrapper();
                            _s_paddingold();
                            _s_paddingnew();
                            _s_paddingcur();
                            _position();
                            _moveitems();
                            scrl = sc_setScroll(a_dur, sO.easing, conf);
                            scrl.anims.push([$cfs, { 'opacity': 1 }, _onafter]);
                            sc_startScroll(scrl, conf);
                        }]);
                        break;

                    case 'crossfade':
                        $cfs.css({ 'opacity': 0 });
                        scrl.anims.push([$cf2, { 'opacity': 0 }]);
                        scrl.anims.push([$cfs, { 'opacity': 1 }, _onafter]);
                        _a_wrapper();
                        _s_paddingold();
                        _s_paddingnew();
                        _s_paddingcur();
                        _position();
                        _moveitems();
                        break;

                    case 'cover':
                        scrl.anims.push([$cf2, a_cfs, function () {
                            _s_paddingold();
                            _s_paddingnew();
                            _s_paddingcur();
                            _position();
                            _moveitems();
                            _onafter();
                        }]);
                        _a_wrapper();
                        break;

                    case 'cover-fade':
                        scrl.anims.push([$cfs, { 'opacity': 0 }]);
                        scrl.anims.push([$cf2, a_cfs, function () {
                            _s_paddingold();
                            _s_paddingnew();
                            _s_paddingcur();
                            _position();
                            _moveitems();
                            _onafter();
                        }]);
                        _a_wrapper();
                        break;

                    case 'uncover':
                        scrl.anims.push([$cf2, a_wsz, _onafter]);
                        _a_wrapper();
                        _s_paddingold();
                        _s_paddingnew();
                        _s_paddingcur();
                        _position();
                        _moveitems();
                        break;

                    case 'uncover-fade':
                        $cfs.css({ 'opacity': 0 });
                        scrl.anims.push([$cfs, { 'opacity': 1 }]);
                        scrl.anims.push([$cf2, a_wsz, _onafter]);
                        _a_wrapper();
                        _s_paddingold();
                        _s_paddingnew();
                        _s_paddingcur();
                        _position();
                        _moveitems();
                        break;

                    default:
                        scrl.anims.push([$cfs, a_cfs, function () {
                            _moveitems();
                            _onafter();
                        }]);
                        _a_wrapper();
                        _a_paddingold();
                        _a_paddingnew();
                        _a_paddingcur();
                        break;
                }

                sc_startScroll(scrl, conf);
                cf_setCookie(opts.cookie, $cfs, conf);

                $cfs.trigger(cf_e('updatePageStatus', conf), [false, w_siz]);

                return true;
            });


            //	next event
            $cfs.bind(cf_e('slide_next', conf), function (e, sO, nI) {
                e.stopPropagation();
                var a_itm = $cfs.children();

                //	non-circular at end, scroll to start
                if (!opts.circular) {
                    if (itms.first == opts.items.visible) {
                        if (opts.infinite) {
                            $cfs.trigger(cf_e('prev', conf), itms.total - 1);
                        }
                        return e.stopImmediatePropagation();
                    }
                }

                sz_resetMargin(a_itm, opts);

                //	find number of items to scroll
                if (!is_number(nI)) {
                    if (opts.items.filter != '*') {
                        var xI = (is_number(sO.items)) ? sO.items : gn_getVisibleOrg($cfs, opts);
                        nI = gn_getScrollItemsNextFilter(a_itm, opts, 0, xI);
                    }
                    else {
                        nI = opts.items.visible;
                    }
                    nI = cf_getAdjust(nI, opts, sO.items, $tt0);
                }

                var lastItemNr = (itms.first == 0) ? itms.total : itms.first;

                //	prevent non-circular from scrolling to far
                if (!opts.circular) {
                    if (opts.items.visibleConf.variable) {
                        var vI = gn_getVisibleItemsNext(a_itm, opts, nI),
							xI = gn_getVisibleItemsPrev(a_itm, opts, lastItemNr - 1);
                    }
                    else {
                        var vI = opts.items.visible,
							xI = opts.items.visible;
                    }

                    if (nI + vI > lastItemNr) {
                        nI = lastItemNr - xI;
                    }
                }

                //	set new number of visible items
                opts.items.visibleConf.old = opts.items.visible;
                if (opts.items.visibleConf.variable) {
                    var vI = cf_getItemsAdjust(gn_getVisibleItemsNextTestCircular(a_itm, opts, nI, lastItemNr), opts, opts.items.visibleConf.adjust, $tt0);
                    while (opts.items.visible - nI >= vI && nI < itms.total) {
                        nI++;
                        vI = cf_getItemsAdjust(gn_getVisibleItemsNextTestCircular(a_itm, opts, nI, lastItemNr), opts, opts.items.visibleConf.adjust, $tt0);
                    }
                    opts.items.visible = vI;
                }
                else if (opts.items.filter != '*') {
                    var vI = gn_getVisibleItemsNextFilter(a_itm, opts, nI);
                    opts.items.visible = cf_getItemsAdjust(vI, opts, opts.items.visibleConf.adjust, $tt0);
                }

                sz_resetMargin(a_itm, opts, true);

                //	scroll 0, don't scroll
                if (nI == 0) {
                    e.stopImmediatePropagation();
                    return debug(conf, '0 items to scroll: Not scrolling.');
                }
                debug(conf, 'Scrolling ' + nI + ' items forward.');


                //	save new config
                itms.first -= nI;
                while (itms.first < 0) {
                    itms.first += itms.total;
                }

                //	non-circular callback
                if (!opts.circular) {
                    if (itms.first == opts.items.visible && sO.onEnd) {
                        sO.onEnd.call($tt0, 'next');
                    }
                    if (!opts.infinite) {
                        nv_enableNavi(opts, itms.first, conf);
                    }
                }

                //	rearrange items
                if (itms.total < opts.items.visible + nI) {
                    $cfs.children().slice(0, (opts.items.visible + nI) - itms.total).clone(true).appendTo($cfs);
                }

                //	the needed items
                var a_itm = $cfs.children(),
					i_old = gi_getOldItemsNext(a_itm, opts),
					i_new = gi_getNewItemsNext(a_itm, opts, nI),
					i_cur_l = a_itm.eq(nI - 1),
					i_old_l = i_old.last(),
					i_new_l = i_new.last();

                sz_resetMargin(a_itm, opts);

                var pL = 0,
					pR = 0;

                if (opts.align) {
                    var p = cf_getAlignPadding(i_new, opts);
                    pL = p[0];
                    pR = p[1];
                }

                //	hide items for fx directscroll
                var hiddenitems = false,
					i_skp = $();
                if (opts.items.visibleConf.old < nI) {
                    i_skp = a_itm.slice(opts.items.visibleConf.old, nI);
                    if (sO.fx == 'directscroll') {
                        var orgW = opts.items[opts.d['width']];
                        hiddenitems = i_skp;
                        i_cur_l = i_old_l;
                        sc_hideHiddenItems(hiddenitems);
                        opts.items[opts.d['width']] = 'variable';
                    }
                }

                //	save new sizes
                var $cf2 = false,
					i_siz = ms_getTotalSize(a_itm.slice(0, nI), opts, 'width'),
					w_siz = cf_mapWrapperSizes(ms_getSizes(i_new, opts, true), opts, !opts.usePadding),
					i_siz_vis = 0,
					a_cfs = {},
					a_cfs_vis = {},
					a_cur = {},
					a_old = {},
					a_lef = {},
					a_dur = sc_getDuration(sO, opts, nI, i_siz);

                switch (sO.fx) {
                    case 'uncover':
                    case 'uncover-fade':
                        i_siz_vis = ms_getTotalSize(a_itm.slice(0, opts.items.visibleConf.old), opts, 'width');
                        break;
                }

                if (hiddenitems) {
                    opts.items[opts.d['width']] = orgW;
                }

                if (opts.align) {
                    if (opts.padding[opts.d[1]] < 0) {
                        opts.padding[opts.d[1]] = 0;
                    }
                }
                sz_resetMargin(a_itm, opts, true);
                sz_resetMargin(i_old_l, opts, opts.padding[opts.d[1]]);

                if (opts.align) {
                    opts.padding[opts.d[1]] = pR;
                    opts.padding[opts.d[3]] = pL;
                }

                a_lef[opts.d['left']] = (opts.usePadding) ? opts.padding[opts.d[3]] : 0;

                //	scrolling functions
                var _s_wrapper = function () { },
					_a_wrapper = function () { },
					_s_paddingold = function () { },
					_a_paddingold = function () { },
					_s_paddingcur = function () { },
					_a_paddingcur = function () { },
					_onafter = function () { },
					_moveitems = function () { },
					_position = function () { };

                //	clone carousel
                switch (sO.fx) {
                    case 'crossfade':
                    case 'cover':
                    case 'cover-fade':
                    case 'uncover':
                    case 'uncover-fade':
                        $cf2 = $cfs.clone(true).appendTo($wrp);
                        $cf2.children().slice(opts.items.visibleConf.old).remove();
                        break;
                }
                switch (sO.fx) {
                    case 'crossfade':
                    case 'cover':
                    case 'cover-fade':
                        $cfs.css('zIndex', 1);
                        $cf2.css('zIndex', 0);
                        break;
                }

                //	reset all scrolls
                scrl = sc_setScroll(a_dur, sO.easing, conf);

                //	animate / set carousel
                a_cfs[opts.d['left']] = -i_siz;
                a_cfs_vis[opts.d['left']] = -i_siz_vis;

                if (pL < 0) {
                    a_cfs[opts.d['left']] += pL;
                }

                //	animate / set wrapper
                if (opts[opts.d['width']] == 'variable' || opts[opts.d['height']] == 'variable') {
                    _s_wrapper = function () {
                        $wrp.css(w_siz);
                    };
                    _a_wrapper = function () {
                        scrl.anims.push([$wrp, w_siz]);
                    };
                }

                //	animate / set items
                if (opts.usePadding) {
                    var i_new_l_m = i_new_l.data('_cfs_origCssMargin');

                    if (pR >= 0) {
                        i_new_l_m += opts.padding[opts.d[1]];
                    }
                    i_new_l.css(opts.d['marginRight'], i_new_l_m);

                    if (i_cur_l.not(i_old_l).length) {
                        a_old[opts.d['marginRight']] = i_old_l.data('_cfs_origCssMargin');
                    }
                    _s_paddingold = function () {
                        i_old_l.css(a_old);
                    };
                    _a_paddingold = function () {
                        scrl.anims.push([i_old_l, a_old]);
                    };

                    var i_cur_l_m = i_cur_l.data('_cfs_origCssMargin');
                    if (pL > 0) {
                        i_cur_l_m += opts.padding[opts.d[3]];
                    }

                    a_cur[opts.d['marginRight']] = i_cur_l_m;

                    _s_paddingcur = function () {
                        i_cur_l.css(a_cur);
                    };
                    _a_paddingcur = function () {
                        scrl.anims.push([i_cur_l, a_cur]);
                    };
                }

                //	set position
                _position = function () {
                    $cfs.css(a_lef);
                };


                var overFill = opts.items.visible + nI - itms.total;

                //	rearrange items
                _moveitems = function () {
                    if (overFill > 0) {
                        $cfs.children().slice(itms.total).remove();
                    }
                    var l_itm = $cfs.children().slice(0, nI).appendTo($cfs).last();
                    if (overFill > 0) {
                        i_new = gi_getCurrentItems(a_itm, opts);
                    }
                    sc_showHiddenItems(hiddenitems);

                    if (opts.usePadding) {
                        if (itms.total < opts.items.visible + nI) {
                            var i_cur_l = $cfs.children().eq(opts.items.visible - 1);
                            i_cur_l.css(opts.d['marginRight'], i_cur_l.data('_cfs_origCssMargin') + opts.padding[opts.d[1]]);
                        }
                        l_itm.css(opts.d['marginRight'], l_itm.data('_cfs_origCssMargin'));
                    }
                };


                var cb_arguments = sc_mapCallbackArguments(i_old, i_skp, i_new, nI, 'next', a_dur, w_siz);

                //	fire onAfter callbacks
                _onafter = function () {
                    $cfs.css('zIndex', $cfs.data('_cfs_origCssZindex'));
                    sc_afterScroll($cfs, $cf2, sO);
                    crsl.isScrolling = false;
                    clbk.onAfter = sc_fireCallbacks($tt0, sO, 'onAfter', cb_arguments, clbk);
                    queu = sc_fireQueue($cfs, queu, conf);

                    if (!crsl.isPaused) {
                        $cfs.trigger(cf_e('play', conf));
                    }
                };

                //	fire onBefore callbacks
                crsl.isScrolling = true;
                tmrs = sc_clearTimers(tmrs);
                clbk.onBefore = sc_fireCallbacks($tt0, sO, 'onBefore', cb_arguments, clbk);

                switch (sO.fx) {
                    case 'none':
                        $cfs.css(a_cfs);
                        _s_wrapper();
                        _s_paddingold();
                        _s_paddingcur();
                        _position();
                        _moveitems();
                        _onafter();
                        break;

                    case 'fade':
                        scrl.anims.push([$cfs, { 'opacity': 0 }, function () {
                            _s_wrapper();
                            _s_paddingold();
                            _s_paddingcur();
                            _position();
                            _moveitems();
                            scrl = sc_setScroll(a_dur, sO.easing, conf);
                            scrl.anims.push([$cfs, { 'opacity': 1 }, _onafter]);
                            sc_startScroll(scrl, conf);
                        }]);
                        break;

                    case 'crossfade':
                        $cfs.css({ 'opacity': 0 });
                        scrl.anims.push([$cf2, { 'opacity': 0 }]);
                        scrl.anims.push([$cfs, { 'opacity': 1 }, _onafter]);
                        _a_wrapper();
                        _s_paddingold();
                        _s_paddingcur();
                        _position();
                        _moveitems();
                        break;

                    case 'cover':
                        $cfs.css(opts.d['left'], $wrp[opts.d['width']]());
                        scrl.anims.push([$cfs, a_lef, _onafter]);
                        _a_wrapper();
                        _s_paddingold();
                        _s_paddingcur();
                        _moveitems();
                        break;

                    case 'cover-fade':
                        $cfs.css(opts.d['left'], $wrp[opts.d['width']]());
                        scrl.anims.push([$cf2, { 'opacity': 0 }]);
                        scrl.anims.push([$cfs, a_lef, _onafter]);
                        _a_wrapper();
                        _s_paddingold();
                        _s_paddingcur();
                        _moveitems();
                        break;

                    case 'uncover':
                        scrl.anims.push([$cf2, a_cfs_vis, _onafter]);
                        _a_wrapper();
                        _s_paddingold();
                        _s_paddingcur();
                        _position();
                        _moveitems();
                        break;

                    case 'uncover-fade':
                        $cfs.css({ 'opacity': 0 });
                        scrl.anims.push([$cfs, { 'opacity': 1 }]);
                        scrl.anims.push([$cf2, a_cfs_vis, _onafter]);
                        _a_wrapper();
                        _s_paddingold();
                        _s_paddingcur();
                        _position();
                        _moveitems();
                        break;

                    default:
                        scrl.anims.push([$cfs, a_cfs, function () {
                            _position();
                            _moveitems();
                            _onafter();
                        }]);
                        _a_wrapper();
                        _a_paddingold();
                        _a_paddingcur();
                        break;
                }

                sc_startScroll(scrl, conf);
                cf_setCookie(opts.cookie, $cfs, conf);

                $cfs.trigger(cf_e('updatePageStatus', conf), [false, w_siz]);

                return true;
            });


            //	slideTo event
            $cfs.bind(cf_e('slideTo', conf), function (e, num, dev, org, obj, dir, clb) {
                e.stopPropagation();

                var v = [num, dev, org, obj, dir, clb],
					t = ['string/number/object', 'number', 'boolean', 'object', 'string', 'function'],
					a = cf_sortParams(v, t);

                obj = a[3];
                dir = a[4];
                clb = a[5];

                num = gn_getItemIndex(a[0], a[1], a[2], itms, $cfs);

                if (num == 0) {
                    return false;
                }
                if (!is_object(obj)) {
                    obj = false;
                }

                if (dir != 'prev' && dir != 'next') {
                    if (opts.circular) {
                        dir = (num <= itms.total / 2) ? 'next' : 'prev';
                    }
                    else {
                        dir = (itms.first == 0 || itms.first > num) ? 'next' : 'prev';
                    }
                }

                if (dir == 'prev') {
                    num = itms.total - num;
                }
                $cfs.trigger(cf_e(dir, conf), [obj, num, clb]);

                return true;
            });


            //	prevPage event
            $cfs.bind(cf_e('prevPage', conf), function (e, obj, clb) {
                e.stopPropagation();
                var cur = $cfs.triggerHandler(cf_e('currentPage', conf));
                return $cfs.triggerHandler(cf_e('slideToPage', conf), [cur - 1, obj, 'prev', clb]);
            });


            //	nextPage event
            $cfs.bind(cf_e('nextPage', conf), function (e, obj, clb) {
                e.stopPropagation();
                var cur = $cfs.triggerHandler(cf_e('currentPage', conf));
                return $cfs.triggerHandler(cf_e('slideToPage', conf), [cur + 1, obj, 'next', clb]);
            });


            //	slideToPage event
            $cfs.bind(cf_e('slideToPage', conf), function (e, pag, obj, dir, clb) {
                e.stopPropagation();
                if (!is_number(pag)) {
                    pag = $cfs.triggerHandler(cf_e('currentPage', conf));
                }
                var ipp = opts.pagination.items || opts.items.visible,
					max = Math.ceil(itms.total / ipp) - 1;

                if (pag < 0) {
                    pag = max;
                }
                if (pag > max) {
                    pag = 0;
                }
                return $cfs.triggerHandler(cf_e('slideTo', conf), [pag * ipp, 0, true, obj, dir, clb]);
            });

            //	jumpToStart event
            $cfs.bind(cf_e('jumpToStart', conf), function (e, s) {
                e.stopPropagation();
                if (s) {
                    s = gn_getItemIndex(s, 0, true, itms, $cfs);
                }
                else {
                    s = 0;
                }

                s += itms.first;
                if (s != 0) {
                    if (itms.total > 0) {
                        while (s > itms.total) {
                            s -= itms.total;
                        }
                    }
                    $cfs.prepend($cfs.children().slice(s, itms.total));
                }
                return true;
            });


            //	synchronise event
            $cfs.bind(cf_e('synchronise', conf), function (e, s) {
                e.stopPropagation();
                if (s) {
                    s = cf_getSynchArr(s);
                }
                else if (opts.synchronise) {
                    s = opts.synchronise;
                }
                else {
                    return debug(conf, 'No carousel to synchronise.');
                }

                var n = $cfs.triggerHandler(cf_e('currentPosition', conf)),
					x = true;

                for (var j = 0, l = s.length; j < l; j++) {
                    if (!s[j][0].triggerHandler(cf_e('slideTo', conf), [n, s[j][3], true])) {
                        x = false;
                    }
                }
                return x;
            });


            //	queue event
            $cfs.bind(cf_e('queue', conf), function (e, dir, opt) {
                e.stopPropagation();
                if (is_function(dir)) {
                    dir.call($tt0, queu);
                }
                else if (is_array(dir)) {
                    queu = dir;
                }
                else if (!is_undefined(dir)) {
                    queu.push([dir, opt]);
                }
                return queu;
            });


            //	insertItem event
            $cfs.bind(cf_e('insertItem', conf), function (e, itm, num, org, dev) {
                e.stopPropagation();

                var v = [itm, num, org, dev],
					t = ['string/object', 'string/number/object', 'boolean', 'number'],
					a = cf_sortParams(v, t);

                itm = a[0];
                num = a[1];
                org = a[2];
                dev = a[3];

                if (is_object(itm) && !is_jquery(itm)) {
                    itm = $(itm);
                }
                else if (is_string(itm)) {
                    itm = $(itm);
                }
                if (!is_jquery(itm) || itm.length == 0) {
                    return debug(conf, 'Not a valid object.');
                }

                if (is_undefined(num)) {
                    num = 'end';
                }

                sz_storeMargin(itm, opts);
                sz_storeOrigCss(itm);

                var orgNum = num,
					before = 'before';

                if (num == 'end') {
                    if (org) {
                        if (itms.first == 0) {
                            num = itms.total - 1;
                            before = 'after';
                        }
                        else {
                            num = itms.first;
                            itms.first += itm.length;
                        }
                        if (num < 0) {
                            num = 0;
                        }
                    }
                    else {
                        num = itms.total - 1;
                        before = 'after';
                    }
                }
                else {
                    num = gn_getItemIndex(num, dev, org, itms, $cfs);
                }

                var $cit = $cfs.children().eq(num);
                if ($cit.length) {
                    $cit[before](itm);
                }
                else {
                    debug(conf, 'Correct insert-position not found! Appending item to the end.');
                    $cfs.append(itm);
                }

                if (orgNum != 'end' && !org) {
                    if (num < itms.first) {
                        itms.first += itm.length;
                    }
                }
                itms.total = $cfs.children().length;
                if (itms.first >= itms.total) {
                    itms.first -= itms.total;
                }

                $cfs.trigger(cf_e('updateSizes', conf));
                $cfs.trigger(cf_e('linkAnchors', conf));

                return true;
            });


            //	removeItem event
            $cfs.bind(cf_e('removeItem', conf), function (e, num, org, dev) {
                e.stopPropagation();

                var v = [num, org, dev],
					t = ['string/number/object', 'boolean', 'number'],
					a = cf_sortParams(v, t);

                num = a[0];
                org = a[1];
                dev = a[2];

                var removed = false;

                if (num instanceof $ && num.length > 1) {
                    $removed = $();
                    num.each(function (i, el) {
                        var $rem = $cfs.trigger(cf_e('removeItem', conf), [$(this), org, dev]);
                        if ($rem) {
                            $removed = $removed.add($rem);
                        }
                    });
                    return $removed;
                }

                if (is_undefined(num) || num == 'end') {
                    $removed = $cfs.children().last();
                }
                else {
                    num = gn_getItemIndex(num, dev, org, itms, $cfs);
                    var $removed = $cfs.children().eq(num);
                    if ($removed.length) {
                        if (num < itms.first) {
                            itms.first -= $removed.length;
                        }
                    }
                }
                if ($removed && $removed.length) {
                    $removed.detach();
                    itms.total = $cfs.children().length;
                    $cfs.trigger(cf_e('updateSizes', conf));
                }

                return $removed;
            });


            //	onBefore and onAfter event
            $cfs.bind(cf_e('onBefore', conf) + ' ' + cf_e('onAfter', conf), function (e, fn) {
                e.stopPropagation();
                var eType = e.type.slice(conf.events.prefix.length);
                if (is_array(fn)) {
                    clbk[eType] = fn;
                }
                if (is_function(fn)) {
                    clbk[eType].push(fn);
                }
                return clbk[eType];
            });


            //	currentPosition event
            $cfs.bind(cf_e('currentPosition', conf), function (e, fn) {
                e.stopPropagation();
                if (itms.first == 0) {
                    var val = 0;
                }
                else {
                    var val = itms.total - itms.first;
                }
                if (is_function(fn)) {
                    fn.call($tt0, val);
                }
                return val;
            });


            //	currentPage event
            $cfs.bind(cf_e('currentPage', conf), function (e, fn) {
                e.stopPropagation();
                var ipp = opts.pagination.items || opts.items.visible,
					max = Math.ceil(itms.total / ipp - 1),
					nr;
                if (itms.first == 0) {
                    nr = 0;
                }
                else if (itms.first < itms.total % ipp) {
                    nr = 0;
                }
                else if (itms.first == ipp && !opts.circular) {
                    nr = max;
                }
                else {
                    nr = Math.round((itms.total - itms.first) / ipp);
                }
                if (nr < 0) {
                    nr = 0;
                }
                if (nr > max) {
                    nr = max;
                }
                if (is_function(fn)) {
                    fn.call($tt0, nr);
                }
                return nr;
            });


            //	currentVisible event
            $cfs.bind(cf_e('currentVisible', conf), function (e, fn) {
                e.stopPropagation();
                var $i = gi_getCurrentItems($cfs.children(), opts);
                if (is_function(fn)) {
                    fn.call($tt0, $i);
                }
                return $i;
            });


            //	slice event
            $cfs.bind(cf_e('slice', conf), function (e, f, l, fn) {
                e.stopPropagation();

                if (itms.total == 0) {
                    return false;
                }

                var v = [f, l, fn],
					t = ['number', 'number', 'function'],
					a = cf_sortParams(v, t);

                f = (is_number(a[0])) ? a[0] : 0;
                l = (is_number(a[1])) ? a[1] : itms.total;
                fn = a[2];

                f += itms.first;
                l += itms.first;

                if (items.total > 0) {
                    while (f > itms.total) {
                        f -= itms.total;
                    }
                    while (l > itms.total) {
                        l -= itms.total;
                    }
                    while (f < 0) {
                        f += itms.total;
                    }
                    while (l < 0) {
                        l += itms.total;
                    }
                }
                var $iA = $cfs.children(),
					$i;

                if (l > f) {
                    $i = $iA.slice(f, l);
                }
                else {
                    $i = $($iA.slice(f, itms.total).get().concat($iA.slice(0, l).get()));
                }

                if (is_function(fn)) {
                    fn.call($tt0, $i);
                }
                return $i;
            });


            //	isPaused, isStopped and isScrolling events
            $cfs.bind(cf_e('isPaused', conf) + ' ' + cf_e('isStopped', conf) + ' ' + cf_e('isScrolling', conf), function (e, fn) {
                e.stopPropagation();
                var eType = e.type.slice(conf.events.prefix.length),
					value = crsl[eType];
                if (is_function(fn)) {
                    fn.call($tt0, value);
                }
                return value;
            });


            //	configuration event
            $cfs.bind(cf_e('configuration', conf), function (e, a, b, c) {
                e.stopPropagation();
                var reInit = false;

                //	return entire configuration-object
                if (is_function(a)) {
                    a.call($tt0, opts);
                }
                    //	set multiple options via object
                else if (is_object(a)) {
                    opts_orig = $.extend(true, {}, opts_orig, a);
                    if (b !== false) reInit = true;
                    else opts = $.extend(true, {}, opts, a);

                }
                else if (!is_undefined(a)) {

                    //	callback function for specific option
                    if (is_function(b)) {
                        var val = eval('opts.' + a);
                        if (is_undefined(val)) {
                            val = '';
                        }
                        b.call($tt0, val);
                    }
                        //	set individual option
                    else if (!is_undefined(b)) {
                        if (typeof c !== 'boolean') c = true;
                        eval('opts_orig.' + a + ' = b');
                        if (c !== false) reInit = true;
                        else eval('opts.' + a + ' = b');
                    }
                        //	return value for specific option
                    else {
                        return eval('opts.' + a);
                    }
                }
                if (reInit) {
                    sz_resetMargin($cfs.children(), opts);
                    FN._init(opts_orig);
                    FN._bind_buttons();
                    var sz = sz_setSizes($cfs, opts);
                    $cfs.trigger(cf_e('updatePageStatus', conf), [true, sz]);
                }
                return opts;
            });


            //	linkAnchors event
            $cfs.bind(cf_e('linkAnchors', conf), function (e, $con, sel) {
                e.stopPropagation();

                if (is_undefined($con)) {
                    $con = $('body');
                }
                else if (is_string($con)) {
                    $con = $($con);
                }
                if (!is_jquery($con) || $con.length == 0) {
                    return debug(conf, 'Not a valid object.');
                }
                if (!is_string(sel)) {
                    sel = 'a.caroufredsel';
                }

                $con.find(sel).each(function () {
                    var h = this.hash || '';
                    if (h.length > 0 && $cfs.children().index($(h)) != -1) {
                        $(this).unbind('click').click(function (e) {
                            e.preventDefault();
                            $cfs.trigger(cf_e('slideTo', conf), h);
                        });
                    }
                });
                return true;
            });


            //	updatePageStatus event
            $cfs.bind(cf_e('updatePageStatus', conf), function (e, build, sizes) {
                e.stopPropagation();
                if (!opts.pagination.container) {
                    return;
                }

                var ipp = opts.pagination.items || opts.items.visible,
					pgs = Math.ceil(itms.total / ipp);

                if (build) {
                    if (opts.pagination.anchorBuilder) {
                        opts.pagination.container.children().remove();
                        opts.pagination.container.each(function () {
                            for (var a = 0; a < pgs; a++) {
                                var i = $cfs.children().eq(gn_getItemIndex(a * ipp, 0, true, itms, $cfs));
                                $(this).append(opts.pagination.anchorBuilder.call(i[0], a + 1));
                            }
                        });
                    }
                    opts.pagination.container.each(function () {
                        $(this).children().unbind(opts.pagination.event).each(function (a) {
                            $(this).bind(opts.pagination.event, function (e) {
                                e.preventDefault();
                                $cfs.trigger(cf_e('slideTo', conf), [a * ipp, -opts.pagination.deviation, true, opts.pagination]);
                            });
                        });
                    });
                }

                var selected = $cfs.triggerHandler(cf_e('currentPage', conf)) + opts.pagination.deviation;
                if (selected >= pgs) {
                    selected = 0;
                }
                if (selected < 0) {
                    selected = pgs - 1;
                }
                opts.pagination.container.each(function () {
                    $(this).children().removeClass(cf_c('selected', conf)).eq(selected).addClass(cf_c('selected', conf));
                });
                return true;
            });


            //	updateSizes event
            $cfs.bind(cf_e('updateSizes', conf), function (e) {
                var vI = opts.items.visible,
					a_itm = $cfs.children(),
					avail_primary = ms_getParentSize($wrp, opts, 'width');

                itms.total = a_itm.length;

                if (crsl.primarySizePercentage) {
                    opts.maxDimension = avail_primary;
                    opts[opts.d['width']] = ms_getPercentage(avail_primary, crsl.primarySizePercentage);
                }
                else {
                    opts.maxDimension = ms_getMaxDimension(opts, avail_primary);
                }

                if (opts.responsive) {
                    opts.items.width = opts.items.sizesConf.width;
                    opts.items.height = opts.items.sizesConf.height;
                    opts = in_getResponsiveValues(opts, a_itm, avail_primary);
                    vI = opts.items.visible;
                    sz_setResponsiveSizes(opts, a_itm);
                }
                else if (opts.items.visibleConf.variable) {
                    vI = gn_getVisibleItemsNext(a_itm, opts, 0);
                }
                else if (opts.items.filter != '*') {
                    vI = gn_getVisibleItemsNextFilter(a_itm, opts, 0);
                }

                if (!opts.circular && itms.first != 0 && vI > itms.first) {
                    if (opts.items.visibleConf.variable) {
                        var nI = gn_getVisibleItemsPrev(a_itm, opts, itms.first) - itms.first;
                    }
                    else if (opts.items.filter != '*') {
                        var nI = gn_getVisibleItemsPrevFilter(a_itm, opts, itms.first) - itms.first;
                    }
                    else {
                        var nI = opts.items.visible - itms.first;
                    }
                    debug(conf, 'Preventing non-circular: sliding ' + nI + ' items backward.');
                    $cfs.trigger(cf_e('prev', conf), nI);
                }

                opts.items.visible = cf_getItemsAdjust(vI, opts, opts.items.visibleConf.adjust, $tt0);
                opts.items.visibleConf.old = opts.items.visible;
                opts = in_getAlignPadding(opts, a_itm);

                var sz = sz_setSizes($cfs, opts);
                $cfs.trigger(cf_e('updatePageStatus', conf), [true, sz]);
                nv_showNavi(opts, itms.total, conf);
                nv_enableNavi(opts, itms.first, conf);

                return sz;
            });


            //	destroy event
            $cfs.bind(cf_e('destroy', conf), function (e, orgOrder) {
                e.stopPropagation();
                tmrs = sc_clearTimers(tmrs);

                $cfs.data('_cfs_isCarousel', false);
                $cfs.trigger(cf_e('finish', conf));
                if (orgOrder) {
                    $cfs.trigger(cf_e('jumpToStart', conf));
                }
                sz_restoreOrigCss($cfs.children());
                sz_restoreOrigCss($cfs);
                FN._unbind_events();
                FN._unbind_buttons();
                if (conf.wrapper == 'parent') {
                    sz_restoreOrigCss($wrp);
                }
                else {
                    $wrp.replaceWith($cfs);
                }

                return true;
            });


            //	debug event
            $cfs.bind(cf_e('debug', conf), function (e) {
                debug(conf, 'Carousel width: ' + opts.width);
                debug(conf, 'Carousel height: ' + opts.height);
                debug(conf, 'Item widths: ' + opts.items.width);
                debug(conf, 'Item heights: ' + opts.items.height);
                debug(conf, 'Number of items visible: ' + opts.items.visible);
                if (opts.auto.play) {
                    debug(conf, 'Number of items scrolled automatically: ' + opts.auto.items);
                }
                if (opts.prev.button) {
                    debug(conf, 'Number of items scrolled backward: ' + opts.prev.items);
                }
                if (opts.next.button) {
                    debug(conf, 'Number of items scrolled forward: ' + opts.next.items);
                }
                return conf.debug;
            });


            //	triggerEvent, making prefixed and namespaced events accessible from outside
            $cfs.bind('_cfs_triggerEvent', function (e, n, o) {
                e.stopPropagation();
                return $cfs.triggerHandler(cf_e(n, conf), o);
            });
        };	//	/bind_events


        FN._unbind_events = function () {
            $cfs.unbind(cf_e('', conf));
            $cfs.unbind(cf_e('', conf, false));
            $cfs.unbind('_cfs_triggerEvent');
        };	//	/unbind_events


        FN._bind_buttons = function () {
            FN._unbind_buttons();
            nv_showNavi(opts, itms.total, conf);
            nv_enableNavi(opts, itms.first, conf);

            if (opts.auto.pauseOnHover) {
                var pC = bt_pauseOnHoverConfig(opts.auto.pauseOnHover);
                $wrp.bind(cf_e('mouseenter', conf, false), function () { $cfs.trigger(cf_e('pause', conf), pC); })
					.bind(cf_e('mouseleave', conf, false), function () { $cfs.trigger(cf_e('resume', conf)); });
            }

            //	play button
            if (opts.auto.button) {
                opts.auto.button.bind(cf_e(opts.auto.event, conf, false), function (e) {
                    e.preventDefault();
                    var ev = false,
						pC = null;

                    if (crsl.isPaused) {
                        ev = 'play';
                    }
                    else if (opts.auto.pauseOnEvent) {
                        ev = 'pause';
                        pC = bt_pauseOnHoverConfig(opts.auto.pauseOnEvent);
                    }
                    if (ev) {
                        $cfs.trigger(cf_e(ev, conf), pC);
                    }
                });
            }

            //	prev button
            if (opts.prev.button) {
                opts.prev.button.bind(cf_e(opts.prev.event, conf, false), function (e) {
                    e.preventDefault();
                    $cfs.trigger(cf_e('prev', conf));
                });
                if (opts.prev.pauseOnHover) {
                    var pC = bt_pauseOnHoverConfig(opts.prev.pauseOnHover);
                    opts.prev.button.bind(cf_e('mouseenter', conf, false), function () { $cfs.trigger(cf_e('pause', conf), pC); })
									.bind(cf_e('mouseleave', conf, false), function () { $cfs.trigger(cf_e('resume', conf)); });
                }
            }

            //	next butotn
            if (opts.next.button) {
                opts.next.button.bind(cf_e(opts.next.event, conf, false), function (e) {
                    e.preventDefault();
                    $cfs.trigger(cf_e('next', conf));
                });
                if (opts.next.pauseOnHover) {
                    var pC = bt_pauseOnHoverConfig(opts.next.pauseOnHover);
                    opts.next.button.bind(cf_e('mouseenter', conf, false), function () { $cfs.trigger(cf_e('pause', conf), pC); })
									.bind(cf_e('mouseleave', conf, false), function () { $cfs.trigger(cf_e('resume', conf)); });
                }
            }

            //	pagination
            if (opts.pagination.container) {
                if (opts.pagination.pauseOnHover) {
                    var pC = bt_pauseOnHoverConfig(opts.pagination.pauseOnHover);
                    opts.pagination.container.bind(cf_e('mouseenter', conf, false), function () { $cfs.trigger(cf_e('pause', conf), pC); })
											 .bind(cf_e('mouseleave', conf, false), function () { $cfs.trigger(cf_e('resume', conf)); });
                }
            }

            //	prev/next keys
            if (opts.prev.key || opts.next.key) {
                $(document).bind(cf_e('keyup', conf, false, true, true), function (e) {
                    var k = e.keyCode;
                    if (k == opts.next.key) {
                        e.preventDefault();
                        $cfs.trigger(cf_e('next', conf));
                    }
                    if (k == opts.prev.key) {
                        e.preventDefault();
                        $cfs.trigger(cf_e('prev', conf));
                    }
                });
            }

            //	pagination keys
            if (opts.pagination.keys) {
                $(document).bind(cf_e('keyup', conf, false, true, true), function (e) {
                    var k = e.keyCode;
                    if (k >= 49 && k < 58) {
                        k = (k - 49) * opts.items.visible;
                        if (k <= itms.total) {
                            e.preventDefault();
                            $cfs.trigger(cf_e('slideTo', conf), [k, 0, true, opts.pagination]);
                        }
                    }
                });
            }

            //	swipe
            if ($.fn.swipe) {
                var isTouch = 'ontouchstart' in window;
                if ((isTouch && opts.swipe.onTouch) || (!isTouch && opts.swipe.onMouse)) {
                    var scP = $.extend(true, {}, opts.prev, opts.swipe),
						scN = $.extend(true, {}, opts.next, opts.swipe),
						swP = function () { $cfs.trigger(cf_e('prev', conf), [scP]) },
						swN = function () { $cfs.trigger(cf_e('next', conf), [scN]) };

                    switch (opts.direction) {
                        case 'up':
                        case 'down':
                            opts.swipe.options.swipeUp = swN;
                            opts.swipe.options.swipeDown = swP;
                            break;
                        default:
                            opts.swipe.options.swipeLeft = swN;
                            opts.swipe.options.swipeRight = swP;
                    }
                    if (crsl.swipe) {
                        $cfs.swipe('destroy');
                    }
                    $wrp.swipe(opts.swipe.options);
                    $wrp.css('cursor', 'move');
                    crsl.swipe = true;
                }
            }

            //	mousewheel
            if ($.fn.mousewheel) {

                if (opts.mousewheel) {
                    var mcP = $.extend(true, {}, opts.prev, opts.mousewheel),
						mcN = $.extend(true, {}, opts.next, opts.mousewheel);

                    if (crsl.mousewheel) {
                        $wrp.unbind(cf_e('mousewheel', conf, false));
                    }
                    $wrp.bind(cf_e('mousewheel', conf, false), function (e, delta) {
                        e.preventDefault();
                        if (delta > 0) {
                            $cfs.trigger(cf_e('prev', conf), [mcP]);
                        }
                        else {
                            $cfs.trigger(cf_e('next', conf), [mcN]);
                        }
                    });
                    crsl.mousewheel = true;
                }
            }

            if (opts.auto.play) {
                $cfs.trigger(cf_e('play', conf), opts.auto.delay);
            }

            if (crsl.upDateOnWindowResize) {
                var resizeFn = function (e) {
                    $cfs.trigger(cf_e('finish', conf));
                    if (opts.auto.pauseOnResize && !crsl.isPaused) {
                        $cfs.trigger(cf_e('play', conf));
                    }
                    sz_resetMargin($cfs.children(), opts);
                    $cfs.trigger(cf_e('updateSizes', conf));
                };

                var $w = $(window),
					onResize = null;

                if ($.debounce && conf.onWindowResize == 'debounce') {
                    onResize = $.debounce(200, resizeFn);
                }
                else if ($.throttle && conf.onWindowResize == 'throttle') {
                    onResize = $.throttle(300, resizeFn);
                }
                else {
                    var _windowWidth = 0,
						_windowHeight = 0;

                    onResize = function () {
                        var nw = $w.width(),
							nh = $w.height();

                        if (nw != _windowWidth || nh != _windowHeight) {
                            resizeFn();
                            _windowWidth = nw;
                            _windowHeight = nh;
                        }
                    };
                }
                $w.bind(cf_e('resize', conf, false, true, true), onResize);
            }
        };	//	/bind_buttons


        FN._unbind_buttons = function () {
            var ns1 = cf_e('', conf),
				ns2 = cf_e('', conf, false);
            ns3 = cf_e('', conf, false, true, true);

            $(document).unbind(ns3);
            $(window).unbind(ns3);
            $wrp.unbind(ns2);

            if (opts.auto.button) {
                opts.auto.button.unbind(ns2);
            }
            if (opts.prev.button) {
                opts.prev.button.unbind(ns2);
            }
            if (opts.next.button) {
                opts.next.button.unbind(ns2);
            }
            if (opts.pagination.container) {
                opts.pagination.container.unbind(ns2);
                if (opts.pagination.anchorBuilder) {
                    opts.pagination.container.children().remove();
                }
            }
            if (crsl.swipe) {
                $cfs.swipe('destroy');
                $wrp.css('cursor', 'default');
                crsl.swipe = false;
            }
            if (crsl.mousewheel) {
                crsl.mousewheel = false;
            }

            nv_showNavi(opts, 'hide', conf);
            nv_enableNavi(opts, 'removeClass', conf);

        };	//	/unbind_buttons



        //	START

        if (is_boolean(configs)) {
            configs = {
                'debug': configs
            };
        }

        //	set vars
        var crsl = {
            'direction': 'next',
            'isPaused': true,
            'isScrolling': false,
            'isStopped': false,
            'mousewheel': false,
            'swipe': false
        },
			itms = {
			    'total': $cfs.children().length,
			    'first': 0
			},
			tmrs = {
			    'auto': null,
			    'progress': null,
			    'startTime': getTime(),
			    'timePassed': 0
			},
			scrl = {
			    'isStopped': false,
			    'duration': 0,
			    'startTime': 0,
			    'easing': '',
			    'anims': []
			},
			clbk = {
			    'onBefore': [],
			    'onAfter': []
			},
			queu = [],
			conf = $.extend(true, {}, $.fn.carouFredSel.configs, configs),
			opts = {},
			opts_orig = $.extend(true, {}, options),
			$wrp = (conf.wrapper == 'parent')
				? $cfs.parent()
				: $cfs.wrap('<' + conf.wrapper.element + ' class="' + conf.wrapper.classname + '" />').parent();


        conf.selector = $cfs.selector;
        conf.serialNumber = $.fn.carouFredSel.serialNumber++;

        conf.transition = (conf.transition && $.fn.transition) ? 'transition' : 'animate';

        //	create carousel
        FN._init(opts_orig, true, starting_position);
        FN._build();
        FN._bind_events();
        FN._bind_buttons();

        //	find item to start
        if (is_array(opts.items.start)) {
            var start_arr = opts.items.start;
        }
        else {
            var start_arr = [];
            if (opts.items.start != 0) {
                start_arr.push(opts.items.start);
            }
        }
        if (opts.cookie) {
            start_arr.unshift(parseInt(cf_getCookie(opts.cookie), 10));
        }

        if (start_arr.length > 0) {
            for (var a = 0, l = start_arr.length; a < l; a++) {
                var s = start_arr[a];
                if (s == 0) {
                    continue;
                }
                if (s === true) {
                    s = window.location.hash;
                    if (s.length < 1) {
                        continue;
                    }
                }
                else if (s === 'random') {
                    s = Math.floor(Math.random() * itms.total);
                }
                if ($cfs.triggerHandler(cf_e('slideTo', conf), [s, 0, true, { fx: 'none' }])) {
                    break;
                }
            }
        }
        var siz = sz_setSizes($cfs, opts),
			itm = gi_getCurrentItems($cfs.children(), opts);

        if (opts.onCreate) {
            opts.onCreate.call($tt0, {
                'width': siz.width,
                'height': siz.height,
                'items': itm
            });
        }

        $cfs.trigger(cf_e('updatePageStatus', conf), [true, siz]);
        $cfs.trigger(cf_e('linkAnchors', conf));

        if (conf.debug) {
            $cfs.trigger(cf_e('debug', conf));
        }

        return $cfs;
    };



    //	GLOBAL PUBLIC

    $.fn.carouFredSel.serialNumber = 1;
    $.fn.carouFredSel.defaults = {
        'synchronise': false,
        'infinite': true,
        'circular': true,
        'responsive': false,
        'direction': 'left',
        'items': {
            'start': 0
        },
        'scroll': {
            'easing': 'swing',
            'duration': 500,
            'pauseOnHover': false,
            'event': 'click',
            'queue': false
        }
    };
    $.fn.carouFredSel.configs = {
        'debug': false,
        'transition': false,
        'onWindowResize': 'throttle',
        'events': {
            'prefix': '',
            'namespace': 'cfs'
        },
        'wrapper': {
            'element': 'div',
            'classname': 'caroufredsel_wrapper'
        },
        'classnames': {}
    };
    $.fn.carouFredSel.pageAnchorBuilder = function (nr) {
        return '<a href="#"><span>' + nr + '</span></a>';
    };
    $.fn.carouFredSel.progressbarUpdater = function (perc) {
        $(this).css('width', perc + '%');
    };

    $.fn.carouFredSel.cookie = {
        get: function (n) {
            n += '=';
            var ca = document.cookie.split(';');
            for (var a = 0, l = ca.length; a < l; a++) {
                var c = ca[a];
                while (c.charAt(0) == ' ') {
                    c = c.slice(1);
                }
                if (c.indexOf(n) == 0) {
                    return c.slice(n.length);
                }
            }
            return 0;
        },
        set: function (n, v, d) {
            var e = "";
            if (d) {
                var date = new Date();
                date.setTime(date.getTime() + (d * 24 * 60 * 60 * 1000));
                e = "; expires=" + date.toGMTString();
            }
            document.cookie = n + '=' + v + e + '; path=/';
        },
        remove: function (n) {
            $.fn.carouFredSel.cookie.set(n, "", -1);
        }
    };


    //	GLOBAL PRIVATE

    //	scrolling functions
    function sc_setScroll(d, e, c) {
        if (c.transition == 'transition') {
            if (e == 'swing') {
                e = 'ease';
            }
        }
        return {
            anims: [],
            duration: d,
            orgDuration: d,
            easing: e,
            startTime: getTime()
        };
    }
    function sc_startScroll(s, c) {
        for (var a = 0, l = s.anims.length; a < l; a++) {
            var b = s.anims[a];
            if (!b) {
                continue;
            }
            b[0][c.transition](b[1], s.duration, s.easing, b[2]);
        }
    }
    function sc_stopScroll(s, finish) {
        if (!is_boolean(finish)) {
            finish = true;
        }
        if (is_object(s.pre)) {
            sc_stopScroll(s.pre, finish);
        }
        for (var a = 0, l = s.anims.length; a < l; a++) {
            var b = s.anims[a];
            b[0].stop(true);
            if (finish) {
                b[0].css(b[1]);
                if (is_function(b[2])) {
                    b[2]();
                }
            }
        }
        if (is_object(s.post)) {
            sc_stopScroll(s.post, finish);
        }
    }
    function sc_afterScroll($c, $c2, o) {
        if ($c2) {
            $c2.remove();
        }

        switch (o.fx) {
            case 'fade':
            case 'crossfade':
            case 'cover-fade':
            case 'uncover-fade':
                $c.css('opacity', 1);
                $c.css('filter', '');
                break;
        }
    }
    function sc_fireCallbacks($t, o, b, a, c) {
        if (o[b]) {
            o[b].call($t, a);
        }
        if (c[b].length) {
            for (var i = 0, l = c[b].length; i < l; i++) {
                c[b][i].call($t, a);
            }
        }
        return [];
    }
    function sc_fireQueue($c, q, c) {

        if (q.length) {
            $c.trigger(cf_e(q[0][0], c), q[0][1]);
            q.shift();
        }
        return q;
    }
    function sc_hideHiddenItems(hiddenitems) {
        hiddenitems.each(function () {
            var hi = $(this);
            hi.data('_cfs_isHidden', hi.is(':hidden')).hide();
        });
    }
    function sc_showHiddenItems(hiddenitems) {
        if (hiddenitems) {
            hiddenitems.each(function () {
                var hi = $(this);
                if (!hi.data('_cfs_isHidden')) {
                    hi.show();
                }
            });
        }
    }
    function sc_clearTimers(t) {
        if (t.auto) {
            clearTimeout(t.auto);
        }
        if (t.progress) {
            clearInterval(t.progress);
        }
        return t;
    }
    function sc_mapCallbackArguments(i_old, i_skp, i_new, s_itm, s_dir, s_dur, w_siz) {
        return {
            'width': w_siz.width,
            'height': w_siz.height,
            'items': {
                'old': i_old,
                'skipped': i_skp,
                'visible': i_new
            },
            'scroll': {
                'items': s_itm,
                'direction': s_dir,
                'duration': s_dur
            }
        };
    }
    function sc_getDuration(sO, o, nI, siz) {
        var dur = sO.duration;
        if (sO.fx == 'none') {
            return 0;
        }
        if (dur == 'auto') {
            dur = o.scroll.duration / o.scroll.items * nI;
        }
        else if (dur < 10) {
            dur = siz / dur;
        }
        if (dur < 1) {
            return 0;
        }
        if (sO.fx == 'fade') {
            dur = dur / 2;
        }
        return Math.round(dur);
    }

    //	navigation functions
    function nv_showNavi(o, t, c) {
        var minimum = (is_number(o.items.minimum)) ? o.items.minimum : o.items.visible + 1;
        if (t == 'show' || t == 'hide') {
            var f = t;
        }
        else if (minimum > t) {
            debug(c, 'Not enough items (' + t + ' total, ' + minimum + ' needed): Hiding navigation.');
            var f = 'hide';
        }
        else {
            var f = 'show';
        }
        var s = (f == 'show') ? 'removeClass' : 'addClass',
			h = cf_c('hidden', c);

        if (o.auto.button) {
            o.auto.button[f]()[s](h);
        }
        if (o.prev.button) {
            o.prev.button[f]()[s](h);
        }
        if (o.next.button) {
            o.next.button[f]()[s](h);
        }
        if (o.pagination.container) {
            o.pagination.container[f]()[s](h);
        }
    }
    function nv_enableNavi(o, f, c) {
        if (o.circular || o.infinite) return;
        var fx = (f == 'removeClass' || f == 'addClass') ? f : false,
			di = cf_c('disabled', c);

        if (o.auto.button && fx) {
            o.auto.button[fx](di);
        }
        if (o.prev.button) {
            var fn = fx || (f == 0) ? 'addClass' : 'removeClass';
            o.prev.button[fn](di);
        }
        if (o.next.button) {
            var fn = fx || (f == o.items.visible) ? 'addClass' : 'removeClass';
            o.next.button[fn](di);
        }
    }

    //	get object functions
    function go_getObject($tt, obj) {
        if (is_function(obj)) {
            obj = obj.call($tt);
        }
        else if (is_undefined(obj)) {
            obj = {};
        }
        return obj;
    }
    function go_getItemsObject($tt, obj) {
        obj = go_getObject($tt, obj);
        if (is_number(obj)) {
            obj = {
                'visible': obj
            };
        }
        else if (obj == 'variable') {
            obj = {
                'visible': obj,
                'width': obj,
                'height': obj
            };
        }
        else if (!is_object(obj)) {
            obj = {};
        }
        return obj;
    }
    function go_getScrollObject($tt, obj) {
        obj = go_getObject($tt, obj);
        if (is_number(obj)) {
            if (obj <= 50) {
                obj = {
                    'items': obj
                };
            }
            else {
                obj = {
                    'duration': obj
                };
            }
        }
        else if (is_string(obj)) {
            obj = {
                'easing': obj
            };
        }
        else if (!is_object(obj)) {
            obj = {};
        }
        return obj;
    }
    function go_getNaviObject($tt, obj) {
        obj = go_getObject($tt, obj);
        if (is_string(obj)) {
            var temp = cf_getKeyCode(obj);
            if (temp == -1) {
                obj = $(obj);
            }
            else {
                obj = temp;
            }
        }
        return obj;
    }

    function go_getAutoObject($tt, obj) {
        obj = go_getNaviObject($tt, obj);
        if (is_jquery(obj)) {
            obj = {
                'button': obj
            };
        }
        else if (is_boolean(obj)) {
            obj = {
                'play': obj
            };
        }
        else if (is_number(obj)) {
            obj = {
                'timeoutDuration': obj
            };
        }
        if (obj.progress) {
            if (is_string(obj.progress) || is_jquery(obj.progress)) {
                obj.progress = {
                    'bar': obj.progress
                };
            }
        }
        return obj;
    }
    function go_complementAutoObject($tt, obj) {
        if (is_function(obj.button)) {
            obj.button = obj.button.call($tt);
        }
        if (is_string(obj.button)) {
            obj.button = $(obj.button);
        }
        if (!is_boolean(obj.play)) {
            obj.play = true;
        }
        if (!is_number(obj.delay)) {
            obj.delay = 0;
        }
        if (is_undefined(obj.pauseOnEvent)) {
            obj.pauseOnEvent = true;
        }
        if (!is_boolean(obj.pauseOnResize)) {
            obj.pauseOnResize = true;
        }
        if (!is_number(obj.timeoutDuration)) {
            obj.timeoutDuration = (obj.duration < 10)
				? 2500
				: obj.duration * 5;
        }
        if (obj.progress) {
            if (is_function(obj.progress.bar)) {
                obj.progress.bar = obj.progress.bar.call($tt);
            }
            if (is_string(obj.progress.bar)) {
                obj.progress.bar = $(obj.progress.bar);
            }
            if (obj.progress.bar) {
                if (!is_function(obj.progress.updater)) {
                    obj.progress.updater = $.fn.carouFredSel.progressbarUpdater;
                }
                if (!is_number(obj.progress.interval)) {
                    obj.progress.interval = 50;
                }
            }
            else {
                obj.progress = false;
            }
        }
        return obj;
    }

    function go_getPrevNextObject($tt, obj) {
        obj = go_getNaviObject($tt, obj);
        if (is_jquery(obj)) {
            obj = {
                'button': obj
            };
        }
        else if (is_number(obj)) {
            obj = {
                'key': obj
            };
        }
        return obj;
    }
    function go_complementPrevNextObject($tt, obj) {
        if (is_function(obj.button)) {
            obj.button = obj.button.call($tt);
        }
        if (is_string(obj.button)) {
            obj.button = $(obj.button);
        }
        if (is_string(obj.key)) {
            obj.key = cf_getKeyCode(obj.key);
        }
        return obj;
    }

    function go_getPaginationObject($tt, obj) {
        obj = go_getNaviObject($tt, obj);
        if (is_jquery(obj)) {
            obj = {
                'container': obj
            };
        }
        else if (is_boolean(obj)) {
            obj = {
                'keys': obj
            };
        }
        return obj;
    }
    function go_complementPaginationObject($tt, obj) {
        if (is_function(obj.container)) {
            obj.container = obj.container.call($tt);
        }
        if (is_string(obj.container)) {
            obj.container = $(obj.container);
        }
        if (!is_number(obj.items)) {
            obj.items = false;
        }
        if (!is_boolean(obj.keys)) {
            obj.keys = false;
        }
        if (!is_function(obj.anchorBuilder) && !is_false(obj.anchorBuilder)) {
            obj.anchorBuilder = $.fn.carouFredSel.pageAnchorBuilder;
        }
        if (!is_number(obj.deviation)) {
            obj.deviation = 0;
        }
        return obj;
    }

    function go_getSwipeObject($tt, obj) {
        if (is_function(obj)) {
            obj = obj.call($tt);
        }
        if (is_undefined(obj)) {
            obj = {
                'onTouch': false
            };
        }
        if (is_true(obj)) {
            obj = {
                'onTouch': obj
            };
        }
        else if (is_number(obj)) {
            obj = {
                'items': obj
            };
        }
        return obj;
    }
    function go_complementSwipeObject($tt, obj) {
        if (!is_boolean(obj.onTouch)) {
            obj.onTouch = true;
        }
        if (!is_boolean(obj.onMouse)) {
            obj.onMouse = false;
        }
        if (!is_object(obj.options)) {
            obj.options = {};
        }
        if (!is_boolean(obj.options.triggerOnTouchEnd)) {
            obj.options.triggerOnTouchEnd = false;
        }
        return obj;
    }
    function go_getMousewheelObject($tt, obj) {
        if (is_function(obj)) {
            obj = obj.call($tt);
        }
        if (is_true(obj)) {
            obj = {};
        }
        else if (is_number(obj)) {
            obj = {
                'items': obj
            };
        }
        else if (is_undefined(obj)) {
            obj = false;
        }
        return obj;
    }
    function go_complementMousewheelObject($tt, obj) {
        return obj;
    }

    //	get number functions
    function gn_getItemIndex(num, dev, org, items, $cfs) {
        if (is_string(num)) {
            num = $(num, $cfs);
        }

        if (is_object(num)) {
            num = $(num, $cfs);
        }
        if (is_jquery(num)) {
            num = $cfs.children().index(num);
            if (!is_boolean(org)) {
                org = false;
            }
        }
        else {
            if (!is_boolean(org)) {
                org = true;
            }
        }
        if (!is_number(num)) {
            num = 0;
        }
        if (!is_number(dev)) {
            dev = 0;
        }

        if (org) {
            num += items.first;
        }
        num += dev;
        if (items.total > 0) {
            while (num >= items.total) {
                num -= items.total;
            }
            while (num < 0) {
                num += items.total;
            }
        }
        return num;
    }

    //	items prev
    function gn_getVisibleItemsPrev(i, o, s) {
        var t = 0,
			x = 0;

        for (var a = s; a >= 0; a--) {
            var j = i.eq(a);
            t += (j.is(':visible')) ? j[o.d['outerWidth']](true) : 0;
            if (t > o.maxDimension) {
                return x;
            }
            if (a == 0) {
                a = i.length;
            }
            x++;
        }
    }
    function gn_getVisibleItemsPrevFilter(i, o, s) {
        return gn_getItemsPrevFilter(i, o.items.filter, o.items.visibleConf.org, s);
    }
    function gn_getScrollItemsPrevFilter(i, o, s, m) {
        return gn_getItemsPrevFilter(i, o.items.filter, m, s);
    }
    function gn_getItemsPrevFilter(i, f, m, s) {
        var t = 0,
			x = 0;

        for (var a = s, l = i.length; a >= 0; a--) {
            x++;
            if (x == l) {
                return x;
            }

            var j = i.eq(a);
            if (j.is(f)) {
                t++;
                if (t == m) {
                    return x;
                }
            }
            if (a == 0) {
                a = l;
            }
        }
    }

    function gn_getVisibleOrg($c, o) {
        return o.items.visibleConf.org || $c.children().slice(0, o.items.visible).filter(o.items.filter).length;
    }

    //	items next
    function gn_getVisibleItemsNext(i, o, s) {
        var t = 0,
			x = 0;

        for (var a = s, l = i.length - 1; a <= l; a++) {
            var j = i.eq(a);

            t += (j.is(':visible')) ? j[o.d['outerWidth']](true) : 0;
            if (t > o.maxDimension) {
                return x;
            }

            x++;
            if (x == l + 1) {
                return x;
            }
            if (a == l) {
                a = -1;
            }
        }
    }
    function gn_getVisibleItemsNextTestCircular(i, o, s, l) {
        var v = gn_getVisibleItemsNext(i, o, s);
        if (!o.circular) {
            if (s + v > l) {
                v = l - s;
            }
        }
        return v;
    }
    function gn_getVisibleItemsNextFilter(i, o, s) {
        return gn_getItemsNextFilter(i, o.items.filter, o.items.visibleConf.org, s, o.circular);
    }
    function gn_getScrollItemsNextFilter(i, o, s, m) {
        return gn_getItemsNextFilter(i, o.items.filter, m + 1, s, o.circular) - 1;
    }
    function gn_getItemsNextFilter(i, f, m, s, c) {
        var t = 0,
			x = 0;

        for (var a = s, l = i.length - 1; a <= l; a++) {
            x++;
            if (x >= l) {
                return x;
            }

            var j = i.eq(a);
            if (j.is(f)) {
                t++;
                if (t == m) {
                    return x;
                }
            }
            if (a == l) {
                a = -1;
            }
        }
    }

    //	get items functions
    function gi_getCurrentItems(i, o) {
        return i.slice(0, o.items.visible);
    }
    function gi_getOldItemsPrev(i, o, n) {
        return i.slice(n, o.items.visibleConf.old + n);
    }
    function gi_getNewItemsPrev(i, o) {
        return i.slice(0, o.items.visible);
    }
    function gi_getOldItemsNext(i, o) {
        return i.slice(0, o.items.visibleConf.old);
    }
    function gi_getNewItemsNext(i, o, n) {
        return i.slice(n, o.items.visible + n);
    }

    //	sizes functions
    function sz_storeMargin(i, o, d) {
        if (o.usePadding) {
            if (!is_string(d)) {
                d = '_cfs_origCssMargin';
            }
            i.each(function () {
                var j = $(this),
					m = parseInt(j.css(o.d['marginRight']), 10);
                if (!is_number(m)) {
                    m = 0;
                }
                j.data(d, m);
            });
        }
    }
    function sz_resetMargin(i, o, m) {
        if (o.usePadding) {
            var x = (is_boolean(m)) ? m : false;
            if (!is_number(m)) {
                m = 0;
            }
            sz_storeMargin(i, o, '_cfs_tempCssMargin');
            i.each(function () {
                var j = $(this);
                j.css(o.d['marginRight'], ((x) ? j.data('_cfs_tempCssMargin') : m + j.data('_cfs_origCssMargin')));
            });
        }
    }
    function sz_storeOrigCss(i) {
        i.each(function () {
            var j = $(this);
            j.data('_cfs_origCss', j.attr('style') || '');
        });
    }
    function sz_restoreOrigCss(i) {
        i.each(function () {
            var j = $(this);
            j.attr('style', j.data('_cfs_origCss') || '');
        });
    }
    function sz_setResponsiveSizes(o, all) {
        var visb = o.items.visible,
			newS = o.items[o.d['width']],
			seco = o[o.d['height']],
			secp = is_percentage(seco);

        all.each(function () {
            var $t = $(this),
				nw = newS - ms_getPaddingBorderMargin($t, o, 'Width');

            $t[o.d['width']](nw);
            if (secp) {
                $t[o.d['height']](ms_getPercentage(nw, seco));
            }
        });
    }
    function sz_setSizes($c, o) {
        var $w = $c.parent(),
			$i = $c.children(),
			$v = gi_getCurrentItems($i, o),
			sz = cf_mapWrapperSizes(ms_getSizes($v, o, true), o, false);

        $w.css(sz);

        if (o.usePadding) {
            var p = o.padding,
				r = p[o.d[1]];

            if (o.align && r < 0) {
                r = 0;
            }
            var $l = $v.last();
            $l.css(o.d['marginRight'], $l.data('_cfs_origCssMargin') + r);
            $c.css(o.d['top'], p[o.d[0]]);
            $c.css(o.d['left'], p[o.d[3]]);
        }

        $c.css(o.d['width'], sz[o.d['width']] + (ms_getTotalSize($i, o, 'width') * 2));
        $c.css(o.d['height'], ms_getLargestSize($i, o, 'height'));
        return sz;
    }

    //	measuring functions
    function ms_getSizes(i, o, wrapper) {
        return [ms_getTotalSize(i, o, 'width', wrapper), ms_getLargestSize(i, o, 'height', wrapper)];
    }
    function ms_getLargestSize(i, o, dim, wrapper) {
        if (!is_boolean(wrapper)) {
            wrapper = false;
        }
        if (is_number(o[o.d[dim]]) && wrapper) {
            return o[o.d[dim]];
        }
        if (is_number(o.items[o.d[dim]])) {
            return o.items[o.d[dim]];
        }
        dim = (dim.toLowerCase().indexOf('width') > -1) ? 'outerWidth' : 'outerHeight';
        return ms_getTrueLargestSize(i, o, dim);
    }
    function ms_getTrueLargestSize(i, o, dim) {
        var s = 0;

        for (var a = 0, l = i.length; a < l; a++) {
            var j = i.eq(a);

            var m = (j.is(':visible')) ? j[o.d[dim]](true) : 0;
            if (s < m) {
                s = m;
            }
        }
        return s;
    }

    function ms_getTotalSize(i, o, dim, wrapper) {
        if (!is_boolean(wrapper)) {
            wrapper = false;
        }
        if (is_number(o[o.d[dim]]) && wrapper) {
            return o[o.d[dim]];
        }
        if (is_number(o.items[o.d[dim]])) {
            return o.items[o.d[dim]] * i.length;
        }

        var d = (dim.toLowerCase().indexOf('width') > -1) ? 'outerWidth' : 'outerHeight',
			s = 0;

        for (var a = 0, l = i.length; a < l; a++) {
            var j = i.eq(a);
            s += (j.is(':visible')) ? j[o.d[d]](true) : 0;
        }
        return s;
    }
    function ms_getParentSize($w, o, d) {
        var isVisible = $w.is(':visible');
        if (isVisible) {
            $w.hide();
        }
        var s = $w.parent()[o.d[d]]();
        if (isVisible) {
            $w.show();
        }
        return s;
    }
    function ms_getMaxDimension(o, a) {
        return (is_number(o[o.d['width']])) ? o[o.d['width']] : a;
    }
    function ms_hasVariableSizes(i, o, dim) {
        var s = false,
			v = false;

        for (var a = 0, l = i.length; a < l; a++) {
            var j = i.eq(a);

            var c = (j.is(':visible')) ? j[o.d[dim]](true) : 0;
            if (s === false) {
                s = c;
            }
            else if (s != c) {
                v = true;
            }
            if (s == 0) {
                v = true;
            }
        }
        return v;
    }
    function ms_getPaddingBorderMargin(i, o, d) {
        return i[o.d['outer' + d]](true) - i[o.d[d.toLowerCase()]]();
    }
    function ms_getPercentage(s, o) {
        if (is_percentage(o)) {
            o = parseInt(o.slice(0, -1), 10);
            if (!is_number(o)) {
                return s;
            }
            s *= o / 100;
        }
        return s;
    }

    //	config functions
    function cf_e(n, c, pf, ns, rd) {
        if (!is_boolean(pf)) {
            pf = true;
        }
        if (!is_boolean(ns)) {
            ns = true;
        }
        if (!is_boolean(rd)) {
            rd = false;
        }

        if (pf) {
            n = c.events.prefix + n;
        }
        if (ns) {
            n = n + '.' + c.events.namespace;
        }
        if (ns && rd) {
            n += c.serialNumber;
        }

        return n;
    }
    function cf_c(n, c) {
        return (is_string(c.classnames[n])) ? c.classnames[n] : n;
    }
    function cf_mapWrapperSizes(ws, o, p) {
        if (!is_boolean(p)) {
            p = true;
        }
        var pad = (o.usePadding && p) ? o.padding : [0, 0, 0, 0];
        var wra = {};

        wra[o.d['width']] = ws[0] + pad[1] + pad[3];
        wra[o.d['height']] = ws[1] + pad[0] + pad[2];

        return wra;
    }
    function cf_sortParams(vals, typs) {
        var arr = [];
        for (var a = 0, l1 = vals.length; a < l1; a++) {
            for (var b = 0, l2 = typs.length; b < l2; b++) {
                if (typs[b].indexOf(typeof vals[a]) > -1 && is_undefined(arr[b])) {
                    arr[b] = vals[a];
                    break;
                }
            }
        }
        return arr;
    }
    function cf_getPadding(p) {
        if (is_undefined(p)) {
            return [0, 0, 0, 0];
        }
        if (is_number(p)) {
            return [p, p, p, p];
        }
        if (is_string(p)) {
            p = p.split('px').join('').split('em').join('').split(' ');
        }

        if (!is_array(p)) {
            return [0, 0, 0, 0];
        }
        for (var i = 0; i < 4; i++) {
            p[i] = parseInt(p[i], 10);
        }
        switch (p.length) {
            case 0:
                return [0, 0, 0, 0];
            case 1:
                return [p[0], p[0], p[0], p[0]];
            case 2:
                return [p[0], p[1], p[0], p[1]];
            case 3:
                return [p[0], p[1], p[2], p[1]];
            default:
                return [p[0], p[1], p[2], p[3]];
        }
    }
    function cf_getAlignPadding(itm, o) {
        var x = (is_number(o[o.d['width']])) ? Math.ceil(o[o.d['width']] - ms_getTotalSize(itm, o, 'width')) : 0;
        switch (o.align) {
            case 'left':
                return [0, x];
            case 'right':
                return [x, 0];
            case 'center':
            default:
                return [Math.ceil(x / 2), Math.floor(x / 2)];
        }
    }
    function cf_getDimensions(o) {
        var dm = [
				['width', 'innerWidth', 'outerWidth', 'height', 'innerHeight', 'outerHeight', 'left', 'top', 'marginRight', 0, 1, 2, 3],
				['height', 'innerHeight', 'outerHeight', 'width', 'innerWidth', 'outerWidth', 'top', 'left', 'marginBottom', 3, 2, 1, 0]
        ];

        var dl = dm[0].length,
			dx = (o.direction == 'right' || o.direction == 'left') ? 0 : 1;

        var dimensions = {};
        for (var d = 0; d < dl; d++) {
            dimensions[dm[0][d]] = dm[dx][d];
        }
        return dimensions;
    }
    function cf_getAdjust(x, o, a, $t) {
        var v = x;
        if (is_function(a)) {
            v = a.call($t, v);

        }
        else if (is_string(a)) {
            var p = a.split('+'),
				m = a.split('-');

            if (m.length > p.length) {
                var neg = true,
					sta = m[0],
					adj = m[1];
            }
            else {
                var neg = false,
					sta = p[0],
					adj = p[1];
            }

            switch (sta) {
                case 'even':
                    v = (x % 2 == 1) ? x - 1 : x;
                    break;
                case 'odd':
                    v = (x % 2 == 0) ? x - 1 : x;
                    break;
                default:
                    v = x;
                    break;
            }
            adj = parseInt(adj, 10);
            if (is_number(adj)) {
                if (neg) {
                    adj = -adj;
                }
                v += adj;
            }
        }
        if (!is_number(v) || v < 1) {
            v = 1;
        }
        return v;
    }
    function cf_getItemsAdjust(x, o, a, $t) {
        return cf_getItemAdjustMinMax(cf_getAdjust(x, o, a, $t), o.items.visibleConf);
    }
    function cf_getItemAdjustMinMax(v, i) {
        if (is_number(i.min) && v < i.min) {
            v = i.min;
        }
        if (is_number(i.max) && v > i.max) {
            v = i.max;
        }
        if (v < 1) {
            v = 1;
        }
        return v;
    }
    function cf_getSynchArr(s) {
        if (!is_array(s)) {
            s = [[s]];
        }
        if (!is_array(s[0])) {
            s = [s];
        }
        for (var j = 0, l = s.length; j < l; j++) {
            if (is_string(s[j][0])) {
                s[j][0] = $(s[j][0]);
            }
            if (!is_boolean(s[j][1])) {
                s[j][1] = true;
            }
            if (!is_boolean(s[j][2])) {
                s[j][2] = true;
            }
            if (!is_number(s[j][3])) {
                s[j][3] = 0;
            }
        }
        return s;
    }
    function cf_getKeyCode(k) {
        if (k == 'right') {
            return 39;
        }
        if (k == 'left') {
            return 37;
        }
        if (k == 'up') {
            return 38;
        }
        if (k == 'down') {
            return 40;
        }
        return -1;
    }
    function cf_setCookie(n, $c, c) {
        if (n) {
            var v = $c.triggerHandler(cf_e('currentPosition', c));
            $.fn.carouFredSel.cookie.set(n, v);
        }
    }
    function cf_getCookie(n) {
        var c = $.fn.carouFredSel.cookie.get(n);
        return (c == '') ? 0 : c;
    }

    //	init function
    function in_mapCss($elem, props) {
        var css = {};
        for (var p = 0, l = props.length; p < l; p++) {
            css[props[p]] = $elem.css(props[p]);
        }
        return css;
    }
    function in_complementItems(obj, opt, itm, sta) {
        if (!is_object(obj.visibleConf)) {
            obj.visibleConf = {};
        }
        if (!is_object(obj.sizesConf)) {
            obj.sizesConf = {};
        }

        if (obj.start == 0 && is_number(sta)) {
            obj.start = sta;
        }

        //	visible items
        if (is_object(obj.visible)) {
            obj.visibleConf.min = obj.visible.min;
            obj.visibleConf.max = obj.visible.max;
            obj.visible = false;
        }
        else if (is_string(obj.visible)) {
            //	variable visible items
            if (obj.visible == 'variable') {
                obj.visibleConf.variable = true;
            }
                //	adjust string visible items
            else {
                obj.visibleConf.adjust = obj.visible;
            }
            obj.visible = false;
        }
        else if (is_function(obj.visible)) {
            obj.visibleConf.adjust = obj.visible;
            obj.visible = false;
        }

        //	set items filter
        if (!is_string(obj.filter)) {
            obj.filter = (itm.filter(':hidden').length > 0) ? ':visible' : '*';
        }

        //	primary item-size not set
        if (!obj[opt.d['width']]) {
            //	responsive carousel -> set to largest
            if (opt.responsive) {
                debug(true, 'Set a ' + opt.d['width'] + ' for the items!');
                obj[opt.d['width']] = ms_getTrueLargestSize(itm, opt, 'outerWidth');
            }
                //	 non-responsive -> measure it or set to "variable"
            else {
                obj[opt.d['width']] = (ms_hasVariableSizes(itm, opt, 'outerWidth'))
					? 'variable'
					: itm[opt.d['outerWidth']](true);
            }
        }

        //	secondary item-size not set -> measure it or set to "variable"
        if (!obj[opt.d['height']]) {
            obj[opt.d['height']] = (ms_hasVariableSizes(itm, opt, 'outerHeight'))
				? 'variable'
				: itm[opt.d['outerHeight']](true);
        }

        obj.sizesConf.width = obj.width;
        obj.sizesConf.height = obj.height;
        return obj;
    }
    function in_complementVisibleItems(opt, avl) {
        //	primary item-size variable -> set visible items variable
        if (opt.items[opt.d['width']] == 'variable') {
            opt.items.visibleConf.variable = true;
        }
        if (!opt.items.visibleConf.variable) {
            //	primary size is number -> calculate visible-items
            if (is_number(opt[opt.d['width']])) {
                opt.items.visible = Math.floor(opt[opt.d['width']] / opt.items[opt.d['width']]);
            }
                //	measure and calculate primary size and visible-items
            else {
                opt.items.visible = Math.floor(avl / opt.items[opt.d['width']]);
                opt[opt.d['width']] = opt.items.visible * opt.items[opt.d['width']];
                if (!opt.items.visibleConf.adjust) {
                    opt.align = false;
                }
            }
            if (opt.items.visible == 'Infinity' || opt.items.visible < 1) {
                debug(true, 'Not a valid number of visible items: Set to "variable".');
                opt.items.visibleConf.variable = true;
            }
        }
        return opt;
    }
    function in_complementPrimarySize(obj, opt, all) {
        //	primary size set to auto -> measure largest item-size and set it
        if (obj == 'auto') {
            obj = ms_getTrueLargestSize(all, opt, 'outerWidth');
        }
        return obj;
    }
    function in_complementSecondarySize(obj, opt, all) {
        //	secondary size set to auto -> measure largest item-size and set it
        if (obj == 'auto') {
            obj = ms_getTrueLargestSize(all, opt, 'outerHeight');
        }
        //	secondary size not set -> set to secondary item-size
        if (!obj) {
            obj = opt.items[opt.d['height']];
        }
        return obj;
    }
    function in_getAlignPadding(o, all) {
        var p = cf_getAlignPadding(gi_getCurrentItems(all, o), o);
        o.padding[o.d[1]] = p[1];
        o.padding[o.d[3]] = p[0];
        return o;
    }
    function in_getResponsiveValues(o, all, avl) {

        var visb = cf_getItemAdjustMinMax(Math.ceil(o[o.d['width']] / o.items[o.d['width']]), o.items.visibleConf);
        if (visb > all.length) {
            visb = all.length;
        }

        var newS = Math.floor(o[o.d['width']] / visb);

        o.items.visible = visb;
        o.items[o.d['width']] = newS;
        o[o.d['width']] = visb * newS;
        return o;
    }


    //	buttons functions
    function bt_pauseOnHoverConfig(p) {
        if (is_string(p)) {
            var i = (p.indexOf('immediate') > -1) ? true : false,
				r = (p.indexOf('resume') > -1) ? true : false;
        }
        else {
            var i = r = false;
        }
        return [i, r];
    }
    function bt_mousesheelNumber(mw) {
        return (is_number(mw)) ? mw : null
    }

    //	helper functions
    function is_null(a) {
        return (a === null);
    }
    function is_undefined(a) {
        return (is_null(a) || typeof a == 'undefined' || a === '' || a === 'undefined');
    }
    function is_array(a) {
        return (a instanceof Array);
    }
    function is_jquery(a) {
        return (a instanceof jQuery);
    }
    function is_object(a) {
        return ((a instanceof Object || typeof a == 'object') && !is_null(a) && !is_jquery(a) && !is_array(a) && !is_function(a));
    }
    function is_number(a) {
        return ((a instanceof Number || typeof a == 'number') && !isNaN(a));
    }
    function is_string(a) {
        return ((a instanceof String || typeof a == 'string') && !is_undefined(a) && !is_true(a) && !is_false(a));
    }
    function is_function(a) {
        return (a instanceof Function || typeof a == 'function');
    }
    function is_boolean(a) {
        return (a instanceof Boolean || typeof a == 'boolean' || is_true(a) || is_false(a));
    }
    function is_true(a) {
        return (a === true || a === 'true');
    }
    function is_false(a) {
        return (a === false || a === 'false');
    }
    function is_percentage(x) {
        return (is_string(x) && x.slice(-1) == '%');
    }


    function getTime() {
        return new Date().getTime();
    }

    function deprecated(o, n) {
        debug(true, o + ' is DEPRECATED, support for it will be removed. Use ' + n + ' instead.');
    }
    function debug(d, m) {
        if (!is_undefined(window.console) && !is_undefined(window.console.log)) {
            if (is_object(d)) {
                var s = ' (' + d.selector + ')';
                d = d.debug;
            }
            else {
                var s = '';
            }
            if (!d) {
                return false;
            }

            if (is_string(m)) {
                m = 'carouFredSel' + s + ': ' + m;
            }
            else {
                m = ['carouFredSel' + s + ':', m];
            }
            window.console.log(m);
        }
        return false;
    }



    //	EASING FUNCTIONS
    $.extend($.easing, {
        'quadratic': function (t) {
            var t2 = t * t;
            return t * (-t2 * t + 4 * t2 - 6 * t + 4);
        },
        'cubic': function (t) {
            return t * (4 * t * t - 9 * t + 6);
        },
        'elastic': function (t) {
            var t2 = t * t;
            return t * (33 * t2 * t2 - 106 * t2 * t + 126 * t2 - 67 * t + 15);
        }
    });


})(jQuery);/**
* Expand/collapse headings
//*/
//jQuery.fn.nextUntil = function (expr, include) {
//    var match = [];
//    include = include ? true : false;
//    // We need to figure out which elements to push onto the array
//    this.each(function () {
//        // Traverse through the sibling nodes
//        for (var i = this.nextSibling; i; i = i.nextSibling) {
//            // Make sure that we're only dealing with elements
//            if (i.nodeType != 1) { continue; }
//            // Add it on to the stack if include is set
//            if (include) {
//                match.push(i);
//            }
//            // If we find a match then we need to stop
//            if (jQuery.filter(expr, [i]).length) { break; }
//            // Add it on to the stack if include is not set
//            if (!include) { match.push(i); }
//        }
//    });
//    return this.pushStack(match, arguments);
//};
var headingCount = 0;
var headings = new Array();
function createTwisties(elem, h, l, accordion) {
    $(elem).find(h).each(function () {
        $(this).css("cursor", "pointer");
        $(this).addClass("collapsed");
        var str = $.trim($(this).html());
        str = str.replace(/\s+/g, '-').toLowerCase();
        str = str.replace(/[[\]{}()*+?.,\\^$|#]/g, "");

        //$(this).attr("id",str);
        $(this).nextUntil(h).wrapAll("<div class='content-block' id='sub-heading-" + headingCount + "'></div>");
        if ($(this).hasClass("show")) {
            $(this).next().slideDown();
            $(this).toggleClass("collapsed");
            $(this).toggleClass("expanded");
        }
        else {
            $(this).next().hide();
        }
        $(this).click(function () {
            if ($(this).hasClass("collapsed")) {
                if (accordion) {
                    $(this).siblings(".expanded").each(function () {
                        $(this).toggleClass("collapsed");
                        $(this).toggleClass("expanded");
                        $(this).next().slideUp("fast");
                    });
                }
                $(this).next().slideDown("fast");
            }
            else {
                $(this).next().slideUp("fast");
            }
            if ($(this).attr("class") !== "") {
                $(this).toggleClass("collapsed");
                $(this).toggleClass("expanded");
            }
            return false;
        });
        $(this).contents().wrap("<a href='#sub-heading-" + headingCount + "' id='" + str + "'></a>");
        headingCount++;
    });
    var h_length = $(elem).find(h).length;
    if (h_length > l && l != 0) {
        $(elem).find(h + ":first").before("<div class='immi-expand-collapse-all'><button value='expand' class='expand_all'>Expand all</button><button value='collapse' class='collapse_all'>Collapse all</button></div>");
        $(elem).find("button.expand_all").click(function () {
            $(elem).find(h).each(function () {
                $(this).nextUntil(h).show();
                $(this).attr("class", "expanded");
            });
            return false;
        });
        $(elem).find("button.collapse_all").click(function () {
            $(elem).find(h).each(function () {
                $(this).nextUntil(h).hide();
                $(this).attr("class", "collapsed");
            });
            return false;
        });
    }
}/*
 * jQuery Cookie Plugin v1.3.1
 * https://github.com/carhartl/jquery-cookie
 *
 * Copyright 2013 Klaus Hartl
 * Released under the MIT license
 */
(function (factory) {
    if (typeof define === 'function' && define.amd) {
        // AMD. Register as anonymous module.
        define(['jquery'], factory);
    } else {
        // Browser globals.
        factory(jQuery);
    }
}(function ($) {

    var pluses = /\+/g;

    function raw(s) {
        return s;
    }

    function decoded(s) {
        return decodeURIComponent(s.replace(pluses, ' '));
    }

    function converted(s) {
        if (s.indexOf('"') === 0) {
            // This is a quoted cookie as according to RFC2068, unescape
            s = s.slice(1, -1).replace(/\\"/g, '"').replace(/\\\\/g, '\\');
        }
        try {
            return config.json ? JSON.parse(s) : s;
        } catch (er) { }
    }

    var config = $.cookie = function (key, value, options) {

        // write
        if (value !== undefined) {
            options = $.extend({}, config.defaults, options);

            if (typeof options.expires === 'number') {
                var days = options.expires, t = options.expires = new Date();
                t.setDate(t.getDate() + days);
            }

            value = config.json ? JSON.stringify(value) : String(value);

            return (document.cookie = [
				config.raw ? key : encodeURIComponent(key),
				'=',
				config.raw ? value : encodeURIComponent(value),
				options.expires ? '; expires=' + options.expires.toUTCString() : '', // use expires attribute, max-age is not supported by IE
				options.path ? '; path=' + options.path : '',
				options.domain ? '; domain=' + options.domain : '',
				options.secure ? '; secure' : ''
            ].join(''));
        }

        // read
        var decode = config.raw ? raw : decoded;
        var cookies = document.cookie.split('; ');
        var result = key ? undefined : {};
        for (var i = 0, l = cookies.length; i < l; i++) {
            var parts = cookies[i].split('=');
            var name = decode(parts.shift());
            var cookie = decode(parts.join('='));

            if (key && key === name) {
                result = converted(cookie);
                break;
            }

            if (!key) {
                result[name] = converted(cookie);
            }
        }

        return result;
    };

    config.defaults = {};

    $.removeCookie = function (key, options) {
        if ($.cookie(key) !== undefined) {
            $.cookie(key, '', $.extend(options, { expires: -1 }));
            return true;
        }
        return false;
    };

}));$(document).ready(function () {
    jQuery(document).ready(function ($) {

        //$.log('in _menu.js $.Media: ' + $.Media + ' indexOf("desktop")='+$.Media.indexOf('desktop'));
        //if ($.Media.indexOf('desktop') < 0) return false; // only show the flyout menus for the "desktop" version of the site (based on CSS media query)

        // tooltip help object to displaying assitance in the user-interface
        var Help = function () {
            Help.TopOffset = 10;	// "static" property of the Help "class"
            Help.Text = 'Press spacebar for more options...';
            //this.superclass = Element; this.superclass(); // set and call the "superclass"  <- the Element "class" is invoked every time an instance of the object is created
            this.__construct();
            this.setCssClass([$.CssClassNames.popover, $.CssClassNames.help]);
            this.generateTextNode(Help.Text);
            return this;
        }
        Help.prototype = new $.Element(); // set and call the "superclass" <- the Element "class" is invoked once when first encountered making it more 'efficient' (especially when creating many instances)

        // the Ribbon object generates a "ribbon" that visually connects the menu control/tab to the popover sub menu
        var Ribbon = function () {
            Ribbon.offset = 12;
            Ribbon.overhang = 12;
            //this.superclass = Element; this.superclass(); // set and call the "superclass"
            this.__construct();
            this.setCssClass($.CssClassNames.ribbon);
            return this;
        }
        Ribbon.prototype = new $.Element(); // set and call the "superclass"

        $.hidePopover = function (control, popover) {
            $(popover).safeFadeOut();
        }
        // clear all visible .popovers - this includes help and sub menu popovers (as they all have the .popover class)
        $.hideAllPopovers = function () {
            $('.' + $.CssClassNames.popover).safeFadeOut();
        }

        /** jQuery to make sub navigation popover menus display for both mouse over and pressing the space bar key on the keyboard 	
        */
        $('#nav').each(function (index, element) {

            // define variables and functions
            var menu = this,
                    $menu = $(this),
                    $submenus = $menu.find('.' + $.CssClassNames.subnav),
                    $controls = $menu.find('>ul>li>a'),
                    /* @control - reference to the A element in the #main-menu nav bar
                         @submenu - sub navigation that relates to the control
                  */
                    displaySubMenu = function (control, submenu) {
                        var $submenu = $(submenu),
                                $control = $(control),
                                top = $control.outerHeight() + Ribbon.offset, // add the offset to shift the popover menu down a bit away from the tabs
                                ribbon_offset = Ribbon.offset + 1; // make the ribbon height a bit larger to accomodate rounding issues
                        $control.addClass($.CssClassNames.navFocus);
                        $(submenu.ribbon).css({ top: '-' + ribbon_offset + 'px', left: control.offsetLeft + 'px', height: (ribbon_offset + Ribbon.overhang) + 'px', width: $control.outerWidth() + 'px' });
                        $.hideAllPopovers(); // before we show the menu we need to clear all popovers from view
                        $submenu.safeFadeIn();
                    },
                    hideSubmenu = function (control, submenu) {
                        $.hidePopover(control, submenu);
                        $(control).removeClass($.CssClassNames.navFocus);
                    },
                    hideAllSubmenus = function () {
                        $.hideAllPopovers();
                        $controls.removeClass($.CssClassNames.navFocus);
                    };

            $controls.each(function () {
                //create instance of the help control
                var help = new Help().getElement();
                this.help = help;
                //$(this).after(help);
            });

            // focusing on the navigation menu closes any open subnav menus
            $controls.bind('focus', function (event) {
                hideAllSubmenus();
            });

            $submenus.each(function () {
                // variables to hold references to setTimeout functions (so as to clear them when required and stop the nested anonamous function firing)			
                var submenu = this,
                        $submenu = $(this),
                        li = $(this).closest('li'),
                        control = $(li).find('a')[0], // control is the A element the user interacts with
                        $control = $(control),
                        timer_hover_delay_to_show_popover,
                        timer_to_hover_over_popover,
                        timer_focus_delay_to_show_help_popover,
                        ribbon = new Ribbon().getElement(),
                        $ribbon = $(ribbon),
                        phantom = new $.PhantomLink().getElement(),
                        $phantom = $(phantom);

                submenu.ribbon = ribbon;
                //$ribbon.prependTo(submenu);
                //$submenu.append(phantom);

                $phantom.bind('focus', function (event) {
                    $control.trigger('focus');
                });

                // assign event handlers
                $submenu.bind('click', function (event) {
                    event.stopPropagation(); // we don't want the click event going further than the submenu
                });
                $control.bind('mouseover', function (event) { // mouseover
                    timer_hover_delay_to_show_popover = setTimeout(function () {
                        displaySubMenu(control, submenu);
                        $submenu.bind('mouseover', function (event) {
                            clearTimeout(timer_to_hover_over_popover);
                        }).bind('mouseleave', function (event) {
                            hideSubmenu(control, submenu);
                        });
                    }, $.Delay.Show);
                }).bind('mouseout', function (event) {
                    clearTimeout(timer_hover_delay_to_show_popover);
                    timer_to_hover_over_popover = setTimeout(function () {
                        hideSubmenu(control, submenu);
                    }, $.Delay.Hide); // time allowed for the user to move the mouse over the tab to the popover (when opened) - if the user doesn't move the mouse cursor over the popover in this time it will close
                }).bind('focus', function (event) { // when focusing on a link we show the help popover telling the user they can press the spacebar to show (and hide) the sub-navigation popover
                    // the help popover component shows here
                    var control = this;
                    timer_focus_delay_to_show_help_popover = setTimeout(function () { // time delay to show the help after time 1.2 seconds			
                        // if the .popover.nav is visible then don't go any further
                        if ($submenus.is(':visible')) {
                            return;
                        }
                        $(control.help).css({ left: control.offsetLeft + 'px', top: ($(control).outerHeight() + Help.TopOffset) + 'px' });
                        $(control.help).safeFadeIn();
                        setTimeout(function () { // auto-remove the help popover after three seconds
                            if ($(control.help).is(':visible')) {
                                $.hideAllPopovers();
                            }
                        }, $.TipDuration);
                    }, $.TipDuration);
                }).bind('blur', function (event) {
                    clearTimeout(timer_focus_delay_to_show_help_popover); // bluring away from the control/link will clearn the timeout stopping it from displaying if it hasn't already done so
                }).bind('keypress', function (event) {
                    if (event.which == 32) { // space bar pressed - pressing spacebar toggles the subnavigation menu displayed or hidden (after being lazy-loaded)
                        event.preventDefault();
                        //$.log('space-bar pressed');
                        if ($submenu.filter(":visible").length) { // when the subnavigation menu exists and is displayed hide it
                            hideSubmenu(control, submenu);
                        } else { // otherwise generate/show the popover
                            displaySubMenu(control, submenu);
                            $(document).bind('click', function (event) {
                                hideSubmenu(control, submenu);
                            });
                        }
                    }
                });

            });

        });

    });
    // add accessibile navigation help text 
    $('.immi-subnav-help').each(function () {
        var allyHelp = $('<div/>')
        .addClass('ym-hideme')
        .text('Press spacebar for more options...')
        .wrapInner('<p/>');
        $(this).after(allyHelp);
    });
});/** _slideshow.js
 *  jQuery to make the footer background become more opaque when a contained link is focused and more transparent when blurred
 *	this type of functioality is handled by the CSS for mouse over but JS is needed for keyboard focus/blur events
 *	
 *  TODO: make scirpt support mobile platform -- current it supports only desktop/tablet
 * 				mobile needs to support touch events for swips instead of links/buttons
 */


jQuery(document).ready(function ($) {


    if ($("#nav").is(":visible")) {	// check if the nav is visible, therefoe not mobile size					

        var effectTime = 800,	//cross-fade time (in milliseconds)
				autoplay = true; // slideshow plays on load

        // the Phtantom link is a link styled out of the view-port, that, when focused will move the focus to another location - refocusing established on the instance of the object
        var PlayPause = function () {

            PlayPause.ToolTip = {
                Play: 'Play/Pause control - paused - click to play',
                Pause: 'Play/Pause control - playing - click to pause'
            };

            var element;

            this.__construct = function () {
                element = document.createElement("button");
                element.className = $.CssClassNames.slideshowPlayPause;
                element.setAttribute('title', PlayPause.ToolTip.Play);
                element.appendChild(document.createTextNode('Play/Pause'));
            }();

            this.getElement = function () {
                return element;
            }

            element.setPlay = function () {
                $(element).attr('title', PlayPause.ToolTip.Play); // set A back to play state
                $(element).addClass($.CssClassNames.slideshowPaused); //this.classList.add($.CssClassNames.slideshowPaused);
            }
            element.setPause = function () { // set A back to pause state
                $(element).attr('title', PlayPause.ToolTip.Pause);
                $(element).removeClass($.CssClassNames.slideshowPaused); //this.classList.remove($.CssClassNames.slideshowPaused);
            }

            return this;
        }
        //PlayPause.prototype = new $.Framework.Element(); // set and call the "superclass"



           
         
        
    }



});
/*
 * jQuery outside events - v1.1 - 3/16/2010
 * http://benalman.com/projects/jquery-outside-events-plugin/
 * 
 * Copyright (c) 2010 "Cowboy" Ben Alman
 * Dual licensed under the MIT and GPL licenses.
 * http://benalman.com/about/license/
 */
(function ($, c, b) { $.map("click dblclick mousemove mousedown mouseup mouseover mouseout change select submit keydown keypress keyup".split(" "), function (d) { a(d) }); a("focusin", "focus" + b); a("focusout", "blur" + b); $.addOutsideEvent = a; function a(g, e) { e = e || g + b; var d = $(), h = g + "." + e + "-special-event"; $.event.special[e] = { setup: function () { d = d.add(this); if (d.length === 1) { $(c).bind(h, f) } }, teardown: function () { d = d.not(this); if (d.length === 0) { $(c).unbind(h) } }, add: function (i) { var j = i.handler; i.handler = function (l, k) { l.target = k; j.apply(this, arguments) } } }; function f(i) { $(d).each(function () { var j = $(this); if (this !== i.target && !j.has(i.target).length) { j.triggerHandler(e, [i.target]) } }) } } })(jQuery, document, "outside");

/**
 * ## jsTree 2.0.0-alpha ##
 * http://jstree.com/
 *
 * Copyright (c) 2013 Ivan Bozhanov (http://vakata.com)
 *
 * Licensed same as jquery - under the terms of the MIT License
 *   http://www.opensource.org/licenses/mit-license.php
 *
 */
(function ($) {
    "use strict";

    // prevent another load? maybe there is a better way?
    if ($.jstree) {
        return;
    }

    // internal variables
    var instance_counter = 0,
		ccp_node = false,
		ccp_mode = false,
		themes_loaded = [];

    /**
	 * ### Static $.jstree object
	 *
	 * `$.jstree` holds all jstree related functions and variables
	 *
	 * * `version` the jstree version in use
	 * * `plugins` stores all loaded jstree plugins
	 * * `defaults` holds the core & plugin's defaults
	 *
	 */
    $.jstree = {
        version: '2.0.0-alpha',
        defaults: {
            plugins: []
        },
        plugins: {}
    };
    /**
	 * `$.jstree.create()` creates a jstree instance
	 *
	 * __Parameters__
	 *
	 * * `el` - the element to create the instance in
	 * * `options` - options for the instance, extends `$.jstree.defaults`
	 *
	 * __Returns__
	 * the new jstree instance
	 */
    $.jstree.create = function (el, options) {
        var tmp = new $.jstree.core(++instance_counter),
			opt = options;
        options = $.extend(true, {}, $.jstree.defaults, options);
        if (opt && opt.plugins) {
            options.plugins = opt.plugins;
        }
        $.each(options.plugins, function (i, k) {
            if (i !== 'core') {
                tmp = tmp.plugin(k, options[k]);
            }
        });
        tmp.init(el, options);
        return tmp;
    };
    /**
	 * `$.jstree.core()` the actual empty class.
	 *
	 * Used internally -  to create an instance use either:
	 *
	 * * `$.jstree.create(element, options)` or
	 * * `$(selector).jstree(options)`
	 *
	 * __Parameters__
	 *
	 * * `id` - the instance index - passed internally
	 */
    $.jstree.core = function (id) {
        this._id = id;
        this._data = {
            'core': {
                'themes': {}
            }
        };
    };
    /**
	 * `$.jstree.reference()` get an instance by some selector.
	 *
	 * __Parameters__
	 *
	 * * `needle` - a DOM element / jQuery object to search by.
	 */
    $.jstree.reference = function (needle) {
        return $(needle).closest('.jstree').data('jstree');
    };
    /**
	 * ### jQuery $().jstree method
	 *
	 * `$(selector).jstree()` is used to create an instance on the selector or to invoke a command on a instance. `Uses $.jstree.create()` internally.
	 *
	 * __Examples__
	 *
	 *	$('#container').jstree();
	 *	$('#container').jstree({ option : value });
	 *	$('#container').jstree('open_node', '#branch_1');
	 *
	 */
    $.fn.jstree = function (arg) {
        // check for string argument
        var is_method = (typeof arg === 'string'),
			args = Array.prototype.slice.call(arguments, 1),
			result = null;
        this.each(function () {
            // get the instance (if there is one) and method (if it exists)
            var instance = $(this).data('jstree'),
				method = is_method && instance ? instance[arg] : null;
            // if calling a method, and method is available - execute on the instance
            result = is_method && method ?
				method.apply(instance, args) :
				null;
            // if there is no instance - create one
            if (!instance) {
                $(this).data('jstree', new $.jstree.create(this, arg));
            }
            // if there was a method call which returned a result - break and return the value
            if (result !== null && typeof result !== 'undefined') {
                return false;
            }
        });
        // if there was a method call with a valid return value - return that, otherwise continue the chain
        return result !== null && typeof result !== 'undefined' ?
            result : this;
    };
    /**
	 * ### jQuery :jstree pseudo selector
	 *
	 * `$(':jstree')` is used to find elements containing an instance
	 *
	 * __Examples__
	 *
	 *	$('div:jstree').each(function () {
	 *		$(this).jstree('destroy');
	 *	});
	 *
	 */
    $.expr[':'].jstree = $.expr.createPseudo(function (search) {
        return function (a) {
            return $(a).hasClass('jstree') &&
				typeof ($(a).data('jstree')) !== 'undefined';
        };
    });

    /**
	 * ### jsTree core settings
	 *
	 * `$.jstree.defaults.core` stores all defaults for the core.
	 *
	 * * `string` should be an object or a function:
	 *
	 *		// object
	 *		{
	 *			'Loading ...' : ' ...'
	 *			...
	 *		}
	 *
	 *		// function
	 *		function (key) {
	 *			switch(key) {
	 *				case 'Loading ...':
	 *					return ' ...';
	 *			...
	 *		}
	 *
	 *	This setting is handled in the `get_string()` function, if no match is found, the key itself is used.
	 *
	 * * `check_callback` should either be a boolean or a function:
	 */
    $.jstree.defaults.core = {
        strings: false,
        check_callback: true,
        animation: 100,
        aria_roles: false,
        multiple: true,
        themes: {
            name: false,
            url: true,
            dots: true,
            icons: true,
            dir: false
        },
        base_height: false,
        clean_loaded: true,
        correct_loaded: true,
        expand_selected_onload: true
    };

    /**
	 * ### jsTree core methods
	 */
    $.jstree.core.prototype = {
        /**
		 * `plugin()` is used to decorate an instance with a plugin. Used internally in `$.jstree.create()`.
		 *
		 * __Parameters__
		 *
		 * * `deco` - the plugin to activate on the instance
		 * * `options` - options for the plugin
		 *
		 * __Returns__
		 * the decorated jstree instance
		 *
		 * _Plugin authors are better off reading the options from `this.settings.{plugin_name}` in the `.bind()` or `init()` function of their plugins._
		 */
        plugin: function (deco, opts) {
            var Child = $.jstree.plugins[deco];
            if (Child) {
                this._data[deco] = {};
                Child.prototype = this;
                return new Child(opts, this);
            }
            return this;
        },
        /**
		 * `init()`
		 *
		 * __Parameters__
		 *
		 * * `par`
		 *
		 * __Returns__
		 *
		 */
        init: function (el, options) {
            this.element = $(el).addClass('jstree jstree-' + this._id);
            this.settings = options;
            this.element.bind("destroyed", $.proxy(this.teardown, this));

            this._data.core.ready = false;
            this._data.core.loaded = false;
            this._data.core.rtl = (this.element.css("direction") === "rtl");
            this.element[this._data.core.rtl ? 'addClass' : 'removeClass']("jstree-rtl");
            if (this.settings.core.aria_roles) {
                this.element.attr('role', 'tree');
            }
            this._data.core.selected = $();

            this.bind();
            this.trigger("init");

            this._data.core.original_container_html = this.element.find(" > ul > li").clone(true);
            this._data.core.original_container_html
				.find("li").addBack()
				.contents().filter(function () {
				    return this.nodeType === 3 && (!this.nodeValue || /^\s+$/.test(this.nodeValue));
				})
				.remove();
            this.element.html("<" + "ul><" + "li class='jstree-loading jstree-leaf jstree-last'><i class='jstree-icon jstree-ocl'></i><" + "a class='jstree-anchor' href='#'>" + this.get_string("Loading ...") + "</a></li></ul>");
            this._data.core.li_height = this.settings.base_height || this.get_container_ul().children("li:eq(0)").height() || 18;
            this.load_node(-1);
        },
        /**
		 * `destroy()`
		 */
        destroy: function () {
            this.element.unbind("destroyed", this.teardown);
            this.teardown();
        },
        /**
		 * `teardown()`
		 */
        teardown: function () {
            this.unbind();
            this.element
				.removeClass('jstree')
				.removeData('jstree')
				.find("[class^='jstree']")
					.addBack()
					.attr("class", function () { return this.className.replace(/jstree[^ ]*|$/ig, ''); });
            this.element = null;
        },
        /**
		 * `bind()`
		 */
        bind: function () {
            if ($.support.touch) {
                this.element.addTouch();
            }
            this.element
				.on("dblclick.jstree", function () {
				    if (document.selection && document.selection.empty) {
				        document.selection.empty();
				    }
				    else {
				        if (window.getSelection) {
				            var sel = window.getSelection();
				            try {
				                sel.removeAllRanges();
				                sel.collapse();
				            } catch (er) { }
				        }
				    }
				})
				.on("click.jstree", ".jstree-ocl", $.proxy(function (e) {
				    this.toggle_node(e.target);
				}, this))
				.on("click.jstree", ".jstree-anchor", $.proxy(function (e) {
				    // removed to allow clicking through of links
				    // e.preventDefault();
				    //Check for hash links and expand 
				    if (e.currentTarget.href.indexOf("#") != -1) {
				        if ($(e.currentTarget).parent().hasClass("jstree-closed")) {
				            this.open_node(e.currentTarget);
				        }
				        else {
				            this.close_node(e.currentTarget);
				        }
				        return false;
				    }
				    this.activate_node(e.currentTarget, e);
				}, this))
				.on('keydown.jstree', '.jstree-anchor', $.proxy(function (e) {
				    var o = null;
				    switch (e.which) {
				        case 13:
				        case 32:
				            e.type = "click";
				            $(e.currentTarget).trigger(e);
				            break;
				        case 37:
				            e.preventDefault();
				            if (this.is_open(e.currentTarget)) {
				                this.close_node(e.currentTarget);
				            }
				            else {
				                o = this.get_prev(e.currentTarget);
				                if (o && o.length) { o.children('.jstree-anchor').focus(); }
				            }
				            break;
				        case 38:
				            e.preventDefault();
				            o = this.get_prev(e.currentTarget);
				            if (o && o.length) { o.children('.jstree-anchor').focus(); }
				            break;
				        case 39:
				            e.preventDefault();
				            if (this.is_closed(e.currentTarget)) {
				                this.open_node(e.currentTarget);
				            }
				            else {
				                o = this.get_next(e.currentTarget);
				                if (o && o.length) { o.children('.jstree-anchor').focus(); }
				            }
				            break;
				        case 40:
				            e.preventDefault();
				            o = this.get_next(e.currentTarget);
				            if (o && o.length) { o.children('.jstree-anchor').focus(); }
				            break;
				        default:
				            //console.log(e.which);
				            break;
				    }
				}, this))
				.on("create_node.jstree", $.proxy(function (e, data) {
				    this.clean_node(data.node);
				}, this))
				.on("load_node.jstree", $.proxy(function (e, data) {
				    if (data.status) {
				        if (this.settings.core.clean_loaded) {
				            if (data.node === -1) {
				                // only detach for root (checkbox three-state will not work otherwise)
				                // also - if you could use async clean_node won't be such an issue
				                var ul = this.get_container_ul().detach();
				                if (ul.children('li').length) {
				                    this.clean_node(ul.children('li'));
				                }
				                this.element.prepend(ul);
				            }
				            else {
				                var s = this._data.core.selected.length;
				                if (data.node.children("ul").children("li").length) {
				                    this.clean_node(data.node.children("ul").children("li"));
				                }
				                if (this._data.core.ready && s !== this._data.core.selected.length) {
				                    this.trigger('changed', { 'action': 'clean_node', 'selected': this._data.core.selected });
				                }
				            }
				        }
				        if (data.node === -1 && !this._data.core.loaded) {
				            this._data.core.loaded = true;
				            this.trigger("loaded");
				        }
				        if (!this._data.core.ready && !this.get_container_ul().find('.jstree-loading:eq(0)').length) {
				            this._data.core.ready = true;
				            if (this._data.core.selected.length) {
				                if (this.settings.core.expand_selected_onload) {
				                    this._data.core.selected.parents(".jstree-closed").each($.proxy(function (i, v) { this.open_node(v, false, 0); }, this));
				                }
				                this.trigger('changed', { 'action': 'ready', 'selected': this._data.core.selected });
				            }
				            this.trigger("ready");
				        }
				    }
				}, this))
				.on("loaded.jstree", $.proxy(function (e, data) {
				    if (this.settings.core.correct_loaded) {
				        data.instance.get_container_ul().children('li').each(function () {
				            data.instance.correct_node(this);
				        });
				    }
				}, this))
				.on("open_node.jstree", $.proxy(function (e, data) {
				    if (this.settings.core.correct_loaded) {
				        data.node.children('li').each(function () {
				            data.instance.correct_node(this);
				        });
				    }
				}, this))
				// THEME RELATED
				.on("init.jstree", $.proxy(function () {
				    var s = this.settings.core.themes;
				    this._data.core.themes.dots = s.dots;
				    this._data.core.themes.icons = s.icons;

				    if (s.name === false) {
				        s.name = 'default';
				    }
				    this.set_theme(s.name, s.url);
				}, this))
				.on('loaded.jstree', $.proxy(function () {
				    this[this._data.core.themes.dots ? "show_dots" : "hide_dots"]();
				    this[this._data.core.themes.icons ? "show_icons" : "hide_icons"]();
				}, this))
				.on('focus.jstree', '.jstree-anchor', $.proxy(function (e) {
				    $(e.currentTarget).mouseenter();
				}, this))
				.on('blur.jstree', '.jstree-anchor', $.proxy(function (e) {
				    $(e.currentTarget).mouseleave();
				}, this))
				.on('mouseenter.jstree', '.jstree-anchor', $.proxy(function (e) {
				    var o = this.element.find('.jstree-anchor:focus').not('.jstree-clicked');
				    if (o && o.length && o[0] !== e.currentTarget) {
				        o.blur();
				    }
				    this.hover_node(e.currentTarget);
				}, this))
				.on('mouseleave.jstree', '.jstree-anchor', $.proxy(function (e) {
				    this.dehover_node(e.currentTarget);
				}, this));
        },
        /**
		 * `unbind()`
		 */
        unbind: function () {
            this.element.off('.jstree');
            $(document).off('.jstree-' + this._id);
        },
        /**
		 * `trigger()`
		 *
		 * __Parameters__
		 *
		 * * `ev`
		 * * `data`
		 */
        trigger: function (ev, data, wait) {
            if (!data) {
                data = {};
            }
            data.instance = this;
            if ((typeof wait).toLowerCase() === 'number') {
                setTimeout($.proxy(function () {
                    this.element.triggerHandler(ev.replace('.jstree', '') + '.jstree', data);
                }, this), wait);
            }
            else {
                this.element.triggerHandler(ev.replace('.jstree', '') + '.jstree', data);
            }
        },
        /**
		 * `get_container()`
		 *
		 * __Returns__
		 *
		 */
        get_container: function () {
            return this.element;
        },
        /**
		 * `get_container_ul()`
		 *
		 * __Returns__
		 *
		 */
        get_container_ul: function () {
            return this.element.children("ul:eq(0)");
        },
        /**
		 * `get_string()`
		 *
		 * __Parameters__
		 *
		 * * `key`
		 *
		 * __Returns__
		 *
		 */
        get_string: function (key) {
            var a = this.settings.core.strings;
            if ($.isFunction(a)) { return a.call(this, key); }
            if (a && a[key]) { return a[key]; }
            return key;
        },

        _firstChild: function (dom) {
            dom = dom ? dom.firstChild : null;
            while (dom !== null && dom.nodeType !== 1) {
                dom = dom.nextSibling;
            }
            return dom;
        },
        _nextSibling: function (dom) {
            dom = dom ? dom.nextSibling : null;
            while (dom !== null && dom.nodeType !== 1) {
                dom = dom.nextSibling;
            }
            return dom;
        },
        _previousSibling: function (dom) {
            dom = dom ? dom.previousSibling : null;
            while (dom !== null && dom.nodeType !== 1) {
                dom = dom.previousSibling;
            }
            return dom;
        },
        /**
		 * `get_node()`
		 *
		 * __Parameters__
		 *
		 * * `obj`
		 *
		 * __Returns__
		 *
		 */
        get_node: function (obj) {
            if (obj === -1) {
                return -1;
            }
            obj = $(obj, this.element);
            if (obj.hasClass(".jstree")) {
                return -1;
            }
            obj = obj.closest("li", this.element);
            return obj.length ? obj : false;
        },
        /**
		 * `get_next()`
		 *
		 * __Parameters__
		 *
		 * * `obj`
		 * * `strict`
		 *
		 * __Returns__
		 *
		 */
        get_next: function (obj, strict) {
            var tmp;
            obj = this.get_node(obj);
            if (obj === -1) {
                tmp = this._firstChild(this.get_container_ul()[0]);
                return tmp ? $(tmp) : false;
            }
            if (!obj || !obj.length) {
                return false;
            }
            if (strict) {
                tmp = this._nextSibling(obj[0]);
                return tmp ? $(tmp) : false;
            }
            if (obj.hasClass("jstree-open")) {
                tmp = this._firstChild(obj.children('ul')[0]);
                return tmp ? $(tmp) : false;
            }
            else if ((tmp = this._nextSibling(obj[0]))) {
                return $(tmp);
            }
            else {
                return obj.parentsUntil(".jstree", "li").next("li").eq(0);
            }
        },
        /**
		 * `get_prev()`
		 *
		 * __Parameters__
		 *
		 * * `obj`
		 * * `strict`
		 *
		 * __Returns__
		 *
		 */
        get_prev: function (obj, strict) {
            var tmp;
            obj = this.get_node(obj);
            if (obj === -1) {
                tmp = this.get_container_ul()[0].lastChild;
                return tmp ? $(tmp) : false;
            }
            if (!obj || !obj.length) {
                return false;
            }
            if (strict) {
                tmp = this._previousSibling(obj[0]);
                return tmp ? $(tmp) : false;
            }
            if ((tmp = this._previousSibling(obj[0]))) {
                obj = $(tmp);
                while (obj.hasClass("jstree-open")) {
                    obj = obj.children("ul:eq(0)").children("li:last");
                }
                return obj;
            }
            else {
                tmp = obj[0].parentNode.parentNode;
                return tmp && tmp.tagName === 'LI' ? $(tmp) : false;
            }
        },
        /**
		 * `get_parent()`
		 *
		 * __Parameters__
		 *
		 * * `obj`
		 *
		 * __Returns__
		 *
		 */
        get_parent: function (obj) {
            obj = this.get_node(obj);
            if (obj === -1 || !obj || !obj.length) {
                return false;
            }
            var o = obj[0].parentNode.parentNode;

            return o.tagName === 'LI' ? $(o) : -1;
        },
        /**
		 * `get_children()`
		 *
		 * __Parameters__
		 *
		 * * `obj`
		 *
		 * __Returns__
		 *
		 */
        get_children: function (obj) {
            obj = this.get_node(obj);
            if (obj === -1) {
                return this.get_container_ul().children("li");
            }
            if (!obj || !obj.length) {
                return false;
            }
            return obj.children("ul").children("li");
        },
        /**
		 * `is_parent()`
		 *
		 * __Parameters__
		 *
		 * * `obj`
		 *
		 * __Returns__
		 *
		 */
        is_parent: function (obj) {
            obj = this.get_node(obj);
            return obj && obj !== -1 && (this._firstChild(obj.children("ul")[0]) || obj.hasClass("jstree-closed"));
        },
        /**
		 * `is_loaded()`
		 *
		 * __Parameters__
		 *
		 * * `obj`
		 *
		 * __Returns__
		 *
		 */
        is_loaded: function (obj) {
            obj = this.get_node(obj);
            return obj && ((obj === -1 && !this.element.children("ul").children("li.jstree-loading").length) || (obj !== -1 && !obj.hasClass('jstree-loading') && (this._firstChild(obj.children("ul")[0]) || obj.hasClass('jstree-leaf'))));
        },
        /**
		 * `is_loading()`
		 *
		 * __Parameters__
		 *
		 * * `obj`
		 *
		 * __Returns__
		 *
		 */
        is_loading: function (obj) {
            obj = this.get_node(obj);
            return obj && ((obj === -1 && this.element.children("ul").children("li.jstree-loading").length) || (obj !== -1 && obj.hasClass("jstree-loading")));
        },
        /**
		 * `is_open()`
		 *
		 * __Parameters__
		 *
		 * * `obj`
		 *
		 * __Returns__
		 *
		 */
        is_open: function (obj) {
            obj = this.get_node(obj);
            return obj && obj !== -1 && obj.hasClass("jstree-open");
        },
        /**
		 * `is_closed()`
		 *
		 * __Parameters__
		 *
		 * * `obj`
		 *
		 * __Returns__
		 *
		 */
        is_closed: function (obj) {
            obj = this.get_node(obj);
            return obj && obj !== -1 && obj.hasClass("jstree-closed");
        },
        /**
		 * `is_leaf()`
		 *
		 * __Parameters__
		 *
		 * * `obj`
		 *
		 * __Returns__
		 *
		 */
        is_leaf: function (obj) {
            obj = this.get_node(obj);
            return obj && obj !== -1 && obj.hasClass("jstree-leaf");
        },
        /**
		 * `load_node()`
		 *
		 * __Parameters__
		 *
		 * * `obj`
		 * * `callback`
		 *
		 * __Returns__
		 *
		 */
        load_node: function (obj, callback) {
            obj = this.get_node(obj);
            if (!obj) {
                callback.call(this, obj, false);
                return false;
            }
            // if(this.is_loading(obj)) { return true; }
            if (obj !== -1) {
                obj.addClass("jstree-loading");
            }
            this._load_node(obj, $.proxy(function (status) {
                if (obj !== -1) {
                    obj.removeClass("jstree-loading");
                }
                this.trigger('load_node', { "node": obj, "status": status });
                if (callback) {
                    callback.call(this, obj, status);
                }
            }, this));
            return true;
        },
        /**
		 * `_load_node()`
		 *
		 * __Parameters__
		 *
		 * * `obj`
		 * * `callback`
		 *
		 * __Returns__
		 *
		 */
        _load_node: function (obj, callback) {
            if (obj === -1) {
                this.get_container_ul().empty().append(this._data.core.original_container_html.clone(true));
                callback.call(this, true);
            }
            else {
                callback.call(this, false);
            }
        },
        /**
		 * `open_node()`
		 *
		 * __Parameters__
		 *
		 * * `obj`
		 * * `callback`
		 * * `animation`
		 *
		 * __Returns__
		 *
		 */
        open_node: function (obj, callback, animation) {
            obj = this.get_node(obj);
            if (obj === -1 || !obj || !obj.length) {
                return false;
            }
            animation = (typeof animation).toLowerCase() === "undefined" ? this.settings.core.animation : animation;
            if (!this.is_closed(obj)) {
                if (callback) {
                    callback.call(this, obj, false);
                }
                return false;
            }
            if (!this.is_loaded(obj)) { // TODO: is_loading?
                this.load_node(obj, function (o, ok) {
                    return ok ? this.open_node(o, callback, animation) : (callback ? callback.call(this, o, false) : false);
                });
            }
            else {
                var t = this;
                if (!animation) {
                    obj[0].className = obj[0].className.replace('jstree-closed', 'jstree-open');
                }
                else {
                    obj
						.children("ul").css("display", "none").end()
						.removeClass("jstree-closed").addClass("jstree-open")
						.children("ul").stop(true, true)
							.slideDown(animation, function () {
							    this.style.display = "";
							    t.trigger("after_open", { "node": obj });
							});
                }
                if (callback) {
                    callback.call(this, obj, true);
                }
                this.trigger('open_node', { "node": obj });
                if (!animation) {
                    this.trigger("after_open", { "node": obj });
                }
            }
        },
        /**
		 * `close_node()`
		 *
		 * __Parameters__
		 *
		 * * `obj`
		 * * `animation`
		 *
		 * __Returns__
		 *
		 */
        close_node: function (obj, animation) {
            obj = this.get_node(obj);
            if (!obj || !obj.length || !this.is_open(obj)) {
                return false;
            }
            animation = (typeof animation).toLowerCase() === "undefined" ? this.settings.core.animation : animation;
            var t = this;
            if (!animation) {
                obj[0].className = obj[0].className.replace('jstree-open', 'jstree-closed');
            }
            else {
                obj
					.children("ul").attr("style", "display:block !important").end()
					.removeClass("jstree-open").addClass("jstree-closed")
					.children("ul").stop(true, true).slideUp(animation, function () {
					    this.style.display = "";
					    t.trigger("after_close", { "node": obj });
					});
            }
            this.trigger('close_node', { "node": obj });
            if (!animation) {
                this.trigger("after_close", { "node": obj });
            }
        },
        /**
		 * `toggle_node()`
		 *
		 * __Parameters__
		 *
		 * * `obj`
		 *
		 * __Returns__
		 *
		 */
        toggle_node: function (obj) {
            if (this.is_closed(obj)) {
                return this.open_node(obj);
            }
            if (this.is_open(obj)) {
                return this.close_node(obj);
            }
        },
        /**
		 * `open_all()`
		 *
		 * __Parameters__
		 *
		 * * `obj`
		 * * `animation`
		 * * `original_obj`
		 *
		 * __Returns__
		 *
		 */
        open_all: function (obj, animation, original_obj) {
            obj = obj ? this.get_node(obj) : -1;
            obj = !obj || obj === -1 ? this.get_container_ul() : obj;
            original_obj = original_obj || obj;
            var _this = this;
            obj = this.is_closed(obj) ? obj.find('li.jstree-closed').addBack() : obj.find('li.jstree-closed');
            obj.each(function () {
                _this.open_node(
					this,
					_this.is_loaded(this) ?
						false :
						function (obj) { this.open_all(obj, animation, original_obj); },
					animation || 0
				);
            });
            if (original_obj.find('li.jstree-closed').length === 0) {
                this.trigger('open_all', { "node": original_obj });
            }
        },
        /**
		 * `close_all()`
		 *
		 * __Parameters__
		 *
		 * * `obj`
		 * * `animation`
		 *
		 * __Returns__
		 *
		 */
        close_all: function (obj, animation) {
            obj = obj ? this.get_node(obj) : -1;
            var $obj = !obj || obj === -1 ? this.get_container_ul() : obj,
				_this = this;
            $obj = this.is_open($obj) ? $obj.find('li.jstree-open').addBack() : $obj.find('li.jstree-open');
            $obj.each(function () { _this.close_node(this, animation || 0); });
            this.trigger('close_all', { "node": obj });
        },
        /**
		 * `is_disabled()`
		 *
		 * __Parameters__
		 *
		 * * `obj`
		 *
		 * __Returns__
		 *
		 */
        is_disabled: function (obj) {
            obj = this.get_node(obj);
            return obj && obj !== -1 && obj.children('.jstree-anchor').hasClass("jstree-disabled");
        },
        /**
		 * `enable_node()`
		 *
		 * __Parameters__
		 *
		 * * `obj`
		 *
		 * __Returns__
		 *
		 */
        enable_node: function (obj) {
            obj = this.get_node(obj);
            if (!obj || !obj.length) {
                return false;
            }
            obj.children('.jstree-anchor').removeClass('jstree-disabled');
            this.trigger('enable_node', { 'node': obj });
        },
        /**
		 * `disable_node()`
		 *
		 * __Parameters__
		 *
		 * * `obj`
		 *
		 * __Returns__
		 *
		 */
        disable_node: function (obj) {
            obj = this.get_node(obj);
            if (!obj || !obj.length) {
                return false;
            }
            obj.children('.jstree-anchor').addClass('jstree-disabled');
            this.trigger('disable_node', { 'node': obj });
        },
        /**
		 * `activate_node()`
		 *
		 * __Parameters__
		 *
		 * * `obj`
		 * * `e`
		 *
		 * __Returns__
		 *
		 */
        activate_node: function (obj, e) {
            if (this.is_disabled(obj)) {
                return false;
            }
            if (!this.settings.core.multiple || (!e.metaKey && !e.ctrlKey)) {
                this.deselect_all(true);
                this.select_node(obj);
            }
            else {
                if (!this.is_selected(obj)) {
                    this.select_node(obj);
                }
                else {
                    this.deselect_node(obj);
                }
            }
            this.trigger('activate_node', { 'node': obj });
        },
        /**
		 * `hover_node()`
		 *
		 * __Parameters__
		 *
		 * * `obj`
		 *
		 * __Returns__
		 *
		 */
        hover_node: function (obj) {
            obj = this.get_node(obj);
            if (!obj || !obj.length) {
                return false;
            }
            obj.children('.jstree-anchor').addClass('jstree-hovered');
            this.trigger('hover_node', { 'node': obj });
        },
        /**
		 * `dehover_node()`
		 *
		 * __Parameters__
		 *
		 * * `obj`
		 *
		 * __Returns__
		 *
		 */
        dehover_node: function (obj) {
            obj = this.get_node(obj);
            if (!obj || !obj.length) {
                return false;
            }
            obj.children('.jstree-anchor').removeClass('jstree-hovered');
            this.trigger('dehover_node', { 'node': obj });
        },
        /**
		 * `select_node()`
		 *
		 * __Parameters__
		 *
		 * * `obj`
		 * * `supress_event`
		 *
		 * __Returns__
		 *
		 */
        select_node: function (obj, supress_event, prevent_open) {
            obj = this.get_node(obj);
            if (!obj || !obj.length) {
                return false;
            }
            this._data.core.selected = this._data.core.selected.add(obj);
            this.element.find('.jstree-clicked').removeClass('jstree-clicked');
            this._data.core.selected.children('.jstree-anchor').addClass('jstree-clicked');

            if (!prevent_open) {
                var t = this;
                obj.parents(".jstree-closed").each(function () { t.open_node(this, false, 0); });
            }

            this.trigger('select_node', { 'node': obj, 'selected': this._data.core.selected });

            if (!supress_event) {
                this.trigger('changed', { 'action': 'select_node', 'node': obj, 'selected': this._data.core.selected });
            }
        },
        /**
		 * `deselect_node()`
		 *
		 * __Parameters__
		 *
		 * * `obj`
		 * * `supress_event`
		 *
		 * __Returns__
		 *
		 */
        deselect_node: function (obj, supress_event) {
            obj = this.get_node(obj);
            if (!obj || !obj.length) {
                return false;
            }
            this._data.core.selected = this._data.core.selected.not(obj);

            this.element.find('.jstree-clicked').removeClass('jstree-clicked');
            this._data.core.selected.children('.jstree-anchor').addClass('jstree-clicked');

            this.trigger('deselect_node', { 'node': obj, 'selected': this._data.core.selected });

            if (!supress_event) {
                this.trigger('changed', { 'action': 'deselect_node', 'node': obj, 'selected': this._data.core.selected });
            }
        },
        /**
		 * `deselect_all()`
		 *
		 * __Parameters__
		 *
		 * * `supress_event`
		 *
		 */
        deselect_all: function (supress_event) {
            this._data.core.selected = $();

            var obj = this.element.find('.jstree-clicked').removeClass('jstree-clicked');

            this.trigger('deselect_all', { 'selected': this._data.core.selected, 'node': obj });
            if (!supress_event) {
                this.trigger('changed', { 'action': 'deselect_all', 'selected': this._data.core.selected, 'node': obj });
            }
        },
        /**
		 * `is_selected()`
		 *
		 * __Parameters__
		 *
		 * * `obj`
		 *
		 * __Returns__
		 *
		 */
        is_selected: function (obj) {
            obj = this.get_node(obj);
            if (!obj || !obj.length) {
                return false;
            }
            return this._data.core.selected.index(obj) >= 0;
        },
        /**
		 * `get_selected()`
		 *
		 * __Returns__
		 *
		 */
        get_selected: function () {
            return this._data.core.selected;
        },
        /**
		 * `clean_node()`
		 *
		 * __Parameters__
		 *
		 * * `obj`
		 *
		 */
        clean_node: function (obj) {
            // DETACH maybe inside the "load_node" function? But what about animations, etc?
            obj = this.get_node(obj);
            obj = !obj || obj === -1 ? this.element.find("li") : obj.find("li").addBack();
            // test placing this here
            obj.find('li.jstree-clicked').removeClass('jstree-clicked');
            if (this.settings.core.aria_roles) {
                obj.attr('role', 'treeitem').parent().attr('role', 'group');
            }
            var _this = this;
            return obj.each(function () {
                var t = $(this),
					a = t.children('a'),
					d = t.data("jstree"),
					// is_ajax -> return this.settings.core.is_ajax || this._data.ajax;
					s = (d && d.opened) || t.hasClass("jstree-open") ? "open" : (d && (d.closed || d.children)) || t.children("ul").length ? "closed" : "leaf"; // replace with t.children("ul").children("li").length || (this.is_ajax() && !t.children('ul').length)
                if (d && d.opened) { delete d.opened; }
                if (d && d.closed) { delete d.closed; }
                t.removeClass("jstree-open jstree-closed jstree-leaf jstree-last");
                if (!a.length) {
                    // allow for text and HTML markup inside the nodes
                    t.contents().filter(function () { return this.nodeType === 3 || this.tagName !== 'UL'; }).wrapAll('<a href="#"></a>');
                    // TODO: make this faster
                    a = t.children('a');
                    a.html(t.children('a').html().replace(/[\s\t\n]+$/, ''));
                }
                else {
                    if (!$.trim(a.attr('href'))) { a.attr("href", "#"); }
                }
                a.addClass('jstree-anchor');
                if (!t.children("i.jstree-ocl").length) {
                    t.prepend("<i class='jstree-icon jstree-ocl'>&#160;</i>");
                }
                if (!t.next().length) {
                    t.addClass("jstree-last");
                }
                switch (s) {
                    case 'leaf':
                        t.addClass('jstree-leaf');
                        break;
                    case 'closed':
                        t.addClass('jstree-closed');
                        _this.close_node(t, 0);
                        break;
                    case 'open':
                        t.addClass('jstree-closed');
                        _this.open_node(t, false, 0);
                        break;
                }
                // theme part
                if (!a.children("i.jstree-themeicon").length) {
                    a.prepend("<i class='jstree-icon jstree-themeicon'>&#160;</i>");
                }
                if (d && typeof d.icon !== 'undefined') {
                    _this.set_icon(t, d.icon);
                    delete d.icon;
                }
                if (d && d.selected) {
                    _this.select_node(t, true, true);
                    delete d.selected;
                }
                if (d && d.disabled) {
                    _this.disable_node(t);
                    delete d.disabled;
                }
            });
        },
        /**
		 * `correct_node()`
		 *
		 * __Parameters__
		 *
		 * * `obj`
		 * * `deep`
		 *
		 * __Returns__
		 *
		 */
        correct_node: function (obj, deep) {
            obj = this.get_node(obj);
            if (!obj || (obj === -1 && !deep)) { return false; }
            if (obj === -1) { obj = this.element.find('li'); }
            else { obj = deep ? obj.find('li').addBack() : obj; }
            obj.each(function () {
                var obj = $(this);
                switch (!0) {
                    case obj.hasClass("jstree-open") && !obj.children("ul").children("li").length:
                        obj.removeClass("jstree-open").addClass("jstree-leaf").children("ul").remove(); // children("ins").html("&#160;").end()
                        break;
                    case obj.hasClass("jstree-leaf") && !!obj.children("ul").children("li").length:
                        obj.removeClass("jstree-leaf").addClass("jstree-closed"); //.children("ins").html("+");
                        break;
                }
                obj[obj.next().length === 0 ? 'addClass' : 'removeClass']("jstree-last");
            });
            return obj;
        },
        /**
		 * `get_state()`
		 *
		 * __Returns__
		 *
		 */
        get_state: function () {
            var state = {
                'core': {
                    'open': [],
                    'scroll': {
                        'left': this.element.scrollLeft(),
                        'top': this.element.scrollTop()
                    },
                    'themes': {
                        'name': this.get_theme(),
                        'icons': this._data.core.themes.icons,
                        'dots': this._data.core.themes.dots
                    },
                    'selected': []
                }
            };
            this.get_container_ul().find('.jstree-open').each(function () { if (this.id) { state.core.open.push(this.id); } });
            this._data.core.selected.each(function () { if (this.id) { state.core.selected.push(this.id); } });
            return state;
        },
        /**
		 * `set_state()`
		 *
		 * __Parameters__
		 *
		 * * `state`
		 * * `callback`
		 *
		 * __Returns__
		 *
		 */
        set_state: function (state, callback) {
            if (state) {
                if (state.core) {
                    if ($.isArray(state.core.open)) {
                        var res = true,
							t = this;
                        //this.close_all();
                        $.each(state.core.open.concat([]), function (i, v) {
                            v = document.getElementById(v);
                            if (v) {
                                if (t.is_loaded(v)) {
                                    if (t.is_closed(v)) {
                                        t.open_node(v, false, 0);
                                    }
                                    $.vakata.array_remove(state.core.open, i);
                                }
                                else {
                                    if (!t.is_loading(v)) {
                                        t.open_node(v, $.proxy(function () { this.set_state(state); }, t), 0);
                                    }
                                    // there will be some async activity - so wait for it
                                    res = false;
                                }
                            }
                        });
                        if (res) {
                            delete state.core.open;
                            this.set_state(state, callback);
                        }
                        return false;
                    }
                    if (state.core.scroll) {
                        if (state.core.scroll && typeof state.core.scroll.left !== 'undefined') {
                            this.element.scrollLeft(state.core.scroll.left);
                        }
                        if (state.core.scroll && typeof state.core.scroll.top !== 'undefined') {
                            this.element.scrollTop(state.core.scroll.top);
                        }
                        delete state.core.scroll;
                        delete state.core.open;
                        this.set_state(state, callback);
                        return false;
                    }
                    if (state.core.themes) {
                        if (state.core.themes.name) {
                            this.set_theme(state.core.themes.name);
                        }
                        if (typeof state.core.themes.dots !== 'undefined') {
                            this[state.core.themes.dots ? "show_dots" : "hide_dots"]();
                        }
                        if (typeof state.core.themes.icons !== 'undefined') {
                            this[state.core.themes.icons ? "show_icons" : "hide_icons"]();
                        }
                        delete state.core.themes;
                        delete state.core.open;
                        this.set_state(state, callback);
                        return false;
                    }
                    if (state.core.selected) {
                        var _this = this;
                        this.deselect_all();
                        $.each(state.core.selected, function (i, v) {
                            _this.select_node(document.getElementById(v));
                        });
                        delete state.core.selected;
                        this.set_state(state, callback);
                        return false;
                    }
                    if ($.isEmptyObject(state)) {
                        if (callback) { callback.call(this); }
                        this.trigger('set_state');
                        return false;
                    }
                    return true;
                }
                return true;
            }
            return false;
        },
        /**
		 * `refresh()`
		 */
        refresh: function () {
            this._data.core.state = this.get_state();
            this.load_node(-1, function (o, s) {
                if (s) {
                    this.set_state($.extend(true, {}, this._data.core.state), function () {
                        this.trigger('refresh');
                    });
                }
                this._data.core.state = null;
            });
        },
        /**
		 * `get_text()`
		 *
		 * __Parameters__
		 *
		 * * `obj`
		 * * `remove_html`
		 *
		 * __Returns__
		 *
		 */
        get_text: function (obj, remove_html) {
            obj = this.get_node(obj);
            if (!obj || obj === -1 || !obj.length) { return false; }
            obj = obj.children("a:eq(0)").clone();
            obj.children(".jstree-icon").remove();
            obj = obj[remove_html ? 'text' : 'html']();
            obj = $('<div />')[remove_html ? 'text' : 'html'](obj);
            return obj.html();
        },
        /**
		 * `set_text()`
		 *
		 * __Parameters__
		 *
		 * * `obj`
		 * * `val`
		 *
		 * __Returns__
		 *
		 */
        set_text: function (obj, val) {
            obj = this.get_node(obj);
            if (!obj || obj === -1 || !obj.length) { return false; }
            obj = obj.children("a:eq(0)");
            var tmp = obj.children("I").clone();
            obj.html(val).prepend(tmp);
            this.trigger('set_text', { "obj": obj, "text": val });
            return true;
        },
        /**
		 * `parse_json()`
		 *
		 * __Parameters__
		 *
		 * * `node`
		 *
		 * __Returns__
		 *
		 */
        parse_json: function (node) {
            var li, a, ul, t;
            if (node === null || ($.isArray(node) && node.length === 0)) {
                return false;
            }
            if ($.isArray(node)) {
                ul = $("<ul />");
                t = this;
                $.each(node, function (i, v) {
                    ul.append(t.parse_json(v));
                });
                return ul;
            }
            if (typeof node === "undefined") { node = {}; }
            if (typeof node === "string") { node = { "title": node }; }
            if (!node.li_attr) { node.li_attr = {}; }
            if (!node.a_attr) { node.a_attr = {}; }
            if (!node.a_attr.href) { node.a_attr.href = '#'; }
            if (!node.title) { node.title = this.get_string("New node"); }

            li = $("<li />").attr(node.li_attr);
            a = $("<a />").attr(node.a_attr).html(node.title);
            ul = $("<ul />");
            if (node.data && !$.isEmptyObject(node.data)) { li.data(node.data); }
            if (
				node.children === true ||
				$.isArray(node.children) ||
				(li.data('jstree') && $.isArray(li.data('jstree').children))
			) {
                if (!li.data('jstree')) {
                    li.data('jstree', {});
                }
                li.data('jstree').closed = true;
            }
            li.append(a);
            if ($.isArray(node.children)) {
                $.each(node.children, $.proxy(function (i, n) {
                    ul.append(this.parse_json(n));
                }, this));
                li.append(ul);
            }
            return li;
        },
        /**
		 * `get_json()`
		 *
		 * __Parameters__
		 *
		 * * `obj`
		 * * `is_callback`
		 *
		 * __Returns__
		 *
		 */
        get_json: function (obj, is_callback) {
            obj = typeof obj !== 'undefined' ? this.get_node(obj) : false;
            if (!is_callback) {
                if (!obj || obj === -1) { obj = this.get_container_ul().children("li"); }
            }
            var r, t, li_attr = {}, a_attr = {}, tmp = {}, i;
            if (!obj || !obj.length) { return false; }
            if (obj.length > 1 || !is_callback) {
                r = [];
                t = this;
                obj.each(function () {
                    r.push(t.get_json($(this), true));
                });
                return r;
            }
            tmp = $.vakata.attributes(obj, true);
            $.each(tmp, function (i, v) {
                if (i === 'id') { li_attr[i] = v; return true; }
                v = $.trim(v.replace(/\bjstree[^ ]*/ig, '').replace(/\s+$/ig, " "));
                if (v.length) { li_attr[i] = v; }
            });
            tmp = $.vakata.attributes(obj.children('.jstree-anchor'), true);
            $.each(tmp, function (i, v) {
                if (i === 'id') { a_attr[i] = v; return true; }
                v = $.trim(v.replace(/\bjstree[^ ]*/ig, '').replace(/\s+$/ig, " "));
                if (v.length) { a_attr[i] = v; }
            });
            r = {
                'title': this.get_text(obj),
                'data': $.extend(true, {}, obj.data() || {}),
                'children': false,
                'li_attr': li_attr,
                'a_attr': a_attr
            };

            if (!r.data.jstree) { r.data.jstree = {}; }
            if (this.is_open(obj)) { r.data.jstree.opened = true; }
            if (this.is_closed(obj)) { r.data.jstree.closed = true; }
            i = this.get_icon(obj);
            if (typeof i !== 'undefined' && i !== null) { r.data.jstree.icon = i; }
            if (this.is_selected(obj)) { r.data.jstree.selected = true; }

            obj = obj.children("ul").children("li");
            if (obj.length) {
                r.children = [];
                t = this;
                obj.each(function () {
                    r.children.push(t.get_json($(this), true));
                });
            }
            return r;
        },
        /**
		 * `create_node()`
		 *
		 * __Parameters__
		 *
		 * * `par`
		 * * `node`
		 * * `pos`
		 * * `callback`
		 * * `is_loaded`
		 *
		 * __Returns__
		 *
		 */
        create_node: function (par, node, pos, callback, is_loaded) {
            par = this.get_node(par);
            pos = typeof pos === "undefined" ? "last" : pos;

            if (par !== -1 && !par.length) { return false; }
            if (!pos.match(/^(before|after)$/) && !is_loaded && !this.is_loaded(par)) {
                return this.load_node(par, function () { this.create_node(par, node, pos, callback, true); });
            }

            var li = this.parse_json(node),
				tmp = par === -1 ? this.element : par;

            if (par === -1) {
                if (pos === "before") { pos = "first"; }
                if (pos === "after") { pos = "last"; }
            }
            switch (pos) {
                case "before":
                    pos = par.index();
                    par = this.get_parent(par);
                    break;
                case "after":
                    pos = par.index() + 1;
                    par = this.get_parent(par);
                    break;
                case "inside":
                case "first":
                    pos = 0;
                    break;
                case "last":
                    pos = tmp.children('ul').children('li').length;
                    break;
                default:
                    if (!pos) { pos = 0; }
                    break;
            }
            if (!this.check("create_node", li, par, pos)) { return false; }

            tmp = par === -1 ? this.element : par;
            if (!tmp.children("ul").length) { tmp.append("<ul />"); }
            if (tmp.children("ul").children("li").eq(pos).length) {
                tmp.children("ul").children("li").eq(pos).before(li);
            }
            else {
                tmp.children("ul").append(li);
            }
            this.correct_node(par, true);
            if (callback) { callback.call(this, li); }
            this.trigger('create_node', { "node": li, "parent": par, "position": li.index() });
            return li;
        },
        /**
		 * `rename_node()`
		 *
		 * __Parameters__
		 *
		 * * `obj`
		 * * `val`
		 *
		 * __Returns__
		 *
		 */
        rename_node: function (obj, val) {
            obj = this.get_node(obj);
            var old = this.get_text(obj);
            if (!this.check("rename_node", obj, this.get_parent(obj), val)) { return false; }
            if (obj && obj.length) {
                this.set_text(obj, val); // .apply(this, Array.prototype.slice.call(arguments))
                this.trigger('rename_node', { "node": obj, "title": val, "old": old });
            }
        },
        /**
		 * `delete_node()`
		 *
		 * __Parameters__
		 *
		 * * `obj`
		 *
		 * __Returns__
		 *
		 */
        delete_node: function (obj) {
            obj = this.get_node(obj);
            if (!obj || obj === -1 || !obj.length) { return false; }
            var par = this.get_parent(obj),
				pre = this.get_prev(obj);
            if (!this.check("delete_node", obj, par, obj.index())) { return false; }
            obj = obj.detach();
            this.correct_node(par);
            this.correct_node(pre);
            this.trigger('delete_node', { "node": obj, "prev": pre, "parent": par });

            var n = obj.find(".jstree-clicked"),
				t = this;
            if (n.length) {
                n.each(function () { t.deselect_node(this, true); });
                this.trigger('changed', { 'action': 'delete_node', 'node': obj, 'selected': this._data.core.selected, 'parent': par });
            }
            return obj;
        },
        /**
		 * `check()`
		 *
		 * __Parameters__
		 *
		 * * `chk`
		 * * `obj`
		 * * `par`
		 * * `pos`
		 *
		 * __Returns__
		 *
		 */
        check: function (chk, obj, par, pos) {
            var tmp = chk.match(/^move_node|copy_node|create_node$/i) ? par : obj,
				chc = this.settings.core.check_callback;
            if (chc === false || ($.isFunction(chc) && chc.call(this, chk, obj, par, pos) === false)) {
                return false;
            }
            tmp = tmp === -1 ? this.element.data('jstree') : tmp.data('jstree');
            if (tmp && tmp.functions && tmp.functions[chk]) {
                tmp = tmp.functions[chk];
                if ($.isFunction(tmp)) {
                    tmp = tmp.call(this, chk, obj, par, pos);
                }
                if (tmp === false) {
                    return false;
                }
            }
            switch (chk) {
                case "create_node":
                    break;
                case "rename_node":
                    break;
                case "move_node":
                    tmp = par === -1 ? this.element : par;
                    tmp = tmp.children('ul').children('li');
                    if (tmp.length && tmp.index(obj) !== -1 && (pos === obj.index() || pos === obj.index() + 1)) {
                        return false;
                    }
                    if (par !== -1 && par.parentsUntil('.jstree', 'li').addBack().index(obj) !== -1) {
                        return false;
                    }
                    break;
                case "copy_node":
                    break;
                case "delete_node":
                    break;
            }
            return true;
        },
        /**
		 * `move_node()`
		 *
		 * __Parameters__
		 *
		 * * `obj`
		 * * `par`
		 * * `pos`
		 * * `callback`
		 * * `is_loaded`
		 *
		 * __Returns__
		 *
		 */
        move_node: function (obj, par, pos, callback, is_loaded) {
            obj = this.get_node(obj);
            par = this.get_node(par);
            pos = typeof pos === "undefined" ? 0 : pos;

            if (!obj || obj === -1 || !obj.length) { return false; }
            if (par !== -1 && !par.length) { return false; }
            if (!pos.toString().match(/^(before|after)$/) && !is_loaded && !this.is_loaded(par)) {
                return this.load_node(par, function () { this.move_node(obj, par, pos, callback, true); });
            }

            var old_par = this.get_parent(obj),
				new_par = (!pos.toString().match(/^(before|after)$/) || par === -1) ? par : this.get_parent(par),
				old_ins = $.jstree.reference(obj),
				new_ins = par === -1 ? this : $.jstree.reference(par),
				is_multi = (old_ins._id !== new_ins._id);
            if (new_par === -1) {
                par = new_ins.get_container();
                if (pos === "before") { pos = "first"; }
                if (pos === "after") { pos = "last"; }
            }
            switch (pos) {
                case "before":
                    pos = par.index();
                    break;
                case "after":
                    pos = par.index() + 1;
                    break;
                case "inside":
                case "first":
                    pos = 0;
                    break;
                case "last":
                    pos = par.children('ul').children('li').length;
                    break;
                default:
                    if (!pos) { pos = 0; }
                    break;
            }
            if (!this.check("move_node", obj, new_par, pos)) { return false; }

            if (!par.children("ul").length) { par.append("<ul />"); }
            if (par.children("ul").children("li").eq(pos).length) {
                par.children("ul").children("li").eq(pos).before(obj);
            }
            else {
                par.children("ul").append(obj);
            }

            if (is_multi) { // if multitree - clean the node recursively - remove all icons, and call deep clean_node
                obj.find('.jstree-icon, .jstree-ocl').remove();
                this.clean_node(obj);
            }
            old_ins.correct_node(old_par, true);
            new_ins.correct_node(new_par, true);
            if (callback) { callback.call(this, obj, new_par, obj.index()); }
            this.trigger('move_node', { "node": obj, "parent": new_par, "position": obj.index(), "old_parent": old_par, "is_multi": is_multi, 'old_instance': old_ins, 'new_instance': new_ins });
            return true;
        },
        /**
		 * `copy_node()`
		 *
		 * __Parameters__
		 *
		 * * `obj`
		 * * `par`
		 * * `pos`
		 * * `callback`
		 * * `is_loaded`
		 *
		 * __Returns__
		 *
		 */
        copy_node: function (obj, par, pos, callback, is_loaded) {
            obj = this.get_node(obj);
            par = this.get_node(par);
            pos = typeof pos === "undefined" ? "last" : pos;

            if (!obj || obj === -1 || !obj.length) { return false; }
            if (par !== -1 && !par.length) { return false; }
            if (!pos.toString().match(/^(before|after)$/) && !is_loaded && !this.is_loaded(par)) {
                return this.load_node(par, function () { this.copy_node(obj, par, pos, callback, true); });
            }
            var org_obj = obj,
				old_par = this.get_parent(obj),
				new_par = (!pos.toString().match(/^(before|after)$/) || par === -1) ? par : this.get_parent(par),
				old_ins = $.jstree.reference(obj),
				new_ins = par === -1 ? this : $.jstree.reference(par),
				is_multi = (old_ins._id !== new_ins._id);

            obj = obj.clone(true);
            obj.find("*[id]").addBack().each(function () {
                if (this.id) { this.id = "copy_" + this.id; }
            });
            if (new_par === -1) {
                par = new_ins.get_container();
                if (pos === "before") { pos = "first"; }
                if (pos === "after") { pos = "last"; }
            }
            switch (pos) {
                case "before":
                    pos = par.index();
                    break;
                case "after":
                    pos = par.index() + 1;
                    break;
                case "inside":
                case "first":
                    pos = 0;
                    break;
                case "last":
                    pos = par.children('ul').children('li').length;
                    break;
                default:
                    if (!pos) { pos = 0; }
                    break;
            }

            if (!this.check("copy_node", org_obj, new_par, pos)) { return false; }

            if (!par.children("ul").length) { par.append("<ul />"); }
            if (par.children("ul").children("li").eq(pos).length) {
                par.children("ul").children("li").eq(pos).before(obj);
            }
            else {
                par.children("ul").append(obj);
            }
            if (is_multi) { // if multitree - clean the node recursively - remove all icons, and call deep clean_node
                obj.find('.jstree-icon, .jstree-ocl').remove();
            }
            new_ins.clean_node(obj); // always clean so that selected states, etc. are removed
            new_ins.correct_node(new_par, true); // no need to correct the old parent, as nothing has changed there
            if (callback) { callback.call(this, obj, new_par, obj.index(), org_obj); }
            this.trigger('copy_node', { "node": obj, "parent": new_par, "old_parent": old_par, "position": obj.index(), "original": org_obj, "is_multi": is_multi, 'old_instance': old_ins, 'new_instance': new_ins });
            return true;
        },
        /**
		 * `cut()`
		 *
		 * __Parameters__
		 *
		 * * `obj`
		 *
		 * __Returns__
		 *
		 */
        cut: function (obj) {
            obj = this.get_node(obj);
            if (!obj || obj === -1 || !obj.length) { return false; }
            ccp_node = obj;
            ccp_mode = 'move_node';
            this.trigger('cut', { "node": obj });
        },
        /**
		 * `copy()`
		 *
		 * __Parameters__
		 *
		 * * `obj`
		 *
		 * __Returns__
		 *
		 */
        copy: function (obj) {
            obj = this.get_node(obj);
            if (!obj || obj === -1 || !obj.length) { return false; }
            ccp_node = obj;
            ccp_mode = 'copy_node';
            this.trigger('copy', { "node": obj });
        },
        /**
		 * `get_buffer()`
		 *
		 * __Returns__
		 *
		 */
        get_buffer: function () {
            return { 'mode': ccp_mode, 'node': ccp_node };
        },
        /**
		 * `can_paste()`
		 *
		 * __Returns__
		 *
		 */
        can_paste: function () {
            return ccp_mode !== false && ccp_node !== false;
        },
        /**
		 * `paste()`
		 *
		 * __Parameters__
		 *
		 * * `obj`
		 *
		 * __Returns__
		 *
		 */
        paste: function (obj) {
            obj = this.get_node(obj);
            if (!obj || !ccp_mode || !ccp_mode.match(/^(copy_node|move_node)$/) || !ccp_node) { return false; }
            this[ccp_mode](ccp_node, obj);
            this.trigger('paste', { "obj": obj, "nodes": ccp_node, "mode": ccp_mode });
            ccp_node = false;
            ccp_mode = false;
        },
        /**
		 * `edit()`
		 *
		 * __Parameters__
		 *
		 * * `obj`
		 * * `default_text`
		 *
		 * __Returns__
		 *
		 */
        edit: function (obj, default_text) {
            obj = this.get_node(obj);
            if (!obj || obj === -1 || !obj.length) { return false; }
            obj.parentsUntil(".jstree", ".jstree-closed").each($.proxy(function (i, v) {
                this.open_node(v, false, 0);
            }, this));
            var rtl = this._data.core.rtl,
				w = this.element.width(),
				a = obj.children('a:eq(0)'),
				oi = obj.children("i"),
				ai = a.children("i"),
				w1 = oi.width() * oi.length,
				w2 = ai.width() * ai.length,
				t = typeof default_text === 'string' ? default_text : this.get_text(obj),
				h1 = $("<" + "div />", { css: { "position": "absolute", "top": "-200px", "left": (rtl ? "0px" : "-1000px"), "visibility": "hidden" } }).appendTo("body"),
				h2 = obj.css("position", "relative").append(
					$("<" + "input />", {
					    "value": t,
					    "class": "jstree-rename-input",
					    // "size" : t.length,
					    "css": {
					        "padding": "0",
					        "border": "1px solid silver",
					        "position": "absolute",
					        "left": (rtl ? "auto" : (w1 + w2 + 4) + "px"),
					        "right": (rtl ? (w1 + w2 + 4) + "px" : "auto"),
					        "top": "0px",
					        "height": (this._data.core.li_height - 2) + "px",
					        "lineHeight": (this._data.core.li_height - 2) + "px",
					        "width": "150px" // will be set a bit further down
					    },
					    "blur": $.proxy(function () {
					        var i = obj.children(".jstree-rename-input"),
								v = i.val();
					        if (v === "") { v = t; }
					        h1.remove();
					        i.remove();
					        if (this.rename_node(obj, v) === false) {
					            this.rename_node(obj, t);
					        }
					        obj.css("position", "");
					    }, this),
					    "keydown": function (event) {
					        var key = event.keyCode || event.which;
					        if (key === 27) {
					            this.value = t;
					        }
					        if (key === 27 || key === 13 || key === 37 || key === 38 || key === 39 || key === 40) {
					            event.stopImmediatePropagation();
					        }
					        if (key === 27 || key === 13) {
					            event.preventDefault();
					            this.blur();
					        }
					    },
					    "keyup": function (event) {
					        var key = event.keyCode || event.which;
					        h2.width(Math.min(h1.text("pW" + this.value).width(), w));
					    },
					    "keypress": function (event) {
					        var key = event.keyCode || event.which;
					        if (key === 13) { return false; }
					    }
					})
				).children(".jstree-rename-input"),
				fn = {
				    fontFamily: a.css('fontFamily') || '',
				    fontSize: a.css('fontSize') || '',
				    fontWeight: a.css('fontWeight') || '',
				    fontStyle: a.css('fontStyle') || '',
				    fontStretch: a.css('fontStretch') || '',
				    fontVariant: a.css('fontVariant') || '',
				    letterSpacing: a.css('letterSpacing') || '',
				    wordSpacing: a.css('wordSpacing') || ''
				};
            this.set_text(obj, "");
            h1.css(fn);
            h2.css(fn).width(Math.min(h1.text("pW" + h2[0].value).width(), w))[0].select();
        },
        /**
		 * `set_theme()`
		 *
		 * __Parameters__
		 *
		 * * `theme_name`
		 * * `theme_url`
		 *
		 * __Returns__
		 *
		 */
        set_theme: function (theme_name, theme_url) {
            //if (!theme_name) { return false; }
            //if (theme_url === true) {
            //    var dir = this.settings.core.themes.dir;
            //    if (!dir) { dir = $.jstree.path + '/themes'; }
            //    theme_url = dir + '/' + theme_name + '/style.css';
            //}
            //if (theme_url && $.inArray(theme_url, themes_loaded) === -1) {
            //    $('head').append('<' + 'link rel="stylesheet" href="' + theme_url + '" type="text/css" />');
            //    themes_loaded.push(theme_url);
            //}
            //if (this._data.core.themes.name) {
            //    this.element.removeClass('jstree-' + this._data.core.themes.name);
            //}
            //this._data.core.themes.name = theme_name;
            //this.element.addClass('jstree-' + theme_name);
            //this.trigger('set_theme', { 'theme': theme_name });
        },
        /**
		 * `get_theme()`
		 *
		 * __Returns__
		 *
		 */
        get_theme: function () { return this._data.core.themes.name; },
        /**
		 * `show_dots()`
		 */
        show_dots: function () { this._data.core.themes.dots = true; this.element.children("ul").removeClass("jstree-no-dots"); },
        /**
		 * `hide_dots()`
		 */
        hide_dots: function () { this._data.core.themes.dots = false; this.element.children("ul").addClass("jstree-no-dots"); },
        /**
		 * `toggle_dots()`
		 */
        toggle_dots: function () { if (this._data.core.themes.dots) { this.hide_dots(); } else { this.show_dots(); } },
        /**
		 * `show_icons()`
		 */
        show_icons: function () { this._data.core.themes.icons = true; this.element.children("ul").removeClass("jstree-no-icons"); },
        /**
		 * `hide_icons()`
		 */
        hide_icons: function () { this._data.core.themes.icons = false; this.element.children("ul").addClass("jstree-no-icons"); },
        /**
		 * `toggle_icons()`
		 */
        toggle_icons: function () { if (this._data.core.themes.icons) { this.hide_icons(); } else { this.show_icons(); } },
        /**
		 * `set_icon()`
		 *
		 * __Parameters__
		 *
		 * * `obj`
		 * * `icon`
		 *
		 * __Returns__
		 *
		 */
        set_icon: function (obj, icon) {
            obj = this.get_node(obj);
            if (!obj || obj === -1 || !obj.length) { return false; }
            obj = obj.children("a").children(".jstree-themeicon");
            if (icon === false) {
                this.hide_icon(obj);
            }
            else if (icon.indexOf("/") === -1) {
                obj.addClass(icon).attr("rel", icon);
            }
            else {
                obj.css("background", "url('" + icon + "') center center no-repeat").attr("rel", icon);
            }
            return true;
        },
        /**
		 * `get_icon()`
		 *
		 * __Parameters__
		 *
		 * * `obj`
		 *
		 * __Returns__
		 *
		 */
        get_icon: function (obj) {
            obj = this.get_node(obj);
            if (!obj || obj === -1 || !obj.length) { return null; }
            obj = obj.children("a").children(".jstree-themeicon");
            if (obj.hasClass('jstree-themeicon-hidden')) { return false; }
            obj = obj.attr("rel");
            return (obj && obj.length) ? obj : null;
        },
        /**
		 * `hide_icon()`
		 *
		 * __Parameters__
		 *
		 * * `obj`
		 *
		 * __Returns__
		 *
		 */
        hide_icon: function (obj) {
            obj = this.get_node(obj);
            if (!obj || obj === -1 || !obj.length) { return false; }
            obj.children("a").children(".jstree-themeicon").addClass('jstree-themeicon-hidden');
            return true;
        },
        /**
		 * `show_icon()`
		 *
		 * __Parameters__
		 *
		 * * `obj`
		 *
		 * __Returns__
		 *
		 */
        show_icon: function (obj) {
            obj = this.get_node(obj);
            if (!obj || obj === -1 || !obj.length) { return false; }
            obj.children("a").children(".jstree-themeicon").removeClass('jstree-themeicon-hidden');
            return true;
        }
    };

    var src = $('script:last').attr('src');
    $.jstree.path = src ? src.replace(/\/[^\/]+$/, '') : '';
    $.jstree.no_css = src && src.indexOf('?no_css') !== -1;

    if ($.jstree.no_css) {
        $.jstree.defaults.core.themes.url = false;
    }

    // base CSS
    $(function () {
        var css_string = '' +
				//'.jstree * { -webkit-box-sizing:content-box; -moz-box-sizing:content-box; box-sizing:content-box; }' +
				'.jstree ul, .jstree li { display:block; margin:0 0 0 0; padding:0 0 0 0; list-style-type:none; list-style-image:none; } ' +
				'.jstree li { display:block; } ' + // min-height:18px; line-height:18px; white-space:nowrap; margin-left:18px; min-width:18px; 
				'.jstree-rtl li { margin-left:0; margin-right:18px; } ' +
				'.jstree > ul > li { margin-left:0px; } ' +
				'.jstree-rtl > ul > li { margin-right:0px; } ' +
				'.jstree .jstree-icon {text-decoration:none; margin:0; padding:0; vertical-align:top; } ' +  // display:inline-block; 
				'.jstree .jstree-ocl { width:18px; height:18px; text-align:center; line-height:18px; cursor:pointer; vertical-align:top; } ' +
				'.jstree li.jstree-open > ul { display:block; } ' +
				'.jstree li.jstree-closed > ul { display:none; } ' +
				'.jstree-anchor {line-height:16px; color:black; padding:1px 4px 1px 2px; margin:0; text-decoration:none; outline:0; } ' +  // display:inline-block;  white-space:nowrap; height:16px;
				'.jstree-anchor > .jstree-themeicon { display: none; height:16px; width:16px; margin-right:3px; } ' +
				'.jstree-rtl .jstree-anchor { padding:1px 2px 1px 4px; } ' +
				'.jstree-rtl .jstree-anchor > .jstree-themeicon { margin-left:3px; margin-right:0; } ' +
				'.jstree-no-icons .jstree-themeicon, .jstree-anchor > .jstree-themeicon-hidden { display:none; } ';
        if (!$.jstree.no_css) {
            $('head').append('<' + 'style type="text/css">' + css_string + '<' + '/style>');
        }
    });

    // helpers
    $.vakata = {};
    // collect attributes
    $.vakata.attributes = function (node, with_values) {
        node = $(node)[0];
        var attr = with_values ? {} : [];
        $.each(node.attributes, function (i, v) {
            if ($.inArray(v.nodeName.toLowerCase(), ['style', 'contenteditable', 'hasfocus', 'tabindex']) !== -1) { return; }
            if (v.nodeValue !== null && $.trim(v.nodeValue) !== '') {
                if (with_values) { attr[v.nodeName] = v.nodeValue; }
                else { attr.push(v.nodeName); }
            }
        });
        return attr;
    };
    // remove item from array
    $.vakata.array_remove = function (array, from, to) {
        var rest = array.slice((to || from) + 1 || array.length);
        array.length = from < 0 ? array.length + from : from;
        array.push.apply(array, rest);
        return array;
    };
    // private function for json quoting strings
    var _quote = function (str) {
        var escapeable = /["\\\x00-\x1f\x7f-\x9f]/g,
			meta = { '\b': '\\b', '\t': '\\t', '\n': '\\n', '\f': '\\f', '\r': '\\r', '"': '\\"', '\\': '\\\\' };
        if (str.match(escapeable)) {
            return '"' + str.replace(escapeable, function (a) {
                var c = meta[a];
                if (typeof c === 'string') { return c; }
                c = a.charCodeAt();
                return '\\u00' + Math.floor(c / 16).toString(16) + (c % 16).toString(16);
            }) + '"';
        }
        return '"' + str + '"';
    };
    $.vakata.json = {
        encode: function (o) {
            if (o === null) { return "null"; }

            var tmp = [], i;
            switch (typeof (o)) {
                case "undefined":
                    return undefined;
                case "number":
                case "boolean":
                    return o + "";
                case "string":
                    return _quote(o);
                case "object":
                    if ($.isFunction(o.toJSON)) {
                        return $.vakata.json.encode(o.toJSON());
                    }
                    if (o.constructor === Date) {
                        return '"' +
							o.getUTCFullYear() + '-' +
							String("0" + (o.getUTCMonth() + 1)).slice(-2) + '-' +
							String("0" + o.getUTCDate()).slice(-2) + 'T' +
							String("0" + o.getUTCHours()).slice(-2) + ':' +
							String("0" + o.getUTCMinutes()).slice(-2) + ':' +
							String("0" + o.getUTCSeconds()).slice(-2) + '.' +
							String("00" + o.getUTCMilliseconds()).slice(-3) + 'Z"';
                    }
                    if (o.constructor === Array) {
                        for (i = 0; i < o.length; i++) {
                            tmp.push($.vakata.json.encode(o[i]) || "null");
                        }
                        return "[" + tmp.join(",") + "]";
                    }

                    $.each(o, function (i, v) {
                        if ($.isFunction(v)) { return true; }
                        i = typeof i === "number" ? '"' + i + '"' : _quote(i);
                        v = $.vakata.json.encode(v);
                        tmp.push(i + ":" + v);
                    });
                    return "{" + tmp.join(", ") + "}";
            }
        },
        decode: function (json) {
            return $.parseJSON(json);
        }
    };

})(jQuery);/**
 * ## jsTree 2.0.0-alpha ##
 * http://jstree.com/
 *
 * Copyright (c) 2013 Ivan Bozhanov (http://vakata.com)
 *
 * Licensed same as jquery - under the terms of the MIT License
 *   http://www.opensource.org/licenses/mit-license.php
 *
 */
(function ($) {
    "use strict";

    // prevent another load? maybe there is a better way?
    if ($.jstree) {
        return;
    }

    // internal variables
    var instance_counter = 0,
		ccp_node = false,
		ccp_mode = false,
		themes_loaded = [];

    /**
	 * ### Static $.jstree object
	 *
	 * `$.jstree` holds all jstree related functions and variables
	 *
	 * * `version` the jstree version in use
	 * * `plugins` stores all loaded jstree plugins
	 * * `defaults` holds the core & plugin's defaults
	 *
	 */
    $.jstree = {
        version: '2.0.0-alpha',
        defaults: {
            plugins: []
        },
        plugins: {}
    };
    /**
	 * `$.jstree.create()` creates a jstree instance
	 *
	 * __Parameters__
	 *
	 * * `el` - the element to create the instance in
	 * * `options` - options for the instance, extends `$.jstree.defaults`
	 *
	 * __Returns__
	 * the new jstree instance
	 */
    $.jstree.create = function (el, options) {
        var tmp = new $.jstree.core(++instance_counter),
			opt = options;
        options = $.extend(true, {}, $.jstree.defaults, options);
        if (opt && opt.plugins) {
            options.plugins = opt.plugins;
        }
        $.each(options.plugins, function (i, k) {
            if (i !== 'core') {
                tmp = tmp.plugin(k, options[k]);
            }
        });
        tmp.init(el, options);
        return tmp;
    };
    /**
	 * `$.jstree.core()` the actual empty class.
	 *
	 * Used internally -  to create an instance use either:
	 *
	 * * `$.jstree.create(element, options)` or
	 * * `$(selector).jstree(options)`
	 *
	 * __Parameters__
	 *
	 * * `id` - the instance index - passed internally
	 */
    $.jstree.core = function (id) {
        this._id = id;
        this._data = {
            'core': {
                'themes': {}
            }
        };
    };
    /**
	 * `$.jstree.reference()` get an instance by some selector.
	 *
	 * __Parameters__
	 *
	 * * `needle` - a DOM element / jQuery object to search by.
	 */
    $.jstree.reference = function (needle) {
        return $(needle).closest('.jstree').data('jstree');
    };
    /**
	 * ### jQuery $().jstree method
	 *
	 * `$(selector).jstree()` is used to create an instance on the selector or to invoke a command on a instance. `Uses $.jstree.create()` internally.
	 *
	 * __Examples__
	 *
	 *	$('#container').jstree();
	 *	$('#container').jstree({ option : value });
	 *	$('#container').jstree('open_node', '#branch_1');
	 *
	 */
    $.fn.jstree = function (arg) {
        // check for string argument
        var is_method = (typeof arg === 'string'),
			args = Array.prototype.slice.call(arguments, 1),
			result = null;
        this.each(function () {
            // get the instance (if there is one) and method (if it exists)
            var instance = $(this).data('jstree'),
				method = is_method && instance ? instance[arg] : null;
            // if calling a method, and method is available - execute on the instance
            result = is_method && method ?
				method.apply(instance, args) :
				null;
            // if there is no instance - create one
            if (!instance) {
                $(this).data('jstree', new $.jstree.create(this, arg));
            }
            // if there was a method call which returned a result - break and return the value
            if (result !== null && typeof result !== 'undefined') {
                return false;
            }
        });
        // if there was a method call with a valid return value - return that, otherwise continue the chain
        return result !== null && typeof result !== 'undefined' ?
            result : this;
    };
    /**
	 * ### jQuery :jstree pseudo selector
	 *
	 * `$(':jstree')` is used to find elements containing an instance
	 *
	 * __Examples__
	 *
	 *	$('div:jstree').each(function () {
	 *		$(this).jstree('destroy');
	 *	});
	 *
	 */
    $.expr[':'].jstree = $.expr.createPseudo(function (search) {
        return function (a) {
            return $(a).hasClass('jstree') &&
				typeof ($(a).data('jstree')) !== 'undefined';
        };
    });

    /**
	 * ### jsTree core settings
	 *
	 * `$.jstree.defaults.core` stores all defaults for the core.
	 *
	 * * `string` should be an object or a function:
	 *
	 *		// object
	 *		{
	 *			'Loading ...' : ' ...'
	 *			...
	 *		}
	 *
	 *		// function
	 *		function (key) {
	 *			switch(key) {
	 *				case 'Loading ...':
	 *					return ' ...';
	 *			...
	 *		}
	 *
	 *	This setting is handled in the `get_string()` function, if no match is found, the key itself is used.
	 *
	 * * `check_callback` should either be a boolean or a function:
	 */
    $.jstree.defaults.core = {
        strings: false,
        check_callback: true,
        animation: 100,
        aria_roles: false,
        multiple: true,
        themes: {
            name: false,
            url: true,
            dots: true,
            icons: true,
            dir: false
        },
        base_height: false,
        clean_loaded: true,
        correct_loaded: true,
        expand_selected_onload: true
    };

    /**
	 * ### jsTree core methods
	 */
    $.jstree.core.prototype = {
        /**
		 * `plugin()` is used to decorate an instance with a plugin. Used internally in `$.jstree.create()`.
		 *
		 * __Parameters__
		 *
		 * * `deco` - the plugin to activate on the instance
		 * * `options` - options for the plugin
		 *
		 * __Returns__
		 * the decorated jstree instance
		 *
		 * _Plugin authors are better off reading the options from `this.settings.{plugin_name}` in the `.bind()` or `init()` function of their plugins._
		 */
        plugin: function (deco, opts) {
            var Child = $.jstree.plugins[deco];
            if (Child) {
                this._data[deco] = {};
                Child.prototype = this;
                return new Child(opts, this);
            }
            return this;
        },
        /**
		 * `init()`
		 *
		 * __Parameters__
		 *
		 * * `par`
		 *
		 * __Returns__
		 *
		 */
        init: function (el, options) {
            this.element = $(el).addClass('jstree jstree-' + this._id);
            this.settings = options;
            this.element.bind("destroyed", $.proxy(this.teardown, this));

            this._data.core.ready = false;
            this._data.core.loaded = false;
            this._data.core.rtl = (this.element.css("direction") === "rtl");
            this.element[this._data.core.rtl ? 'addClass' : 'removeClass']("jstree-rtl");
            if (this.settings.core.aria_roles) {
                this.element.attr('role', 'tree');
            }
            this._data.core.selected = $();

            this.bind();
            this.trigger("init");

            this._data.core.original_container_html = this.element.find(" > ul > li").clone(true);
            this._data.core.original_container_html
				.find("li").addBack()
				.contents().filter(function () {
				    return this.nodeType === 3 && (!this.nodeValue || /^\s+$/.test(this.nodeValue));
				})
				.remove();
            this.element.html("<" + "ul><" + "li class='jstree-loading jstree-leaf jstree-last'><i class='jstree-icon jstree-ocl'></i><" + "a class='jstree-anchor' href='#'>" + this.get_string("Loading ...") + "</a></li></ul>");
            this._data.core.li_height = this.settings.base_height || this.get_container_ul().children("li:eq(0)").height() || 18;
            this.load_node(-1);
        },
        /**
		 * `destroy()`
		 */
        destroy: function () {
            this.element.unbind("destroyed", this.teardown);
            this.teardown();
        },
        /**
		 * `teardown()`
		 */
        teardown: function () {
            this.unbind();
            this.element
				.removeClass('jstree')
				.removeData('jstree')
				.find("[class^='jstree']")
					.addBack()
					.attr("class", function () { return this.className.replace(/jstree[^ ]*|$/ig, ''); });
            this.element = null;
        },
        /**
		 * `bind()`
		 */
        bind: function () {
            if ($.support.touch) {
                this.element.addTouch();
            }
            this.element
				.on("dblclick.jstree", function () {
				    if (document.selection && document.selection.empty) {
				        document.selection.empty();
				    }
				    else {
				        if (window.getSelection) {
				            var sel = window.getSelection();
				            try {
				                sel.removeAllRanges();
				                sel.collapse();
				            } catch (er) { }
				        }
				    }
				})
				.on("click.jstree", ".jstree-ocl", $.proxy(function (e) {
				    this.toggle_node(e.target);
				}, this))
				.on("click.jstree", ".jstree-anchor", $.proxy(function (e) {
				    // removed to allow clicking through of links
				    // e.preventDefault();
				    this.activate_node(e.currentTarget, e);
				}, this))
				.on('keydown.jstree', '.jstree-anchor', $.proxy(function (e) {
				    var o = null;
				    switch (e.which) {
				        case 13:
				        case 32:
				            e.type = "click";
				            $(e.currentTarget).trigger(e);
				            break;
				        case 37:
				            e.preventDefault();
				            if (this.is_open(e.currentTarget)) {
				                this.close_node(e.currentTarget);
				            }
				            else {
				                o = this.get_prev(e.currentTarget);
				                if (o && o.length) { o.children('.jstree-anchor').focus(); }
				            }
				            break;
				        case 38:
				            e.preventDefault();
				            o = this.get_prev(e.currentTarget);
				            if (o && o.length) { o.children('.jstree-anchor').focus(); }
				            break;
				        case 39:
				            e.preventDefault();
				            if (this.is_closed(e.currentTarget)) {
				                this.open_node(e.currentTarget);
				            }
				            else {
				                o = this.get_next(e.currentTarget);
				                if (o && o.length) { o.children('.jstree-anchor').focus(); }
				            }
				            break;
				        case 40:
				            e.preventDefault();
				            o = this.get_next(e.currentTarget);
				            if (o && o.length) { o.children('.jstree-anchor').focus(); }
				            break;
				        default:
				            //console.log(e.which);
				            break;
				    }
				}, this))
				.on("create_node.jstree", $.proxy(function (e, data) {
				    this.clean_node(data.node);
				}, this))
				.on("load_node.jstree", $.proxy(function (e, data) {
				    if (data.status) {
				        if (this.settings.core.clean_loaded) {
				            if (data.node === -1) {
				                // only detach for root (checkbox three-state will not work otherwise)
				                // also - if you could use async clean_node won't be such an issue
				                var ul = this.get_container_ul().detach();
				                if (ul.children('li').length) {
				                    this.clean_node(ul.children('li'));
				                }
				                this.element.prepend(ul);
				            }
				            else {
				                var s = this._data.core.selected.length;
				                if (data.node.children("ul").children("li").length) {
				                    this.clean_node(data.node.children("ul").children("li"));
				                }
				                if (this._data.core.ready && s !== this._data.core.selected.length) {
				                    this.trigger('changed', { 'action': 'clean_node', 'selected': this._data.core.selected });
				                }
				            }
				        }
				        if (data.node === -1 && !this._data.core.loaded) {
				            this._data.core.loaded = true;
				            this.trigger("loaded");
				        }
				        if (!this._data.core.ready && !this.get_container_ul().find('.jstree-loading:eq(0)').length) {
				            this._data.core.ready = true;
				            if (this._data.core.selected.length) {
				                if (this.settings.core.expand_selected_onload) {
				                    this._data.core.selected.parents(".jstree-closed").each($.proxy(function (i, v) { this.open_node(v, false, 0); }, this));
				                }
				                this.trigger('changed', { 'action': 'ready', 'selected': this._data.core.selected });
				            }
				            this.trigger("ready");
				        }
				    }
				}, this))
				.on("loaded.jstree", $.proxy(function (e, data) {
				    if (this.settings.core.correct_loaded) {
				        data.instance.get_container_ul().children('li').each(function () {
				            data.instance.correct_node(this);
				        });
				    }
				}, this))
				.on("open_node.jstree", $.proxy(function (e, data) {
				    if (this.settings.core.correct_loaded) {
				        data.node.children('li').each(function () {
				            data.instance.correct_node(this);
				        });
				    }
				}, this))
				// THEME RELATED
				.on("init.jstree", $.proxy(function () {
				    var s = this.settings.core.themes;
				    this._data.core.themes.dots = s.dots;
				    this._data.core.themes.icons = s.icons;

				    if (s.name === false) {
				        s.name = 'default';
				    }
				    this.set_theme(s.name, s.url);
				}, this))
				.on('loaded.jstree', $.proxy(function () {
				    this[this._data.core.themes.dots ? "show_dots" : "hide_dots"]();
				    this[this._data.core.themes.icons ? "show_icons" : "hide_icons"]();
				}, this))
				.on('focus.jstree', '.jstree-anchor', $.proxy(function (e) {
				    $(e.currentTarget).mouseenter();
				}, this))
				.on('blur.jstree', '.jstree-anchor', $.proxy(function (e) {
				    $(e.currentTarget).mouseleave();
				}, this))
				.on('mouseenter.jstree', '.jstree-anchor', $.proxy(function (e) {
				    var o = this.element.find('.jstree-anchor:focus').not('.jstree-clicked');
				    if (o && o.length && o[0] !== e.currentTarget) {
				        o.blur();
				    }
				    this.hover_node(e.currentTarget);
				}, this))
				.on('mouseleave.jstree', '.jstree-anchor', $.proxy(function (e) {
				    this.dehover_node(e.currentTarget);
				}, this));
        },
        /**
		 * `unbind()`
		 */
        unbind: function () {
            this.element.off('.jstree');
            $(document).off('.jstree-' + this._id);
        },
        /**
		 * `trigger()`
		 *
		 * __Parameters__
		 *
		 * * `ev`
		 * * `data`
		 */
        trigger: function (ev, data, wait) {
            if (!data) {
                data = {};
            }
            data.instance = this;
            if ((typeof wait).toLowerCase() === 'number') {
                setTimeout($.proxy(function () {
                    this.element.triggerHandler(ev.replace('.jstree', '') + '.jstree', data);
                }, this), wait);
            }
            else {
                this.element.triggerHandler(ev.replace('.jstree', '') + '.jstree', data);
            }
        },
        /**
		 * `get_container()`
		 *
		 * __Returns__
		 *
		 */
        get_container: function () {
            return this.element;
        },
        /**
		 * `get_container_ul()`
		 *
		 * __Returns__
		 *
		 */
        get_container_ul: function () {
            return this.element.children("ul:eq(0)");
        },
        /**
		 * `get_string()`
		 *
		 * __Parameters__
		 *
		 * * `key`
		 *
		 * __Returns__
		 *
		 */
        get_string: function (key) {
            var a = this.settings.core.strings;
            if ($.isFunction(a)) { return a.call(this, key); }
            if (a && a[key]) { return a[key]; }
            return key;
        },

        _firstChild: function (dom) {
            dom = dom ? dom.firstChild : null;
            while (dom !== null && dom.nodeType !== 1) {
                dom = dom.nextSibling;
            }
            return dom;
        },
        _nextSibling: function (dom) {
            dom = dom ? dom.nextSibling : null;
            while (dom !== null && dom.nodeType !== 1) {
                dom = dom.nextSibling;
            }
            return dom;
        },
        _previousSibling: function (dom) {
            dom = dom ? dom.previousSibling : null;
            while (dom !== null && dom.nodeType !== 1) {
                dom = dom.previousSibling;
            }
            return dom;
        },
        /**
		 * `get_node()`
		 *
		 * __Parameters__
		 *
		 * * `obj`
		 *
		 * __Returns__
		 *
		 */
        get_node: function (obj) {
            if (obj === -1) {
                return -1;
            }
            obj = $(obj, this.element);
            if (obj.hasClass(".jstree")) {
                return -1;
            }
            obj = obj.closest("li", this.element);
            return obj.length ? obj : false;
        },
        /**
		 * `get_next()`
		 *
		 * __Parameters__
		 *
		 * * `obj`
		 * * `strict`
		 *
		 * __Returns__
		 *
		 */
        get_next: function (obj, strict) {
            var tmp;
            obj = this.get_node(obj);
            if (obj === -1) {
                tmp = this._firstChild(this.get_container_ul()[0]);
                return tmp ? $(tmp) : false;
            }
            if (!obj || !obj.length) {
                return false;
            }
            if (strict) {
                tmp = this._nextSibling(obj[0]);
                return tmp ? $(tmp) : false;
            }
            if (obj.hasClass("jstree-open")) {
                tmp = this._firstChild(obj.children('ul')[0]);
                return tmp ? $(tmp) : false;
            }
            else if ((tmp = this._nextSibling(obj[0]))) {
                return $(tmp);
            }
            else {
                return obj.parentsUntil(".jstree", "li").next("li").eq(0);
            }
        },
        /**
		 * `get_prev()`
		 *
		 * __Parameters__
		 *
		 * * `obj`
		 * * `strict`
		 *
		 * __Returns__
		 *
		 */
        get_prev: function (obj, strict) {
            var tmp;
            obj = this.get_node(obj);
            if (obj === -1) {
                tmp = this.get_container_ul()[0].lastChild;
                return tmp ? $(tmp) : false;
            }
            if (!obj || !obj.length) {
                return false;
            }
            if (strict) {
                tmp = this._previousSibling(obj[0]);
                return tmp ? $(tmp) : false;
            }
            if ((tmp = this._previousSibling(obj[0]))) {
                obj = $(tmp);
                while (obj.hasClass("jstree-open")) {
                    obj = obj.children("ul:eq(0)").children("li:last");
                }
                return obj;
            }
            else {
                tmp = obj[0].parentNode.parentNode;
                return tmp && tmp.tagName === 'LI' ? $(tmp) : false;
            }
        },
        /**
		 * `get_parent()`
		 *
		 * __Parameters__
		 *
		 * * `obj`
		 *
		 * __Returns__
		 *
		 */
        get_parent: function (obj) {
            obj = this.get_node(obj);
            if (obj === -1 || !obj || !obj.length) {
                return false;
            }
            var o = obj[0].parentNode.parentNode;

            return o.tagName === 'LI' ? $(o) : -1;
        },
        /**
		 * `get_children()`
		 *
		 * __Parameters__
		 *
		 * * `obj`
		 *
		 * __Returns__
		 *
		 */
        get_children: function (obj) {
            obj = this.get_node(obj);
            if (obj === -1) {
                return this.get_container_ul().children("li");
            }
            if (!obj || !obj.length) {
                return false;
            }
            return obj.children("ul").children("li");
        },
        /**
		 * `is_parent()`
		 *
		 * __Parameters__
		 *
		 * * `obj`
		 *
		 * __Returns__
		 *
		 */
        is_parent: function (obj) {
            obj = this.get_node(obj);
            return obj && obj !== -1 && (this._firstChild(obj.children("ul")[0]) || obj.hasClass("jstree-closed"));
        },
        /**
		 * `is_loaded()`
		 *
		 * __Parameters__
		 *
		 * * `obj`
		 *
		 * __Returns__
		 *
		 */
        is_loaded: function (obj) {
            obj = this.get_node(obj);
            return obj && ((obj === -1 && !this.element.children("ul").children("li.jstree-loading").length) || (obj !== -1 && !obj.hasClass('jstree-loading') && (this._firstChild(obj.children("ul")[0]) || obj.hasClass('jstree-leaf'))));
        },
        /**
		 * `is_loading()`
		 *
		 * __Parameters__
		 *
		 * * `obj`
		 *
		 * __Returns__
		 *
		 */
        is_loading: function (obj) {
            obj = this.get_node(obj);
            return obj && ((obj === -1 && this.element.children("ul").children("li.jstree-loading").length) || (obj !== -1 && obj.hasClass("jstree-loading")));
        },
        /**
		 * `is_open()`
		 *
		 * __Parameters__
		 *
		 * * `obj`
		 *
		 * __Returns__
		 *
		 */
        is_open: function (obj) {
            obj = this.get_node(obj);
            return obj && obj !== -1 && obj.hasClass("jstree-open");
        },
        /**
		 * `is_closed()`
		 *
		 * __Parameters__
		 *
		 * * `obj`
		 *
		 * __Returns__
		 *
		 */
        is_closed: function (obj) {
            obj = this.get_node(obj);
            return obj && obj !== -1 && obj.hasClass("jstree-closed");
        },
        /**
		 * `is_leaf()`
		 *
		 * __Parameters__
		 *
		 * * `obj`
		 *
		 * __Returns__
		 *
		 */
        is_leaf: function (obj) {
            obj = this.get_node(obj);
            return obj && obj !== -1 && obj.hasClass("jstree-leaf");
        },
        /**
		 * `load_node()`
		 *
		 * __Parameters__
		 *
		 * * `obj`
		 * * `callback`
		 *
		 * __Returns__
		 *
		 */
        load_node: function (obj, callback) {
            obj = this.get_node(obj);
            if (!obj) {
                callback.call(this, obj, false);
                return false;
            }
            // if(this.is_loading(obj)) { return true; }
            if (obj !== -1) {
                obj.addClass("jstree-loading");
            }
            this._load_node(obj, $.proxy(function (status) {
                if (obj !== -1) {
                    obj.removeClass("jstree-loading");
                }
                this.trigger('load_node', { "node": obj, "status": status });
                if (callback) {
                    callback.call(this, obj, status);
                }
            }, this));
            return true;
        },
        /**
		 * `_load_node()`
		 *
		 * __Parameters__
		 *
		 * * `obj`
		 * * `callback`
		 *
		 * __Returns__
		 *
		 */
        _load_node: function (obj, callback) {
            if (obj === -1) {
                this.get_container_ul().empty().append(this._data.core.original_container_html.clone(true));
                callback.call(this, true);
            }
            else {
                callback.call(this, false);
            }
        },
        /**
		 * `open_node()`
		 *
		 * __Parameters__
		 *
		 * * `obj`
		 * * `callback`
		 * * `animation`
		 *
		 * __Returns__
		 *
		 */
        open_node: function (obj, callback, animation) {
            obj = this.get_node(obj);
            if (obj === -1 || !obj || !obj.length) {
                return false;
            }
            animation = (typeof animation).toLowerCase() === "undefined" ? this.settings.core.animation : animation;
            if (!this.is_closed(obj)) {
                if (callback) {
                    callback.call(this, obj, false);
                }
                return false;
            }
            if (!this.is_loaded(obj)) { // TODO: is_loading?
                this.load_node(obj, function (o, ok) {
                    return ok ? this.open_node(o, callback, animation) : (callback ? callback.call(this, o, false) : false);
                });
            }
            else {
                var t = this;
                if (!animation) {
                    obj[0].className = obj[0].className.replace('jstree-closed', 'jstree-open');
                }
                else {
                    obj
						.children("ul").css("display", "none").end()
						.removeClass("jstree-closed").addClass("jstree-open")
						.children("ul").stop(true, true)
							.slideDown(animation, function () {
							    this.style.display = "";
							    t.trigger("after_open", { "node": obj });
							});
                }
                if (callback) {
                    callback.call(this, obj, true);
                }
                this.trigger('open_node', { "node": obj });
                if (!animation) {
                    this.trigger("after_open", { "node": obj });
                }
            }
        },
        /**
		 * `close_node()`
		 *
		 * __Parameters__
		 *
		 * * `obj`
		 * * `animation`
		 *
		 * __Returns__
		 *
		 */
        close_node: function (obj, animation) {
            obj = this.get_node(obj);
            if (!obj || !obj.length || !this.is_open(obj)) {
                return false;
            }
            animation = (typeof animation).toLowerCase() === "undefined" ? this.settings.core.animation : animation;
            var t = this;
            if (!animation) {
                obj[0].className = obj[0].className.replace('jstree-open', 'jstree-closed');
            }
            else {
                obj
					.children("ul").attr("style", "display:block !important").end()
					.removeClass("jstree-open").addClass("jstree-closed")
					.children("ul").stop(true, true).slideUp(animation, function () {
					    this.style.display = "";
					    t.trigger("after_close", { "node": obj });
					});
            }
            this.trigger('close_node', { "node": obj });
            if (!animation) {
                this.trigger("after_close", { "node": obj });
            }
        },
        /**
		 * `toggle_node()`
		 *
		 * __Parameters__
		 *
		 * * `obj`
		 *
		 * __Returns__
		 *
		 */
        toggle_node: function (obj) {
            if (this.is_closed(obj)) {
                return this.open_node(obj);
            }
            if (this.is_open(obj)) {
                return this.close_node(obj);
            }
        },
        /**
		 * `open_all()`
		 *
		 * __Parameters__
		 *
		 * * `obj`
		 * * `animation`
		 * * `original_obj`
		 *
		 * __Returns__
		 *
		 */
        open_all: function (obj, animation, original_obj) {
            obj = obj ? this.get_node(obj) : -1;
            obj = !obj || obj === -1 ? this.get_container_ul() : obj;
            original_obj = original_obj || obj;
            var _this = this;
            obj = this.is_closed(obj) ? obj.find('li.jstree-closed').addBack() : obj.find('li.jstree-closed');
            obj.each(function () {
                _this.open_node(
					this,
					_this.is_loaded(this) ?
						false :
						function (obj) { this.open_all(obj, animation, original_obj); },
					animation || 0
				);
            });
            if (original_obj.find('li.jstree-closed').length === 0) {
                this.trigger('open_all', { "node": original_obj });
            }
        },
        /**
		 * `close_all()`
		 *
		 * __Parameters__
		 *
		 * * `obj`
		 * * `animation`
		 *
		 * __Returns__
		 *
		 */
        close_all: function (obj, animation) {
            obj = obj ? this.get_node(obj) : -1;
            var $obj = !obj || obj === -1 ? this.get_container_ul() : obj,
				_this = this;
            $obj = this.is_open($obj) ? $obj.find('li.jstree-open').addBack() : $obj.find('li.jstree-open');
            $obj.each(function () { _this.close_node(this, animation || 0); });
            this.trigger('close_all', { "node": obj });
        },
        /**
		 * `is_disabled()`
		 *
		 * __Parameters__
		 *
		 * * `obj`
		 *
		 * __Returns__
		 *
		 */
        is_disabled: function (obj) {
            obj = this.get_node(obj);
            return obj && obj !== -1 && obj.children('.jstree-anchor').hasClass("jstree-disabled");
        },
        /**
		 * `enable_node()`
		 *
		 * __Parameters__
		 *
		 * * `obj`
		 *
		 * __Returns__
		 *
		 */
        enable_node: function (obj) {
            obj = this.get_node(obj);
            if (!obj || !obj.length) {
                return false;
            }
            obj.children('.jstree-anchor').removeClass('jstree-disabled');
            this.trigger('enable_node', { 'node': obj });
        },
        /**
		 * `disable_node()`
		 *
		 * __Parameters__
		 *
		 * * `obj`
		 *
		 * __Returns__
		 *
		 */
        disable_node: function (obj) {
            obj = this.get_node(obj);
            if (!obj || !obj.length) {
                return false;
            }
            obj.children('.jstree-anchor').addClass('jstree-disabled');
            this.trigger('disable_node', { 'node': obj });
        },
        /**
		 * `activate_node()`
		 *
		 * __Parameters__
		 *
		 * * `obj`
		 * * `e`
		 *
		 * __Returns__
		 *
		 */
        activate_node: function (obj, e) {
            if (this.is_disabled(obj)) {
                return false;
            }
            if (!this.settings.core.multiple || (!e.metaKey && !e.ctrlKey)) {
                this.deselect_all(true);
                this.select_node(obj);
            }
            else {
                if (!this.is_selected(obj)) {
                    this.select_node(obj);
                }
                else {
                    this.deselect_node(obj);
                }
            }
            this.trigger('activate_node', { 'node': obj });
        },
        /**
		 * `hover_node()`
		 *
		 * __Parameters__
		 *
		 * * `obj`
		 *
		 * __Returns__
		 *
		 */
        hover_node: function (obj) {
            obj = this.get_node(obj);
            if (!obj || !obj.length) {
                return false;
            }
            obj.children('.jstree-anchor').addClass('jstree-hovered');
            this.trigger('hover_node', { 'node': obj });
        },
        /**
		 * `dehover_node()`
		 *
		 * __Parameters__
		 *
		 * * `obj`
		 *
		 * __Returns__
		 *
		 */
        dehover_node: function (obj) {
            obj = this.get_node(obj);
            if (!obj || !obj.length) {
                return false;
            }
            obj.children('.jstree-anchor').removeClass('jstree-hovered');
            this.trigger('dehover_node', { 'node': obj });
        },
        /**
		 * `select_node()`
		 *
		 * __Parameters__
		 *
		 * * `obj`
		 * * `supress_event`
		 *
		 * __Returns__
		 *
		 */
        select_node: function (obj, supress_event, prevent_open) {
            obj = this.get_node(obj);
            if (!obj || !obj.length) {
                return false;
            }
            this._data.core.selected = this._data.core.selected.add(obj);
            this.element.find('.jstree-clicked').removeClass('jstree-clicked');
            this._data.core.selected.children('.jstree-anchor').addClass('jstree-clicked');

            if (!prevent_open) {
                var t = this;
                obj.parents(".jstree-closed").each(function () { t.open_node(this, false, 0); });
            }

            this.trigger('select_node', { 'node': obj, 'selected': this._data.core.selected });

            if (!supress_event) {
                this.trigger('changed', { 'action': 'select_node', 'node': obj, 'selected': this._data.core.selected });
            }
        },
        /**
		 * `deselect_node()`
		 *
		 * __Parameters__
		 *
		 * * `obj`
		 * * `supress_event`
		 *
		 * __Returns__
		 *
		 */
        deselect_node: function (obj, supress_event) {
            obj = this.get_node(obj);
            if (!obj || !obj.length) {
                return false;
            }
            this._data.core.selected = this._data.core.selected.not(obj);

            this.element.find('.jstree-clicked').removeClass('jstree-clicked');
            this._data.core.selected.children('.jstree-anchor').addClass('jstree-clicked');

            this.trigger('deselect_node', { 'node': obj, 'selected': this._data.core.selected });

            if (!supress_event) {
                this.trigger('changed', { 'action': 'deselect_node', 'node': obj, 'selected': this._data.core.selected });
            }
        },
        /**
		 * `deselect_all()`
		 *
		 * __Parameters__
		 *
		 * * `supress_event`
		 *
		 */
        deselect_all: function (supress_event) {
            this._data.core.selected = $();

            var obj = this.element.find('.jstree-clicked').removeClass('jstree-clicked');

            this.trigger('deselect_all', { 'selected': this._data.core.selected, 'node': obj });
            if (!supress_event) {
                this.trigger('changed', { 'action': 'deselect_all', 'selected': this._data.core.selected, 'node': obj });
            }
        },
        /**
		 * `is_selected()`
		 *
		 * __Parameters__
		 *
		 * * `obj`
		 *
		 * __Returns__
		 *
		 */
        is_selected: function (obj) {
            obj = this.get_node(obj);
            if (!obj || !obj.length) {
                return false;
            }
            return this._data.core.selected.index(obj) >= 0;
        },
        /**
		 * `get_selected()`
		 *
		 * __Returns__
		 *
		 */
        get_selected: function () {
            return this._data.core.selected;
        },
        /**
		 * `clean_node()`
		 *
		 * __Parameters__
		 *
		 * * `obj`
		 *
		 */
        clean_node: function (obj) {
            // DETACH maybe inside the "load_node" function? But what about animations, etc?
            obj = this.get_node(obj);
            obj = !obj || obj === -1 ? this.element.find("li") : obj.find("li").addBack();
            // test placing this here
            obj.find('li.jstree-clicked').removeClass('jstree-clicked');
            if (this.settings.core.aria_roles) {
                obj.attr('role', 'treeitem').parent().attr('role', 'group');
            }
            var _this = this;
            return obj.each(function () {
                var t = $(this),
					a = t.children('a'),
					d = t.data("jstree"),
					// is_ajax -> return this.settings.core.is_ajax || this._data.ajax;
					s = (d && d.opened) || t.hasClass("jstree-open") ? "open" : (d && (d.closed || d.children)) || t.children("ul").length ? "closed" : "leaf"; // replace with t.children("ul").children("li").length || (this.is_ajax() && !t.children('ul').length)
                if (d && d.opened) { delete d.opened; }
                if (d && d.closed) { delete d.closed; }
                t.removeClass("jstree-open jstree-closed jstree-leaf jstree-last");
                if (!a.length) {
                    // allow for text and HTML markup inside the nodes
                    t.contents().filter(function () { return this.nodeType === 3 || this.tagName !== 'UL'; }).wrapAll('<a href="#"></a>');
                    // TODO: make this faster
                    a = t.children('a');
                    a.html(t.children('a').html().replace(/[\s\t\n]+$/, ''));
                }
                else {
                    if (!$.trim(a.attr('href'))) { a.attr("href", "#"); }
                }
                a.addClass('jstree-anchor');
                if (!t.children("i.jstree-ocl").length) {
                    t.prepend("<i class='jstree-icon jstree-ocl'>&#160;</i>");
                }
                if (!t.next().length) {
                    t.addClass("jstree-last");
                }
                switch (s) {
                    case 'leaf':
                        t.addClass('jstree-leaf');
                        break;
                    case 'closed':
                        t.addClass('jstree-closed');
                        _this.close_node(t, 0);
                        break;
                    case 'open':
                        t.addClass('jstree-closed');
                        _this.open_node(t, false, 0);
                        break;
                }
                // theme part
                if (!a.children("i.jstree-themeicon").length) {
                    a.prepend("<i class='jstree-icon jstree-themeicon'>&#160;</i>");
                }
                if (d && typeof d.icon !== 'undefined') {
                    _this.set_icon(t, d.icon);
                    delete d.icon;
                }
                if (d && d.selected) {
                    _this.select_node(t, true, true);
                    delete d.selected;
                }
                if (d && d.disabled) {
                    _this.disable_node(t);
                    delete d.disabled;
                }
            });
        },
        /**
		 * `correct_node()`
		 *
		 * __Parameters__
		 *
		 * * `obj`
		 * * `deep`
		 *
		 * __Returns__
		 *
		 */
        correct_node: function (obj, deep) {
            obj = this.get_node(obj);
            if (!obj || (obj === -1 && !deep)) { return false; }
            if (obj === -1) { obj = this.element.find('li'); }
            else { obj = deep ? obj.find('li').addBack() : obj; }
            obj.each(function () {
                var obj = $(this);
                switch (!0) {
                    case obj.hasClass("jstree-open") && !obj.children("ul").children("li").length:
                        obj.removeClass("jstree-open").addClass("jstree-leaf").children("ul").remove(); // children("ins").html("&#160;").end()
                        break;
                    case obj.hasClass("jstree-leaf") && !!obj.children("ul").children("li").length:
                        obj.removeClass("jstree-leaf").addClass("jstree-closed"); //.children("ins").html("+");
                        break;
                }
                obj[obj.next().length === 0 ? 'addClass' : 'removeClass']("jstree-last");
            });
            return obj;
        },
        /**
		 * `get_state()`
		 *
		 * __Returns__
		 *
		 */
        get_state: function () {
            var state = {
                'core': {
                    'open': [],
                    'scroll': {
                        'left': this.element.scrollLeft(),
                        'top': this.element.scrollTop()
                    },
                    'themes': {
                        'name': this.get_theme(),
                        'icons': this._data.core.themes.icons,
                        'dots': this._data.core.themes.dots
                    },
                    'selected': []
                }
            };
            this.get_container_ul().find('.jstree-open').each(function () { if (this.id) { state.core.open.push(this.id); } });
            this._data.core.selected.each(function () { if (this.id) { state.core.selected.push(this.id); } });
            return state;
        },
        /**
		 * `set_state()`
		 *
		 * __Parameters__
		 *
		 * * `state`
		 * * `callback`
		 *
		 * __Returns__
		 *
		 */
        set_state: function (state, callback) {
            if (state) {
                if (state.core) {
                    if ($.isArray(state.core.open)) {
                        var res = true,
							t = this;
                        //this.close_all();
                        $.each(state.core.open.concat([]), function (i, v) {
                            v = document.getElementById(v);
                            if (v) {
                                if (t.is_loaded(v)) {
                                    if (t.is_closed(v)) {
                                        t.open_node(v, false, 0);
                                    }
                                    $.vakata.array_remove(state.core.open, i);
                                }
                                else {
                                    if (!t.is_loading(v)) {
                                        t.open_node(v, $.proxy(function () { this.set_state(state); }, t), 0);
                                    }
                                    // there will be some async activity - so wait for it
                                    res = false;
                                }
                            }
                        });
                        if (res) {
                            delete state.core.open;
                            this.set_state(state, callback);
                        }
                        return false;
                    }
                    if (state.core.scroll) {
                        if (state.core.scroll && typeof state.core.scroll.left !== 'undefined') {
                            this.element.scrollLeft(state.core.scroll.left);
                        }
                        if (state.core.scroll && typeof state.core.scroll.top !== 'undefined') {
                            this.element.scrollTop(state.core.scroll.top);
                        }
                        delete state.core.scroll;
                        delete state.core.open;
                        this.set_state(state, callback);
                        return false;
                    }
                    if (state.core.themes) {
                        if (state.core.themes.name) {
                            this.set_theme(state.core.themes.name);
                        }
                        if (typeof state.core.themes.dots !== 'undefined') {
                            this[state.core.themes.dots ? "show_dots" : "hide_dots"]();
                        }
                        if (typeof state.core.themes.icons !== 'undefined') {
                            this[state.core.themes.icons ? "show_icons" : "hide_icons"]();
                        }
                        delete state.core.themes;
                        delete state.core.open;
                        this.set_state(state, callback);
                        return false;
                    }
                    if (state.core.selected) {
                        var _this = this;
                        this.deselect_all();
                        $.each(state.core.selected, function (i, v) {
                            _this.select_node(document.getElementById(v));
                        });
                        delete state.core.selected;
                        this.set_state(state, callback);
                        return false;
                    }
                    if ($.isEmptyObject(state)) {
                        if (callback) { callback.call(this); }
                        this.trigger('set_state');
                        return false;
                    }
                    return true;
                }
                return true;
            }
            return false;
        },
        /**
		 * `refresh()`
		 */
        refresh: function () {
            this._data.core.state = this.get_state();
            this.load_node(-1, function (o, s) {
                if (s) {
                    this.set_state($.extend(true, {}, this._data.core.state), function () {
                        this.trigger('refresh');
                    });
                }
                this._data.core.state = null;
            });
        },
        /**
		 * `get_text()`
		 *
		 * __Parameters__
		 *
		 * * `obj`
		 * * `remove_html`
		 *
		 * __Returns__
		 *
		 */
        get_text: function (obj, remove_html) {
            obj = this.get_node(obj);
            if (!obj || obj === -1 || !obj.length) { return false; }
            obj = obj.children("a:eq(0)").clone();
            obj.children(".jstree-icon").remove();
            obj = obj[remove_html ? 'text' : 'html']();
            obj = $('<div />')[remove_html ? 'text' : 'html'](obj);
            return obj.html();
        },
        /**
		 * `set_text()`
		 *
		 * __Parameters__
		 *
		 * * `obj`
		 * * `val`
		 *
		 * __Returns__
		 *
		 */
        set_text: function (obj, val) {
            obj = this.get_node(obj);
            if (!obj || obj === -1 || !obj.length) { return false; }
            obj = obj.children("a:eq(0)");
            var tmp = obj.children("I").clone();
            obj.html(val).prepend(tmp);
            this.trigger('set_text', { "obj": obj, "text": val });
            return true;
        },
        /**
		 * `parse_json()`
		 *
		 * __Parameters__
		 *
		 * * `node`
		 *
		 * __Returns__
		 *
		 */
        parse_json: function (node) {
            var li, a, ul, t;
            if (node === null || ($.isArray(node) && node.length === 0)) {
                return false;
            }
            if ($.isArray(node)) {
                ul = $("<ul />");
                t = this;
                $.each(node, function (i, v) {
                    ul.append(t.parse_json(v));
                });
                return ul;
            }
            if (typeof node === "undefined") { node = {}; }
            if (typeof node === "string") { node = { "title": node }; }
            if (!node.li_attr) { node.li_attr = {}; }
            if (!node.a_attr) { node.a_attr = {}; }
            if (!node.a_attr.href) { node.a_attr.href = '#'; }
            if (!node.title) { node.title = this.get_string("New node"); }

            li = $("<li />").attr(node.li_attr);
            a = $("<a />").attr(node.a_attr).html(node.title);
            ul = $("<ul />");
            if (node.data && !$.isEmptyObject(node.data)) { li.data(node.data); }
            if (
				node.children === true ||
				$.isArray(node.children) ||
				(li.data('jstree') && $.isArray(li.data('jstree').children))
			) {
                if (!li.data('jstree')) {
                    li.data('jstree', {});
                }
                li.data('jstree').closed = true;
            }
            li.append(a);
            if ($.isArray(node.children)) {
                $.each(node.children, $.proxy(function (i, n) {
                    ul.append(this.parse_json(n));
                }, this));
                li.append(ul);
            }
            return li;
        },
        /**
		 * `get_json()`
		 *
		 * __Parameters__
		 *
		 * * `obj`
		 * * `is_callback`
		 *
		 * __Returns__
		 *
		 */
        get_json: function (obj, is_callback) {
            obj = typeof obj !== 'undefined' ? this.get_node(obj) : false;
            if (!is_callback) {
                if (!obj || obj === -1) { obj = this.get_container_ul().children("li"); }
            }
            var r, t, li_attr = {}, a_attr = {}, tmp = {}, i;
            if (!obj || !obj.length) { return false; }
            if (obj.length > 1 || !is_callback) {
                r = [];
                t = this;
                obj.each(function () {
                    r.push(t.get_json($(this), true));
                });
                return r;
            }
            tmp = $.vakata.attributes(obj, true);
            $.each(tmp, function (i, v) {
                if (i === 'id') { li_attr[i] = v; return true; }
                v = $.trim(v.replace(/\bjstree[^ ]*/ig, '').replace(/\s+$/ig, " "));
                if (v.length) { li_attr[i] = v; }
            });
            tmp = $.vakata.attributes(obj.children('.jstree-anchor'), true);
            $.each(tmp, function (i, v) {
                if (i === 'id') { a_attr[i] = v; return true; }
                v = $.trim(v.replace(/\bjstree[^ ]*/ig, '').replace(/\s+$/ig, " "));
                if (v.length) { a_attr[i] = v; }
            });
            r = {
                'title': this.get_text(obj),
                'data': $.extend(true, {}, obj.data() || {}),
                'children': false,
                'li_attr': li_attr,
                'a_attr': a_attr
            };

            if (!r.data.jstree) { r.data.jstree = {}; }
            if (this.is_open(obj)) { r.data.jstree.opened = true; }
            if (this.is_closed(obj)) { r.data.jstree.closed = true; }
            i = this.get_icon(obj);
            if (typeof i !== 'undefined' && i !== null) { r.data.jstree.icon = i; }
            if (this.is_selected(obj)) { r.data.jstree.selected = true; }

            obj = obj.children("ul").children("li");
            if (obj.length) {
                r.children = [];
                t = this;
                obj.each(function () {
                    r.children.push(t.get_json($(this), true));
                });
            }
            return r;
        },
        /**
		 * `create_node()`
		 *
		 * __Parameters__
		 *
		 * * `par`
		 * * `node`
		 * * `pos`
		 * * `callback`
		 * * `is_loaded`
		 *
		 * __Returns__
		 *
		 */
        create_node: function (par, node, pos, callback, is_loaded) {
            par = this.get_node(par);
            pos = typeof pos === "undefined" ? "last" : pos;

            if (par !== -1 && !par.length) { return false; }
            if (!pos.match(/^(before|after)$/) && !is_loaded && !this.is_loaded(par)) {
                return this.load_node(par, function () { this.create_node(par, node, pos, callback, true); });
            }

            var li = this.parse_json(node),
				tmp = par === -1 ? this.element : par;

            if (par === -1) {
                if (pos === "before") { pos = "first"; }
                if (pos === "after") { pos = "last"; }
            }
            switch (pos) {
                case "before":
                    pos = par.index();
                    par = this.get_parent(par);
                    break;
                case "after":
                    pos = par.index() + 1;
                    par = this.get_parent(par);
                    break;
                case "inside":
                case "first":
                    pos = 0;
                    break;
                case "last":
                    pos = tmp.children('ul').children('li').length;
                    break;
                default:
                    if (!pos) { pos = 0; }
                    break;
            }
            if (!this.check("create_node", li, par, pos)) { return false; }

            tmp = par === -1 ? this.element : par;
            if (!tmp.children("ul").length) { tmp.append("<ul />"); }
            if (tmp.children("ul").children("li").eq(pos).length) {
                tmp.children("ul").children("li").eq(pos).before(li);
            }
            else {
                tmp.children("ul").append(li);
            }
            this.correct_node(par, true);
            if (callback) { callback.call(this, li); }
            this.trigger('create_node', { "node": li, "parent": par, "position": li.index() });
            return li;
        },
        /**
		 * `rename_node()`
		 *
		 * __Parameters__
		 *
		 * * `obj`
		 * * `val`
		 *
		 * __Returns__
		 *
		 */
        rename_node: function (obj, val) {
            obj = this.get_node(obj);
            var old = this.get_text(obj);
            if (!this.check("rename_node", obj, this.get_parent(obj), val)) { return false; }
            if (obj && obj.length) {
                this.set_text(obj, val); // .apply(this, Array.prototype.slice.call(arguments))
                this.trigger('rename_node', { "node": obj, "title": val, "old": old });
            }
        },
        /**
		 * `delete_node()`
		 *
		 * __Parameters__
		 *
		 * * `obj`
		 *
		 * __Returns__
		 *
		 */
        delete_node: function (obj) {
            obj = this.get_node(obj);
            if (!obj || obj === -1 || !obj.length) { return false; }
            var par = this.get_parent(obj),
				pre = this.get_prev(obj);
            if (!this.check("delete_node", obj, par, obj.index())) { return false; }
            obj = obj.detach();
            this.correct_node(par);
            this.correct_node(pre);
            this.trigger('delete_node', { "node": obj, "prev": pre, "parent": par });

            var n = obj.find(".jstree-clicked"),
				t = this;
            if (n.length) {
                n.each(function () { t.deselect_node(this, true); });
                this.trigger('changed', { 'action': 'delete_node', 'node': obj, 'selected': this._data.core.selected, 'parent': par });
            }
            return obj;
        },
        /**
		 * `check()`
		 *
		 * __Parameters__
		 *
		 * * `chk`
		 * * `obj`
		 * * `par`
		 * * `pos`
		 *
		 * __Returns__
		 *
		 */
        check: function (chk, obj, par, pos) {
            var tmp = chk.match(/^move_node|copy_node|create_node$/i) ? par : obj,
				chc = this.settings.core.check_callback;
            if (chc === false || ($.isFunction(chc) && chc.call(this, chk, obj, par, pos) === false)) {
                return false;
            }
            tmp = tmp === -1 ? this.element.data('jstree') : tmp.data('jstree');
            if (tmp && tmp.functions && tmp.functions[chk]) {
                tmp = tmp.functions[chk];
                if ($.isFunction(tmp)) {
                    tmp = tmp.call(this, chk, obj, par, pos);
                }
                if (tmp === false) {
                    return false;
                }
            }
            switch (chk) {
                case "create_node":
                    break;
                case "rename_node":
                    break;
                case "move_node":
                    tmp = par === -1 ? this.element : par;
                    tmp = tmp.children('ul').children('li');
                    if (tmp.length && tmp.index(obj) !== -1 && (pos === obj.index() || pos === obj.index() + 1)) {
                        return false;
                    }
                    if (par !== -1 && par.parentsUntil('.jstree', 'li').addBack().index(obj) !== -1) {
                        return false;
                    }
                    break;
                case "copy_node":
                    break;
                case "delete_node":
                    break;
            }
            return true;
        },
        /**
		 * `move_node()`
		 *
		 * __Parameters__
		 *
		 * * `obj`
		 * * `par`
		 * * `pos`
		 * * `callback`
		 * * `is_loaded`
		 *
		 * __Returns__
		 *
		 */
        move_node: function (obj, par, pos, callback, is_loaded) {
            obj = this.get_node(obj);
            par = this.get_node(par);
            pos = typeof pos === "undefined" ? 0 : pos;

            if (!obj || obj === -1 || !obj.length) { return false; }
            if (par !== -1 && !par.length) { return false; }
            if (!pos.toString().match(/^(before|after)$/) && !is_loaded && !this.is_loaded(par)) {
                return this.load_node(par, function () { this.move_node(obj, par, pos, callback, true); });
            }

            var old_par = this.get_parent(obj),
				new_par = (!pos.toString().match(/^(before|after)$/) || par === -1) ? par : this.get_parent(par),
				old_ins = $.jstree.reference(obj),
				new_ins = par === -1 ? this : $.jstree.reference(par),
				is_multi = (old_ins._id !== new_ins._id);
            if (new_par === -1) {
                par = new_ins.get_container();
                if (pos === "before") { pos = "first"; }
                if (pos === "after") { pos = "last"; }
            }
            switch (pos) {
                case "before":
                    pos = par.index();
                    break;
                case "after":
                    pos = par.index() + 1;
                    break;
                case "inside":
                case "first":
                    pos = 0;
                    break;
                case "last":
                    pos = par.children('ul').children('li').length;
                    break;
                default:
                    if (!pos) { pos = 0; }
                    break;
            }
            if (!this.check("move_node", obj, new_par, pos)) { return false; }

            if (!par.children("ul").length) { par.append("<ul />"); }
            if (par.children("ul").children("li").eq(pos).length) {
                par.children("ul").children("li").eq(pos).before(obj);
            }
            else {
                par.children("ul").append(obj);
            }

            if (is_multi) { // if multitree - clean the node recursively - remove all icons, and call deep clean_node
                obj.find('.jstree-icon, .jstree-ocl').remove();
                this.clean_node(obj);
            }
            old_ins.correct_node(old_par, true);
            new_ins.correct_node(new_par, true);
            if (callback) { callback.call(this, obj, new_par, obj.index()); }
            this.trigger('move_node', { "node": obj, "parent": new_par, "position": obj.index(), "old_parent": old_par, "is_multi": is_multi, 'old_instance': old_ins, 'new_instance': new_ins });
            return true;
        },
        /**
		 * `copy_node()`
		 *
		 * __Parameters__
		 *
		 * * `obj`
		 * * `par`
		 * * `pos`
		 * * `callback`
		 * * `is_loaded`
		 *
		 * __Returns__
		 *
		 */
        copy_node: function (obj, par, pos, callback, is_loaded) {
            obj = this.get_node(obj);
            par = this.get_node(par);
            pos = typeof pos === "undefined" ? "last" : pos;

            if (!obj || obj === -1 || !obj.length) { return false; }
            if (par !== -1 && !par.length) { return false; }
            if (!pos.toString().match(/^(before|after)$/) && !is_loaded && !this.is_loaded(par)) {
                return this.load_node(par, function () { this.copy_node(obj, par, pos, callback, true); });
            }
            var org_obj = obj,
				old_par = this.get_parent(obj),
				new_par = (!pos.toString().match(/^(before|after)$/) || par === -1) ? par : this.get_parent(par),
				old_ins = $.jstree.reference(obj),
				new_ins = par === -1 ? this : $.jstree.reference(par),
				is_multi = (old_ins._id !== new_ins._id);

            obj = obj.clone(true);
            obj.find("*[id]").addBack().each(function () {
                if (this.id) { this.id = "copy_" + this.id; }
            });
            if (new_par === -1) {
                par = new_ins.get_container();
                if (pos === "before") { pos = "first"; }
                if (pos === "after") { pos = "last"; }
            }
            switch (pos) {
                case "before":
                    pos = par.index();
                    break;
                case "after":
                    pos = par.index() + 1;
                    break;
                case "inside":
                case "first":
                    pos = 0;
                    break;
                case "last":
                    pos = par.children('ul').children('li').length;
                    break;
                default:
                    if (!pos) { pos = 0; }
                    break;
            }

            if (!this.check("copy_node", org_obj, new_par, pos)) { return false; }

            if (!par.children("ul").length) { par.append("<ul />"); }
            if (par.children("ul").children("li").eq(pos).length) {
                par.children("ul").children("li").eq(pos).before(obj);
            }
            else {
                par.children("ul").append(obj);
            }
            if (is_multi) { // if multitree - clean the node recursively - remove all icons, and call deep clean_node
                obj.find('.jstree-icon, .jstree-ocl').remove();
            }
            new_ins.clean_node(obj); // always clean so that selected states, etc. are removed
            new_ins.correct_node(new_par, true); // no need to correct the old parent, as nothing has changed there
            if (callback) { callback.call(this, obj, new_par, obj.index(), org_obj); }
            this.trigger('copy_node', { "node": obj, "parent": new_par, "old_parent": old_par, "position": obj.index(), "original": org_obj, "is_multi": is_multi, 'old_instance': old_ins, 'new_instance': new_ins });
            return true;
        },
        /**
		 * `cut()`
		 *
		 * __Parameters__
		 *
		 * * `obj`
		 *
		 * __Returns__
		 *
		 */
        cut: function (obj) {
            obj = this.get_node(obj);
            if (!obj || obj === -1 || !obj.length) { return false; }
            ccp_node = obj;
            ccp_mode = 'move_node';
            this.trigger('cut', { "node": obj });
        },
        /**
		 * `copy()`
		 *
		 * __Parameters__
		 *
		 * * `obj`
		 *
		 * __Returns__
		 *
		 */
        copy: function (obj) {
            obj = this.get_node(obj);
            if (!obj || obj === -1 || !obj.length) { return false; }
            ccp_node = obj;
            ccp_mode = 'copy_node';
            this.trigger('copy', { "node": obj });
        },
        /**
		 * `get_buffer()`
		 *
		 * __Returns__
		 *
		 */
        get_buffer: function () {
            return { 'mode': ccp_mode, 'node': ccp_node };
        },
        /**
		 * `can_paste()`
		 *
		 * __Returns__
		 *
		 */
        can_paste: function () {
            return ccp_mode !== false && ccp_node !== false;
        },
        /**
		 * `paste()`
		 *
		 * __Parameters__
		 *
		 * * `obj`
		 *
		 * __Returns__
		 *
		 */
        paste: function (obj) {
            obj = this.get_node(obj);
            if (!obj || !ccp_mode || !ccp_mode.match(/^(copy_node|move_node)$/) || !ccp_node) { return false; }
            this[ccp_mode](ccp_node, obj);
            this.trigger('paste', { "obj": obj, "nodes": ccp_node, "mode": ccp_mode });
            ccp_node = false;
            ccp_mode = false;
        },
        /**
		 * `edit()`
		 *
		 * __Parameters__
		 *
		 * * `obj`
		 * * `default_text`
		 *
		 * __Returns__
		 *
		 */
        edit: function (obj, default_text) {
            obj = this.get_node(obj);
            if (!obj || obj === -1 || !obj.length) { return false; }
            obj.parentsUntil(".jstree", ".jstree-closed").each($.proxy(function (i, v) {
                this.open_node(v, false, 0);
            }, this));
            var rtl = this._data.core.rtl,
				w = this.element.width(),
				a = obj.children('a:eq(0)'),
				oi = obj.children("i"),
				ai = a.children("i"),
				w1 = oi.width() * oi.length,
				w2 = ai.width() * ai.length,
				t = typeof default_text === 'string' ? default_text : this.get_text(obj),
				h1 = $("<" + "div />", { css: { "position": "absolute", "top": "-200px", "left": (rtl ? "0px" : "-1000px"), "visibility": "hidden" } }).appendTo("body"),
				h2 = obj.css("position", "relative").append(
					$("<" + "input />", {
					    "value": t,
					    "class": "jstree-rename-input",
					    // "size" : t.length,
					    "css": {
					        "padding": "0",
					        "border": "1px solid silver",
					        "position": "absolute",
					        "left": (rtl ? "auto" : (w1 + w2 + 4) + "px"),
					        "right": (rtl ? (w1 + w2 + 4) + "px" : "auto"),
					        "top": "0px",
					        "height": (this._data.core.li_height - 2) + "px",
					        "lineHeight": (this._data.core.li_height - 2) + "px",
					        "width": "150px" // will be set a bit further down
					    },
					    "blur": $.proxy(function () {
					        var i = obj.children(".jstree-rename-input"),
								v = i.val();
					        if (v === "") { v = t; }
					        h1.remove();
					        i.remove();
					        if (this.rename_node(obj, v) === false) {
					            this.rename_node(obj, t);
					        }
					        obj.css("position", "");
					    }, this),
					    "keydown": function (event) {
					        var key = event.keyCode || event.which;
					        if (key === 27) {
					            this.value = t;
					        }
					        if (key === 27 || key === 13 || key === 37 || key === 38 || key === 39 || key === 40) {
					            event.stopImmediatePropagation();
					        }
					        if (key === 27 || key === 13) {
					            event.preventDefault();
					            this.blur();
					        }
					    },
					    "keyup": function (event) {
					        var key = event.keyCode || event.which;
					        h2.width(Math.min(h1.text("pW" + this.value).width(), w));
					    },
					    "keypress": function (event) {
					        var key = event.keyCode || event.which;
					        if (key === 13) { return false; }
					    }
					})
				).children(".jstree-rename-input"),
				fn = {
				    fontFamily: a.css('fontFamily') || '',
				    fontSize: a.css('fontSize') || '',
				    fontWeight: a.css('fontWeight') || '',
				    fontStyle: a.css('fontStyle') || '',
				    fontStretch: a.css('fontStretch') || '',
				    fontVariant: a.css('fontVariant') || '',
				    letterSpacing: a.css('letterSpacing') || '',
				    wordSpacing: a.css('wordSpacing') || ''
				};
            this.set_text(obj, "");
            h1.css(fn);
            h2.css(fn).width(Math.min(h1.text("pW" + h2[0].value).width(), w))[0].select();
        },
        /**
		 * `set_theme()`
		 *
		 * __Parameters__
		 *
		 * * `theme_name`
		 * * `theme_url`
		 *
		 * __Returns__
		 *
		 */
        set_theme: function (theme_name, theme_url) {
            if (!theme_name) { return false; }
            if (theme_url === true) {
                var dir = this.settings.core.themes.dir;
                if (!dir) { dir = $.jstree.path + '/themes'; }
                theme_url = dir + '/' + theme_name + '/style.css';
            }
            if (theme_url && $.inArray(theme_url, themes_loaded) === -1) {
                $('head').append('<' + 'link rel="stylesheet" href="' + theme_url + '" type="text/css" />');
                themes_loaded.push(theme_url);
            }
            if (this._data.core.themes.name) {
                this.element.removeClass('jstree-' + this._data.core.themes.name);
            }
            this._data.core.themes.name = theme_name;
            this.element.addClass('jstree-' + theme_name);
            this.trigger('set_theme', { 'theme': theme_name });
        },
        /**
		 * `get_theme()`
		 *
		 * __Returns__
		 *
		 */
        get_theme: function () { return this._data.core.themes.name; },
        /**
		 * `show_dots()`
		 */
        show_dots: function () { this._data.core.themes.dots = true; this.element.children("ul").removeClass("jstree-no-dots"); },
        /**
		 * `hide_dots()`
		 */
        hide_dots: function () { this._data.core.themes.dots = false; this.element.children("ul").addClass("jstree-no-dots"); },
        /**
		 * `toggle_dots()`
		 */
        toggle_dots: function () { if (this._data.core.themes.dots) { this.hide_dots(); } else { this.show_dots(); } },
        /**
		 * `show_icons()`
		 */
        show_icons: function () { this._data.core.themes.icons = true; this.element.children("ul").removeClass("jstree-no-icons"); },
        /**
		 * `hide_icons()`
		 */
        hide_icons: function () { this._data.core.themes.icons = false; this.element.children("ul").addClass("jstree-no-icons"); },
        /**
		 * `toggle_icons()`
		 */
        toggle_icons: function () { if (this._data.core.themes.icons) { this.hide_icons(); } else { this.show_icons(); } },
        /**
		 * `set_icon()`
		 *
		 * __Parameters__
		 *
		 * * `obj`
		 * * `icon`
		 *
		 * __Returns__
		 *
		 */
        set_icon: function (obj, icon) {
            obj = this.get_node(obj);
            if (!obj || obj === -1 || !obj.length) { return false; }
            obj = obj.children("a").children(".jstree-themeicon");
            if (icon === false) {
                this.hide_icon(obj);
            }
            else if (icon.indexOf("/") === -1) {
                obj.addClass(icon).attr("rel", icon);
            }
            else {
                obj.css("background", "url('" + icon + "') center center no-repeat").attr("rel", icon);
            }
            return true;
        },
        /**
		 * `get_icon()`
		 *
		 * __Parameters__
		 *
		 * * `obj`
		 *
		 * __Returns__
		 *
		 */
        get_icon: function (obj) {
            obj = this.get_node(obj);
            if (!obj || obj === -1 || !obj.length) { return null; }
            obj = obj.children("a").children(".jstree-themeicon");
            if (obj.hasClass('jstree-themeicon-hidden')) { return false; }
            obj = obj.attr("rel");
            return (obj && obj.length) ? obj : null;
        },
        /**
		 * `hide_icon()`
		 *
		 * __Parameters__
		 *
		 * * `obj`
		 *
		 * __Returns__
		 *
		 */
        hide_icon: function (obj) {
            obj = this.get_node(obj);
            if (!obj || obj === -1 || !obj.length) { return false; }
            obj.children("a").children(".jstree-themeicon").addClass('jstree-themeicon-hidden');
            return true;
        },
        /**
		 * `show_icon()`
		 *
		 * __Parameters__
		 *
		 * * `obj`
		 *
		 * __Returns__
		 *
		 */
        show_icon: function (obj) {
            obj = this.get_node(obj);
            if (!obj || obj === -1 || !obj.length) { return false; }
            obj.children("a").children(".jstree-themeicon").removeClass('jstree-themeicon-hidden');
            return true;
        }
    };

    var src = $('script:last').attr('src');
    $.jstree.path = src ? src.replace(/\/[^\/]+$/, '') : '';
    $.jstree.no_css = src && src.indexOf('?no_css') !== -1;

    if ($.jstree.no_css) {
        $.jstree.defaults.core.themes.url = false;
    }

    // base CSS
    $(function () {
        var css_string = '' +
				//'.jstree * { -webkit-box-sizing:content-box; -moz-box-sizing:content-box; box-sizing:content-box; }' +
				'.jstree ul, .jstree li { display:block; margin:0 0 0 0; padding:0 0 0 0; list-style-type:none; list-style-image:none; } ' +
				'.jstree li { display:block; } ' + // min-height:18px; line-height:18px; white-space:nowrap; margin-left:18px; min-width:18px; 
				'.jstree-rtl li { margin-left:0; margin-right:18px; } ' +
				'.jstree > ul > li { margin-left:0px; } ' +
				'.jstree-rtl > ul > li { margin-right:0px; } ' +
				'.jstree .jstree-icon {text-decoration:none; margin:0; padding:0; vertical-align:top; } ' +  // display:inline-block; 
				'.jstree .jstree-ocl { width:18px; height:18px; text-align:center; line-height:18px; cursor:pointer; vertical-align:top; } ' +
				'.jstree li.jstree-open > ul { display:block; } ' +
				'.jstree li.jstree-closed > ul { display:none; } ' +
				'.jstree-anchor {line-height:16px; color:black; padding:1px 4px 1px 2px; margin:0; text-decoration:none; outline:0; } ' +  // display:inline-block;  white-space:nowrap; height:16px;
				'.jstree-anchor > .jstree-themeicon { display: none; height:16px; width:16px; margin-right:3px; } ' +
				'.jstree-rtl .jstree-anchor { padding:1px 2px 1px 4px; } ' +
				'.jstree-rtl .jstree-anchor > .jstree-themeicon { margin-left:3px; margin-right:0; } ' +
				'.jstree-no-icons .jstree-themeicon, .jstree-anchor > .jstree-themeicon-hidden { display:none; } ';
        if (!$.jstree.no_css) {
            $('head').append('<' + 'style type="text/css">' + css_string + '<' + '/style>');
        }
    });

    // helpers
    $.vakata = {};
    // collect attributes
    $.vakata.attributes = function (node, with_values) {
        node = $(node)[0];
        var attr = with_values ? {} : [];
        $.each(node.attributes, function (i, v) {
            if ($.inArray(v.nodeName.toLowerCase(), ['style', 'contenteditable', 'hasfocus', 'tabindex']) !== -1) { return; }
            if (v.nodeValue !== null && $.trim(v.nodeValue) !== '') {
                if (with_values) { attr[v.nodeName] = v.nodeValue; }
                else { attr.push(v.nodeName); }
            }
        });
        return attr;
    };
    // remove item from array
    $.vakata.array_remove = function (array, from, to) {
        var rest = array.slice((to || from) + 1 || array.length);
        array.length = from < 0 ? array.length + from : from;
        array.push.apply(array, rest);
        return array;
    };
    // private function for json quoting strings
    var _quote = function (str) {
        var escapeable = /["\\\x00-\x1f\x7f-\x9f]/g,
			meta = { '\b': '\\b', '\t': '\\t', '\n': '\\n', '\f': '\\f', '\r': '\\r', '"': '\\"', '\\': '\\\\' };
        if (str.match(escapeable)) {
            return '"' + str.replace(escapeable, function (a) {
                var c = meta[a];
                if (typeof c === 'string') { return c; }
                c = a.charCodeAt();
                return '\\u00' + Math.floor(c / 16).toString(16) + (c % 16).toString(16);
            }) + '"';
        }
        return '"' + str + '"';
    };
    $.vakata.json = {
        encode: function (o) {
            if (o === null) { return "null"; }

            var tmp = [], i;
            switch (typeof (o)) {
                case "undefined":
                    return undefined;
                case "number":
                case "boolean":
                    return o + "";
                case "string":
                    return _quote(o);
                case "object":
                    if ($.isFunction(o.toJSON)) {
                        return $.vakata.json.encode(o.toJSON());
                    }
                    if (o.constructor === Date) {
                        return '"' +
							o.getUTCFullYear() + '-' +
							String("0" + (o.getUTCMonth() + 1)).slice(-2) + '-' +
							String("0" + o.getUTCDate()).slice(-2) + 'T' +
							String("0" + o.getUTCHours()).slice(-2) + ':' +
							String("0" + o.getUTCMinutes()).slice(-2) + ':' +
							String("0" + o.getUTCSeconds()).slice(-2) + '.' +
							String("00" + o.getUTCMilliseconds()).slice(-3) + 'Z"';
                    }
                    if (o.constructor === Array) {
                        for (i = 0; i < o.length; i++) {
                            tmp.push($.vakata.json.encode(o[i]) || "null");
                        }
                        return "[" + tmp.join(",") + "]";
                    }

                    $.each(o, function (i, v) {
                        if ($.isFunction(v)) { return true; }
                        i = typeof i === "number" ? '"' + i + '"' : _quote(i);
                        v = $.vakata.json.encode(v);
                        tmp.push(i + ":" + v);
                    });
                    return "{" + tmp.join(", ") + "}";
            }
        },
        decode: function (json) {
            return $.parseJSON(json);
        }
    };

})(jQuery);


/*
 * jstree sample plugin

// wrap in IIFE and pass jQuery as $
(function ($) {
	// some private plugin stuff if needed
	var private_var = null;

	// extending the defaults
	$.jstree.defaults.sample = {
		sample_option : 'sample_val'
	};

	// the actual plugin code
	$.jstree.plugins.sample = function (options, parent) {
		// own function
		this.sample_function = function (arg) {
			// you can chain this method if needed and available
			if(parent.sample_function) { parent.sample_function.call(this, arg); }
		};

		// *SPECIAL* FUNCTIONS
		this.init = function () {
			// do not forget parent
			parent.init.call(this);
		};
		// bind events if needed
		this.bind = function () {
			// call parent function first
			parent.bind.call(this);
			// do(stuff);
		};
		// unbind events if needed (all in jquery namespace are taken care of by the core)
		this.unbind = function () {
			// do(stuff);
			// call parent function last
			parent.unbind.call(this);
		};
		this.teardown = function () {
			// do not forget parent
			parent.teardown.call(this);
		};
		// very heavy - use only if needed and be careful
		this.clean_node = function(obj) {
			// always get the cleaned node from the parent
			obj = parent.clean_node.call(this, obj);
			return obj.each(function () {
				// process nodes
			});
		};
		// state management - get and restore
		this.get_state = function () {
			// always get state from parent first
			var state = parent.get_state.call(this);
			// add own stuff to state
			state.sample = { 'var' : 'val' };
			return state;
		};
		this.set_state = function (state, callback) {
			// only process your part if parent returns true
			// there will be multiple times with false
			if(parent.set_state.call(state, callback)) {
				// check the key you set above
				if(state.sample) {
					// do(stuff); // like calling this.sample_function(state.sample.var);
					// remove your part of the state and RETURN FALSE, the next cycle will be TRUE
					delete state.sample;
					return false;
				}
				// return true if your state is gone (cleared in the previous step)
				return true;
			}
			// parent was false - return false too
			return false;
		};
		// node transportation
		this.get_json = function (obj, is_callback) {
			// get the node from the parent
			var r = parent.get_json.call(this, obj, is_callback);
			// only modify the node if is_callback is true
			if(is_callback) {
				r.data.sample = 'value';
			}
			// return the original / modified node
			return r;
		};
	};

	// attach to document ready if needed
	$(function () {
		// do(stuff);
	});

	// you can include the sample plugin in all instances by default
	$.jstree.defaults.plugins.push("sample");
})(jQuery);
//*/

/**
 * ### Checkbox plugin
 */
(function ($) {
    $.jstree.defaults.checkbox = {
        three_state: true,
        whole_node: false,
        keep_selected_style: true,
        icons: true,
        parse_data: true
    };

    $.jstree.plugins.checkbox = function (options, parent) {
        this.bind = function () {
            parent.bind.call(this);

            this.element
				.on("init.jstree", $.proxy(function () {
				    this._data.checkbox.icons = this.settings.checkbox.icons;
				}, this))
				.on('loaded.jstree', $.proxy(function () {
				    this[this._data.checkbox.icons ? 'show_checkboxes' : 'hide_checkboxes']();
				}, this));
            if (!this.settings.checkbox.keep_selected_style) {
                this.element.addClass('jstree-checkbox-no-clicked');
            }
            if (this.settings.checkbox.three_state) {
                this.element
					.on('ready.jstree', $.proxy(function () {
					    var change = false,
                            nodes = this.get_selected(),
                            tmp = nodes
                                    .find('.jstree-undetermined').removeClass('jstree-undetermined').end()
                                    .find('.jstree-anchor:not(.jstree-clicked)');

					    if (tmp.length) {
					        change = true;
					        this.select_node(tmp, true, true);
					    }
					    nodes.each($.proxy(function (i, v) {
					        change = change || this.check_up($(v).parent());
					    }, this));
					    if (change) {
					        this.trigger('changed', { 'action': 'checkbox_three_state', 'selected': this._data.core.selected });
					    }
					    if (this.settings.json && this.settings.json.progressive_render && this.settings.checkbox.three_state) {
					        this.element
                                .on('deselect_all.jstree select_node.jstree deselect_node.jstree', $.proxy(function (e, data) {
                                    data.node.filter('.jstree-closed').each($.proxy(function (i, v) {
                                        var t = $(v),
                                            d = t.data('jstree');
                                        if (d && d.children && t.children('ul').length === 0) {
                                            this._progressive_data_clean(d.children, e.type === 'select_node');
                                        }
                                    }, this));
                                }, this));
					    }
					}, this))
					.on('deselect_all.jstree', $.proxy(function (e, data) {
					    this.element.find('.jstree-undetermined').removeClass('jstree-undetermined');
					}, this))
					.on('open_node.jstree', $.proxy(function (e, data) {
					    if (data.node && data.node !== -1) {
					        var tmp;
					        if (this.is_selected(data.node)) {
					            tmp = data.node.find('.jstree-anchor').not('.jstree-clicked');
					            if (tmp.length) {
					                this.select_node(tmp, true, true);
					            }
					        }
					        else {
					            if (this.check_up(data.node)) {
					                this.trigger('changed', { 'action': 'checkbox_three_state', 'selected': this._data.core.selected });
					            }
					        }
					    }
					}, this))
					.on('changed.jstree', $.proxy(function (e, data) {
					    var action = data.action || '',
                            node = false,
                            change = false,
                            tmp;
					    switch (action) {
					        case 'select_node':
					            node = data.node.parent();
					            tmp = data.node.find('.jstree-anchor:not(.jstree-clicked)');
					            if (tmp.length) {
					                change = true;
					                this.select_node(tmp, true, true);
					            }
					            data.node.find('.jstree-undetermined').removeClass('jstree-undetermined');
					            /*
                                data.node.find('.jstree-anchor:not(.jstree-clicked)').each($.proxy(function (i,v) {
                                    change = true;
                                    this.select_node(v, true, true);
                                }, this)).end().find('.jstree-undetermined').removeClass('jstree-undetermined');
                                */
					            break;
					        case 'deselect_node':
					            node = data.node.parent();
					            tmp = data.node.find('.jstree-clicked');
					            if (tmp.length) {
					                change = true;
					                this.deselect_node(tmp, true);
					            }
					            data.node.find('.jstree-undetermined').removeClass('jstree-undetermined');
					            /*
                                data.node.find('.jstree-clicked').each($.proxy(function (i,v) {
                                    change = true;
                                    this.deselect_node(v, true);
                                }, this)).end().find('.jstree-undetermined').removeClass('jstree-undetermined');
                                */
					            break;
					        case 'deselect_all':
					            this.element.find('.jstree-undetermined').removeClass('jstree-undetermined');
					            break;
					        case 'delete_node':
					            node = data.parent;
					            break;
					        default:
					            break;
					    }
					    if (node && this.check_up(node)) {
					        change = true;
					    }
					    if (change) {
					        this.trigger('changed', { 'action': 'checkbox_three_state', 'selected': this._data.core.selected });
					    }
					}, this))
					.on('move_node.jstree copy_node.jstree', $.proxy(function (e, data) {
					    if (data.old_instance && data.old_instance.check_up && data.old_instance.check_up(data.old_parent)) {
					        data.old_instance.trigger('changed', { 'action': 'checkbox_three_state', 'selected': data.old_instance._data.core.selected });
					    }
					    if (data.new_instance && data.new_instance.check_up && data.new_instance.check_up(data.parent)) {
					        data.new_instance.trigger('changed', { 'action': 'checkbox_three_state', 'selected': data.new_instance._data.core.selected });
					    }
					}, this));
            }
        };
        this._progressive_data_clean = function (data, is_select) {
            if (!this.settings.checkbox.three_state) { return false; }
            for (var i = 0, j = data.length; i < j; i++) {
                if (data[i].data && data[i].data.jstree) {
                    if (data[i].data.jstree.selected) {
                        delete data[i].data.jstree.selected;
                    }
                    if (data[i].data.jstree.undetermined) {
                        delete data[i].data.jstree.undetermined;
                    }
                    if (data[i].children) {
                        this._progressive_data_clean(data[i].children, is_select);
                    }
                }
            }
        };
        this._set_state = function (node) {
            var i = 0, j = 0, c = 0, r = false;
            if ($.isArray(node)) {
                for (i = 0, j = node.length; i < j; i++) {
                    node[i] = this._set_state(node[i]);
                }
                return node;
            }
            else {
                if (typeof node === "undefined") { node = {}; }
                if (typeof node === "string") { node = { "title": node }; }
                if (!node.data) { node.data = {}; }
                if (!node.data.jstree) { node.data.jstree = {}; }
                r = node.data.jstree;
                if (r.selected || r.undetermined || r._checkboxed) { return node; }
                r._checkboxed = true;

                if (node.children && node.children.length) {
                    for (i = 0, j = node.children.length; i < j; i++) {
                        node.children[i] = this._set_state(node.children[i]);
                        r = node.children[i].data.jstree;
                        if (r.selected) { c += 2; }
                        else if (r.undetermined) { c += 1; }
                    }
                    if (c > 0) {
                        if (c === j * 2) {
                            node.data.jstree.selected = true;
                        }
                        else {
                            node.data.jstree.undetermined = true;
                        }
                    }
                }
                return node;
            }
        };
        this.parse_json = function (data) {
            var s = this.settings.checkbox;
            if (s.parse_data && s.three_state && $.isArray(data)) {
                data = this._set_state(data);
            }
            return parent.parse_json.call(this, data);
        };
        this.clean_node = function (obj) {
            obj = parent.clean_node.call(this, obj);
            var _this = this;
            return obj.each(function () {
                var t = $(this),
					d = t.data('jstree'),
					o = t.children('a');
                if (!o.children("i.jstree-checkbox").length) {
                    o.prepend("<" + "i class='jstree-icon jstree-checkbox'><" + "/i>");
                }
                if (d && d.undetermined) {
                    o.parentsUntil('.jstree', 'li').children("a.jstree-anchor").children("i.jstree-checkbox").addClass('jstree-undetermined');
                    delete d.undetermined;
                }
            });
        };
        this.get_json = function (obj, is_callback) {
            var r = parent.get_json.call(this, obj, is_callback);
            if (is_callback) {
                if (obj.children(".jstree-anchor").children(".jstree-undetermined").length) {
                    r.data.jstree.undetermined = true;
                }
            }
            return r;
        };
        this.activate_node = function (obj, e) {
            if (this.settings.checkbox.whole_node || $(e.target).hasClass('jstree-checkbox')) {
                e.ctrlKey = true;
            }
            parent.activate_node.call(this, obj, e);
        };
        this.check_up = function (obj) {
            if (!this.settings.checkbox.three_state) { return false; }
            obj = this.get_node(obj);
            if (obj === -1 || !obj || !obj.length) { return false; }

            var state = 0,
				has_children = obj.children("ul").children("li").length > 0,
				all_checked = has_children && obj.children("ul").children("li").not(this._data.core.selected).length === 0,
				none_checked = has_children && obj.find('li > .jstree-clicked, li > .jstree-anchor > .jstree-undetermined').length === 0;

            if (!state && this.is_selected(obj)) { state = 1; }
            if (!state && obj.children(".jstree-anchor").children(".jstree-undetermined").length) { state = 2; }

            // if no children
            if (!has_children) {
                if (state === 2) {
                    obj.find('.jstree-undetermined').removeClass('jstree-undetermined');
                }
                return false;
            }
            // if all checked children
            if (all_checked) {
                if (state !== 1) {
                    obj.find('.jstree-undetermined').removeClass('jstree-undetermined');
                    this.select_node(obj, true);
                    this.check_up(obj.parent());
                }
                return true;
            }
            // if none children checked
            if (none_checked) {
                if (state === 2) {
                    obj.find('.jstree-undetermined').removeClass('jstree-undetermined');
                    this.check_up(obj.parent());
                    return false;
                }
                if (state === 1) {
                    this.deselect_node(obj, true);
                    this.check_up(obj.parent());
                    return true;
                }
                return false;
            }
            // some children are checked and state is checked
            if (state === 1) {
                obj.children(".jstree-anchor").children(".jstree-checkbox").addClass('jstree-undetermined');
                this.deselect_node(obj, true);
                this.check_up(obj.parent());
                return true;
            }
            // some children are checked and state is unchecked
            if (state === 0) {
                var tmp = obj.children('.jstree-anchor').children('.jstree-checkbox');
                if (!tmp.hasClass('jstree-undetermined')) {
                    obj.children('.jstree-anchor').children('.jstree-checkbox').addClass('jstree-undetermined');
                    this.check_up(obj.parent());
                }
            }
            return false;
        };
        /**
		 * `show_checkboxes()`
		 */
        this.show_checkboxes = function () { this._data.checkbox.icons = true; this.element.children("ul").removeClass("jstree-no-checkboxes"); };
        /**
		 * `hide_checkboxes()`
		 */
        this.hide_checkboxes = function () { this._data.checkbox.icons = false; this.element.children("ul").addClass("jstree-no-checkboxes"); };
        /**
		 * `toggle_checkboxes()`
		 */
        this.toggle_checkboxes = function () { if (this._data.checkbox.icons) { this.hide_checkboxes(); } else { this.show_checkboxes(); } };
    };

    $(function () {
        // add checkbox specific CSS
        var css_string = '' +
				'.jstree-anchor > .jstree-checkbox { height:16px; width:16px; margin-right:1px; } ' +
				'.jstree-rtl .jstree-anchor > .jstree-checkbox { margin-right:0; margin-left:1px; } ';
        // the default stylesheet
        if (!$.jstree.no_css) {
            $('head').append('<style type="text/css">' + css_string + '</style>');
        }

    });

    // include the checkbox plugin by default
    $.jstree.defaults.plugins.push("checkbox");
})(jQuery);

/**
 * ### Contextmenu plugin
 */
(function ($) {
    $.jstree.defaults.contextmenu = {
        select_node: true,
        show_at_node: true,
        items: function (o) { // Could be an object directly
            // TODO: in "_disabled" call this._check()
            return {
                "create": {
                    "separator_before": false,
                    "separator_after": true,
                    "label": "Create",
                    "action": function (data) {
                        var inst = $.jstree.reference(data.reference),
							obj = inst.get_node(data.reference);
                        inst.create_node(obj, {}, "last", function (new_node) {
                            setTimeout(function () { inst.edit(new_node); }, 0);
                        });
                    }
                },
                "rename": {
                    "separator_before": false,
                    "separator_after": false,
                    "label": "Rename",
                    "action": function (data) {
                        var inst = $.jstree.reference(data.reference),
							obj = inst.get_node(data.reference);
                        inst.edit(obj);
                    }
                },
                "remove": {
                    "separator_before": false,
                    "icon": false,
                    "separator_after": false,
                    "label": "Delete",
                    "action": function (data) {
                        var inst = $.jstree.reference(data.reference),
							obj = inst.get_node(data.reference);
                        inst.delete_node(obj);
                    }
                },
                "ccp": {
                    "separator_before": true,
                    "icon": false,
                    "separator_after": false,
                    "label": "Edit",
                    "action": false,
                    "submenu": {
                        "cut": {
                            "separator_before": false,
                            "separator_after": false,
                            "label": "Cut",
                            "action": function (data) {
                                var inst = $.jstree.reference(data.reference),
									obj = inst.get_node(data.reference);
                                inst.cut(obj);
                            }
                        },
                        "copy": {
                            "separator_before": false,
                            "icon": false,
                            "separator_after": false,
                            "label": "Copy",
                            "action": function (data) {
                                var inst = $.jstree.reference(data.reference),
									obj = inst.get_node(data.reference);
                                inst.copy(obj);
                            }
                        },
                        "paste": {
                            "separator_before": false,
                            "icon": false,
                            "_disabled": !(this.can_paste()),
                            "separator_after": false,
                            "label": "Paste",
                            "action": function (data) {
                                var inst = $.jstree.reference(data.reference),
									obj = inst.get_node(data.reference);
                                inst.paste(obj);
                            }
                        }
                    }
                }
            };
        }
    };

    $.jstree.plugins.contextmenu = function (options, parent) {
        this.bind = function () {
            parent.bind.call(this);

            this.element
				.on("contextmenu.jstree", "a", $.proxy(function (e) {
				    e.preventDefault();
				    if (!this.is_loading(e.currentTarget)) {
				        this.show_contextmenu(e.currentTarget, e.pageX, e.pageY);
				    }
				}, this))
				.on("click.jstree", "a", $.proxy(function (e) {
				    if (this._data.contextmenu.visible) {
				        $.vakata.context.hide();
				    }
				}, this));
            $(document).on("context_hide.vakata", $.proxy(function () { this._data.contextmenu.visible = false; }, this));
        };
        this.teardown = function () {
            if (this._data.contextmenu.visible) {
                $.vakata.context.hide();
            }
            parent.teardown.call(this);
        };

        this.show_contextmenu = function (obj, x, y) {
            obj = this.get_node(obj);
            var s = this.settings.contextmenu,
				a = obj.children("a:visible:eq(0)"),
				o = false,
				i = false;
            if (s.show_at_node || typeof x === "undefined" || typeof y === "undefined") {
                o = a.offset();
                x = o.left;
                y = o.top + this._data.core.li_height;
            }
            if (!this.is_selected(obj)) {
                this.deselect_all();
                this.select_node(obj);
            }

            i = obj.data("jstree") && obj.data("jstree").contextmenu ? obj.data("jstree").contextmenu : s.items;
            if ($.isFunction(i)) { i = i.call(this, obj); }

            $(document).one("context_show.vakata", $.proxy(function (e, data) {
                var cls = 'jstree-contextmenu jstree-' + this.get_theme() + '-contextmenu';
                $(data.element).addClass(cls);
            }, this));
            this._data.contextmenu.visible = true;
            $.vakata.context.show(a, { 'x': x, 'y': y }, i);
            this.trigger('show_contextmenu', { "node": obj, "x": x, "y": y });
        };
    };

    // contextmenu helper
    (function ($) {
        var right_to_left = false,
			vakata_context = {
			    element: false,
			    reference: false,
			    position_x: 0,
			    position_y: 0,
			    items: [],
			    html: "",
			    is_visible: false
			};

        $.vakata.context = {
            settings: {
                hide_onmouseleave: 0,
                icons: true
            },
            _trigger: function (event_name) {
                $(document).triggerHandler("context_" + event_name + ".vakata", {
                    "reference": vakata_context.reference,
                    "element": vakata_context.element,
                    "position": {
                        "x": vakata_context.position_x,
                        "y": vakata_context.position_y
                    }
                });
            },
            _execute: function (i) {
                i = vakata_context.items[i];
                return i && !i._disabled && i.action ? i.action.call(null, {
                    "item": i,
                    "reference": vakata_context.reference,
                    "element": vakata_context.element,
                    "position": {
                        "x": vakata_context.position_x,
                        "y": vakata_context.position_y
                    }
                }) : false;
            },
            _parse: function (o, is_callback) {
                if (!o) { return false; }
                if (!is_callback) {
                    vakata_context.html = "";
                    vakata_context.items = [];
                }
                var str = "",
					sep = false,
					tmp;

                if (is_callback) { str += "<" + "ul>"; }
                $.each(o, function (i, val) {
                    if (!val) { return true; }
                    vakata_context.items.push(val);
                    if (!sep && val.separator_before) {
                        str += "<" + "li class='vakata-context-separator'><" + "a href='#' " + ($.vakata.context.settings.icons ? '' : 'style="margin-left:0px;"') + ">&#160;<" + "/a><" + "/li>";
                    }
                    sep = false;
                    str += "<" + "li class='" + (val._class || "") + (val._disabled ? " vakata-contextmenu-disabled " : "") + "'>";
                    str += "<" + "a href='#' rel='" + (vakata_context.items.length - 1) + "'>";
                    if ($.vakata.context.settings.icons) {
                        str += "<" + "ins ";
                        if (val.icon) {
                            if (val.icon.indexOf("/") !== -1) { str += " style='background:url(\"" + val.icon + "\") center center no-repeat' "; }
                            else { str += " class='" + val.icon + "' "; }
                        }
                        str += ">&#160;<" + "/ins><" + "span>&#160;<" + "/span>";
                    }
                    str += val.label + "<" + "/a>";
                    if (val.submenu) {
                        tmp = $.vakata.context._parse(val.submenu, true);
                        if (tmp) { str += tmp; }
                    }
                    str += "<" + "/li>";
                    if (val.separator_after) {
                        str += "<" + "li class='vakata-context-separator'><" + "a href='#' " + ($.vakata.context.settings.icons ? '' : 'style="margin-left:0px;"') + ">&#160;<" + "/a><" + "/li>";
                        sep = true;
                    }
                });
                str = str.replace(/<li class\='vakata-context-separator'\><\/li\>$/, "");
                if (is_callback) { str += "</ul>"; }
                if (!is_callback) { vakata_context.html = str; $.vakata.context._trigger("parse"); }
                return str.length > 10 ? str : false;
            },
            _show_submenu: function (o) {
                o = $(o);
                if (!o.length || !o.children("ul").length) { return; }
                var e = o.children("ul"),
					x = o.offset().left + o.outerWidth(),
					y = o.offset().top,
					w = e.width(),
					h = e.height(),
					dw = $(window).width() + $(window).scrollLeft(),
					dh = $(window).height() + $(window).scrollTop();
                //        -       
                if (right_to_left) {
                    o[x - (w + 10 + o.outerWidth()) < 0 ? "addClass" : "removeClass"]("vakata-context-left");
                }
                else {
                    o[x + w + 10 > dw ? "addClass" : "removeClass"]("vakata-context-right");
                }
                if (y + h + 10 > dh) {
                    e.css("bottom", "-1px");
                }
                e.show();
            },
            show: function (reference, position, data) {
                if (vakata_context.element && vakata_context.element.length) {
                    vakata_context.element.width('');
                }
                switch (!0) {
                    case (!position && !reference):
                        return false;
                    case (!!position && !!reference):
                        vakata_context.reference = reference;
                        vakata_context.position_x = position.x;
                        vakata_context.position_y = position.y;
                        break;
                    case (!position && !!reference):
                        vakata_context.reference = reference;
                        var o = reference.offset();
                        vakata_context.position_x = o.left + reference.outerHeight();
                        vakata_context.position_y = o.top;
                        break;
                    case (!!position && !reference):
                        vakata_context.position_x = position.x;
                        vakata_context.position_y = position.y;
                        break;
                }
                if (!!reference && !data && $(reference).data('vakata_contextmenu')) {
                    data = $(reference).data('vakata_contextmenu');
                }
                if ($.vakata.context._parse(data)) {
                    vakata_context.element.html(vakata_context.html);
                }
                if (vakata_context.items.length) {
                    var e = vakata_context.element,
						x = vakata_context.position_x,
						y = vakata_context.position_y,
						w = e.width(),
						h = e.height(),
						dw = $(window).width() + $(window).scrollLeft(),
						dh = $(window).height() + $(window).scrollTop();
                    if (right_to_left) {
                        x -= e.outerWidth();
                        if (x < $(window).scrollLeft() + 20) {
                            x = $(window).scrollLeft() + 20;
                        }
                    }
                    if (x + w + 20 > dw) {
                        x = dw - (w + 20);
                    }
                    if (y + h + 20 > dh) {
                        y = dh - (h + 20);
                    }

                    vakata_context.element
						.css({ "left": x, "top": y })
						.show()
						.find('a:eq(0)').focus().parent().addClass("vakata-context-hover");
                    vakata_context.is_visible = true;
                    $.vakata.context._trigger("show");
                }
            },
            hide: function () {
                if (vakata_context.is_visible) {
                    vakata_context.element.hide().find("ul").hide().end().find(':focus').blur();
                    vakata_context.is_visible = false;
                    $.vakata.context._trigger("hide");
                }
            }
        };
        $(function () {
            right_to_left = $("body").css("direction") === "rtl";
            var to = false,
				css_string = '' +
				'.vakata-context { display:none; _width:1px; } ' +
				'.vakata-context, ' +
				'.vakata-context ul { margin:0; padding:2px; position:absolute; background:#f5f5f5; border:1px solid #979797; ' +
				'	-moz-box-shadow:5px 5px 4px -4px #666666; -webkit-box-shadow:2px 2px 2px #999999; box-shadow:2px 2px 2px #999999; }' +
				'.vakata-context ul { list-style:none; left:100%; margin-top:-2.7em; margin-left:-4px; } ' +
				'.vakata-context li.vakata-context-right ul { left:auto; right:100%; margin-left:auto; margin-right:-4px; } ' +
				'.vakata-context li { list-style:none; display:inline; }' +
				'.vakata-context li a { display:block; padding:0 2em 0 2em; text-decoration:none; width:auto; color:black; white-space:nowrap; line-height:2.4em; ' +
				'	-moz-text-shadow:1px 1px 0px white; -webkit-text-shadow:1px 1px 0px white; text-shadow:1px 1px 0px white; ' +
				'	-moz-border-radius:1px; -webkit-border-radius:1px; border-radius:1px; }' +
				'.vakata-context li a:hover { position:relative; background-color:#e8eff7; ' +
				'	-moz-box-shadow:0px 0px 2px #0a6aa1; -webkit-box-shadow:0px 0px 2px #0a6aa1; box-shadow:0px 0px 2px #0a6aa1; }' +
				'.vakata-context li.vakata-context-hover > a { position:relative; background-color:#e8eff7; ' +
				'	-moz-box-shadow:0px 0px 2px #0a6aa1; -webkit-box-shadow:0px 0px 2px #0a6aa1; box-shadow:0px 0px 2px #0a6aa1; }' +
				'.vakata-context li a.vakata-context-parent { background-image:url("data:image/gif;base64,R0lGODlhCwAHAIAAACgoKP///yH5BAEAAAEALAAAAAALAAcAAAIORI4JlrqN1oMSnmmZDQUAOw=="); background-position:right center; background-repeat:no-repeat; } ' +
				'.vakata-context li.vakata-context-separator a, ' +
				'.vakata-context li.vakata-context-separator a:hover { background:white; border:0; border-top:1px solid #e2e3e3; height:1px; min-height:1px; max-height:1px; padding:0; margin:0 0 0 2.4em; border-left:1px solid #e0e0e0; _overflow:hidden; ' +
				'	-moz-text-shadow:0 0 0 transparent; -webkit-text-shadow:0 0 0 transparent; text-shadow:0 0 0 transparent; ' +
				'	-moz-box-shadow:0 0 0 transparent; -webkit-box-shadow:0 0 0 transparent; box-shadow:0 0 0 transparent; ' +
				'	-moz-border-radius:0; -webkit-border-radius:0; border-radius:0; }' +
				'.vakata-context li.vakata-contextmenu-disabled a, .vakata-context li.vakata-contextmenu-disabled a:hover { color:silver; background-color:transparent; border:0; box-shadow:0 0 0; }' +
				'' +
				'.vakata-context li a ins { text-decoration:none; display:inline-block; width:2.4em; height:2.4em; background:transparent; margin:0 0 0 -2em; } ' +
				'.vakata-context li a span { display:inline-block; width:1px; height:2.4em; background:white; margin:0 0.5em 0 0; border-left:1px solid #e2e3e3; _overflow:hidden; } ' +
				'' +
				'.vakata-context-rtl ul { left:auto; right:100%; margin-left:auto; margin-right:-4px; } ' +
				'.vakata-context-rtl li a.vakata-context-parent { background-image:url("data:image/gif;base64,R0lGODlhCwAHAIAAACgoKP///yH5BAEAAAEALAAAAAALAAcAAAINjI+AC7rWHIsPtmoxLAA7"); background-position:left center; background-repeat:no-repeat; } ' +
				'.vakata-context-rtl li.vakata-context-separator a { margin:0 2.4em 0 0; border-left:0; border-right:1px solid #e2e3e3;} ' +
				'.vakata-context-rtl li.vakata-context-left ul { right:auto; left:100%; margin-left:-4px; margin-right:auto; } ' +
				'.vakata-context-rtl li a ins { margin:0 -2em 0 0; } ' +
				'.vakata-context-rtl li a span { margin:0 0 0 0.5em; border-left-color:white; background:#e2e3e3; } ' +
				'';
            if (!$.jstree.no_css) {
                $('head').append('<style type="text/css">' + css_string + '</style>');
            }

            vakata_context.element = $("<ul class='vakata-context'></ul>");
            vakata_context.element
				.on("mouseenter", "li", function (e) {
				    e.stopImmediatePropagation();

				    if ($.contains(this, e.relatedTarget)) {
				        //   delegate mouseleave -
				        // $(this).find(".vakata-context-hover").removeClass("vakata-context-hover");
				        return;
				    }

				    if (to) { clearTimeout(to); }
				    vakata_context.element.find(".vakata-context-hover").removeClass("vakata-context-hover").end();

				    $(this)
						.siblings().find("ul").hide().end().end()
						.parentsUntil(".vakata-context", "li").addBack().addClass("vakata-context-hover");
				    $.vakata.context._show_submenu(this);
				})
				//  -   ?
				.on("mouseleave", "li", function (e) {
				    if ($.contains(this, e.relatedTarget)) { return; }
				    $(this).find(".vakata-context-hover").addBack().removeClass("vakata-context-hover");
				})
				.on("mouseleave", function (e) {
				    $(this).find(".vakata-context-hover").removeClass("vakata-context-hover");
				    if ($.vakata.context.settings.hide_onmouseleave) {
				        to = setTimeout(
							(function (t) {
							    return function () { $.vakata.context.hide(); };
							})(this), $.vakata.context.settings.hide_onmouseleave);
				    }
				})
				.on("click", "a", function (e) {
				    e.preventDefault();
				})
				.on("mouseup", "a", function (e) {
				    if (!$(this).blur().parent().hasClass("vakata-context-disabled") && $.vakata.context._execute($(this).attr("rel")) !== false) {
				        $.vakata.context.hide();
				    }
				})
				.on('keydown', 'a', function (e) {
				    var o = null;
				    switch (e.which) {
				        case 13:
				        case 32:
				            e.type = "mouseup";
				            e.preventDefault();
				            $(e.currentTarget).trigger(e);
				            break;
				        case 37:
				            if (vakata_context.is_visible) {
				                vakata_context.element.find(".vakata-context-hover").last().parents("li:eq(0)").find("ul").hide().find(".vakata-context-hover").removeClass("vakata-context-hover").end().end().children('a').focus();
				                e.stopImmediatePropagation();
				                e.preventDefault();
				            }
				            break;
				        case 38:
				            if (vakata_context.is_visible) {
				                o = vakata_context.element.find("ul:visible").addBack().last().children(".vakata-context-hover").removeClass("vakata-context-hover").prevAll("li:not(.vakata-context-separator)").first();
				                if (!o.length) { o = vakata_context.element.find("ul:visible").addBack().last().children("li:not(.vakata-context-separator)").last(); }
				                o.addClass("vakata-context-hover").children('a').focus();
				                e.stopImmediatePropagation();
				                e.preventDefault();
				            }
				            break;
				        case 39:
				            if (vakata_context.is_visible) {
				                vakata_context.element.find(".vakata-context-hover").last().children("ul").show().children("li:not(.vakata-context-separator)").removeClass("vakata-context-hover").first().addClass("vakata-context-hover").children('a').focus();
				                e.stopImmediatePropagation();
				                e.preventDefault();
				            }
				            break;
				        case 40:
				            if (vakata_context.is_visible) {
				                o = vakata_context.element.find("ul:visible").addBack().last().children(".vakata-context-hover").removeClass("vakata-context-hover").nextAll("li:not(.vakata-context-separator)").first();
				                if (!o.length) { o = vakata_context.element.find("ul:visible").addBack().last().children("li:not(.vakata-context-separator)").first(); }
				                o.addClass("vakata-context-hover").children('a').focus();
				                e.stopImmediatePropagation();
				                e.preventDefault();
				            }
				            break;
				        case 27:
				            $.vakata.context.hide();
				            e.preventDefault();
				            break;
				        default:
				            //console.log(e.which);
				            break;
				    }
				})
				.appendTo("body");

            $(document)
				.on("mousedown", function (e) {
				    if (vakata_context.is_visible && !$.contains(vakata_context.element[0], e.target)) { $.vakata.context.hide(); }
				})
				.on("context_show.vakata", function (e, data) {
				    vakata_context.element.find("li:has(ul)").children("a").addClass("vakata-context-parent");
				    if (right_to_left) {
				        vakata_context.element.addClass("vakata-context-rtl").css("direction", "rtl");
				    }
				    // also apply a RTL class?
				    vakata_context.element.find("ul").hide().end();
				});
        });
    })($);

    $.jstree.defaults.plugins.push("contextmenu");
})(jQuery);
/**
 * ### Drag'n'drop plugin
 */
(function ($) {
    $.jstree.defaults.dnd = {
        copy: true,
        open_timeout: 500
    };
    $.jstree.plugins.dnd = function (options, parent) {
        this.bind = function () {
            parent.bind.call(this);

            this.element
				.on('mousedown', 'a', $.proxy(function (e) {
				    var obj = this.get_node(e.target); // TODO: how about multiple
				    if (obj && obj !== -1 && obj.length && e.which === 1) { // TODO: think about e.which
				        this.element.trigger('mousedown.jstree');
				        return $.vakata.dnd.start(e, { 'jstree': true, 'origin': this, 'obj': obj }, '<div id="jstree-dnd" class="jstree-' + this.get_theme() + '"><i class="jstree-icon jstree-er"></i>' + this.get_text(e.currentTarget, true) + '<ins class="jstree-copy" style="display:none;">+</ins></div>');
				    }
				}, this));
        };
    };

    $(function () {
        // bind only once for all instances
        var lastmv = false,
			opento = false,
			marker = $('<div id="jstree-marker">&#160;</div>').hide().appendTo('body');

        $(document)
			.bind('dnd_start.vakata', function (e, data) {
			    lastmv = false;
			})
			.bind('dnd_move.vakata', function (e, data) {
			    if (opento) { clearTimeout(opento); }
			    if (!data.data.jstree) { return; }

			    // if we are hovering the marker image do nothing (can happen on "inside" drags)
			    if (data.event.target.id && data.event.target.id === 'jstree-marker') {
			        return;
			    }

			    var ins = $.jstree.reference(data.event.target),
					ref = false,
					off = false,
					rel = false,
					l, t, h, p, i, o;
			    // if we are over an instance
			    if (ins && ins._data && ins._data.dnd) {
			        marker.attr('class', 'jstree-' + ins.get_theme());
			        data.helper
						.children().attr('class', 'jstree-' + ins.get_theme())
						.find('.jstree-copy:eq(0)')[data.data.origin.settings.dnd.copy && (data.event.metaKey || data.event.ctrlKey) ? 'show' : 'hide']();


			        // if are hovering the container itself add a new root node
			        if (data.event.target === ins.element[0] || data.event.target === ins.get_container_ul()[0]) {
			            if (ins.check((data.data.origin.settings.dnd.copy && (data.event.metaKey || data.event.ctrlKey) ? "copy_node" : "move_node"), data.data.obj, -1, 'last')) {
			                lastmv = { 'ins': ins, 'par': -1, 'pos': 'last' };
			                marker.hide();
			                data.helper.find('.jstree-icon:eq(0)').removeClass('jstree-er').addClass('jstree-ok');
			                return;
			            }
			        }
			        else {
			            // if we are hovering a tree node
			            ref = $(data.event.target).closest('a');
			            if (ref && ref.length && ref.parent().is('.jstree-closed, .jstree-open, .jstree-leaf')) {
			                off = ref.offset();
			                rel = data.event.pageY - off.top;
			                h = ref.height();
			                if (rel < h / 3) {
			                    o = ['b', 'i', 'a'];
			                }
			                else if (rel > h - h / 3) {
			                    o = ['a', 'i', 'b'];
			                }
			                else {
			                    o = rel > h / 2 ? ['i', 'a', 'b'] : ['i', 'b', 'a'];
			                }
			                $.each(o, function (j, v) {
			                    switch (v) {
			                        case 'b':
			                            l = off.left - 6;
			                            t = off.top - 5;
			                            p = ins.get_parent(ref);
			                            i = ref.parent().index();
			                            break;
			                        case 'i':
			                            l = off.left - 2;
			                            t = off.top - 5 + h / 2 + 1;
			                            p = ref.parent();
			                            i = 0;
			                            break;
			                        case 'a':
			                            l = off.left - 6;
			                            t = off.top - 5 + h + 2;
			                            p = ins.get_parent(ref);
			                            i = ref.parent().index() + 1;
			                            break;
			                    }
			                    /*
								// TODO: moving inside, but the node is not yet loaded?
								// the check will work anyway, as when moving the node will be loaded first and checked again
								if(v === 'i' && !ins.is_loaded(p)) { }
								*/
			                    if (ins.check((data.data.origin.settings.dnd.copy && (data.event.metaKey || data.event.ctrlKey) ? "copy_node" : "move_node"), data.data.obj, p, i)) {
			                        if (v === 'i' && ref.parent().is('.jstree-closed') && ins.settings.dnd.open_timeout) {
			                            opento = setTimeout((function (x, z) { return function () { x.open_node(z); }; })(ins, ref), ins.settings.dnd.open_timeout);
			                        }
			                        lastmv = { 'ins': ins, 'par': p, 'pos': i };
			                        marker.css({ 'left': l + 'px', 'top': t + 'px' }).show();
			                        data.helper.find('.jstree-icon:eq(0)').removeClass('jstree-er').addClass('jstree-ok');
			                        o = true;
			                        return false;
			                    }
			                });
			                if (o === true) { return; }
			            }
			        }
			    }
			    lastmv = false;
			    data.helper.find('.jstree-icon').removeClass('jstree-ok').addClass('jstree-er');
			    marker.hide();
			})
			.bind('dnd_scroll.vakata', function (e, data) {
			    if (!data.data.jstree) { return; }
			    marker.hide();
			    lastmv = false;
			    data.helper.find('.jstree-icon:eq(0)').removeClass('jstree-ok').addClass('jstree-er');
			})
			.bind('dnd_stop.vakata', function (e, data) {
			    if (opento) { clearTimeout(opento); }
			    if (!data.data.jstree) { return; }
			    marker.hide();
			    if (lastmv) {
			        lastmv.ins[data.data.origin.settings.dnd.copy && (data.event.metaKey || data.event.ctrlKey) ? 'copy_node' : 'move_node']
						(data.data.obj, lastmv.par, lastmv.pos);
			    }
			})
			.bind('keyup keydown', function (e, data) {
			    data = $.vakata.dnd._get();
			    if (data.data && data.data.jstree) {
			        data.helper.find('.jstree-copy:eq(0)')[data.data.origin.settings.dnd.copy && (e.metaKey || e.ctrlKey) ? 'show' : 'hide']();
			    }
			});

        // add DND CSS
        var css_string = '' +
				'#jstree-marker { position: absolute; top:0; left:0; margin:0; padding:0; border-right:0; border-top:5px solid transparent; border-bottom:5px solid transparent; border-left:5px solid; width:0; height:0; font-size:0; line-height:0; _border-top-color:pink; _border-botton-color:pink; _filter:chroma(color=pink); } ' +
				'#jstree-dnd { line-height:16px; margin:0; padding:4px; } ' +
				'#jstree-dnd .jstree-icon, #jstree-dnd .jstree-copy { display:inline-block; text-decoration:none; margin:0 2px 0 0; padding:0; width:16px; height:16px; } ' +
				'#jstree-dnd .jstree-ok { background:green; } ' +
				'#jstree-dnd .jstree-er { background:red; } ' +
				'#jstree-dnd .jstree-copy { margin:0 2px 0 2px; }';
        if (!$.jstree.no_css) {
            $('head').append('<style type="text/css">' + css_string + '</style>');
        }
    });

    // include the dnd plugin by default
    $.jstree.defaults.plugins.push("dnd");
})(jQuery);

// helpers
(function ($) {
    $.fn.vakata_reverse = [].reverse;
    // private variable
    var vakata_dnd = {
        element: false,
        is_down: false,
        is_drag: false,
        helper: false,
        helper_w: 0,
        data: false,
        init_x: 0,
        init_y: 0,
        scroll_l: 0,
        scroll_t: 0,
        scroll_e: false,
        scroll_i: false
    };
    $.vakata.dnd = {
        settings: {
            scroll_speed: 10,
            scroll_proximity: 20,
            helper_left: 5,
            helper_top: 10,
            threshold: 5
        },
        _trigger: function (event_name, e) {
            var data = $.vakata.dnd._get();
            data.event = e;
            $(document).triggerHandler("dnd_" + event_name + ".vakata", data);
        },
        _get: function () {
            return {
                "data": vakata_dnd.data,
                "element": vakata_dnd.element,
                "helper": vakata_dnd.helper
            };
        },
        _clean: function () {
            if (vakata_dnd.helper) { vakata_dnd.helper.remove(); }
            if (vakata_dnd.scroll_i) { clearInterval(vakata_dnd.scroll_i); vakata_dnd.scroll_i = false; }
            vakata_dnd = {
                element: false,
                is_down: false,
                is_drag: false,
                helper: false,
                helper_w: 0,
                data: false,
                init_x: 0,
                init_y: 0,
                scroll_l: 0,
                scroll_t: 0,
                scroll_e: false,
                scroll_i: false
            };
            $(document).unbind("mousemove", $.vakata.dnd.drag);
            $(document).unbind("mouseup", $.vakata.dnd.stop);
        },
        _scroll: function (init_only) {
            if (!vakata_dnd.scroll_e || (!vakata_dnd.scroll_l && !vakata_dnd.scroll_t)) {
                if (vakata_dnd.scroll_i) { clearInterval(vakata_dnd.scroll_i); vakata_dnd.scroll_i = false; }
                return false;
            }
            if (!vakata_dnd.scroll_i) {
                vakata_dnd.scroll_i = setInterval($.vakata.dnd._scroll, 100);
                return false;
            }
            if (init_only === true) { return false; }

            var i = vakata_dnd.scroll_e.scrollTop(),
				j = vakata_dnd.scroll_e.scrollLeft();
            vakata_dnd.scroll_e.scrollTop(i + vakata_dnd.scroll_t * $.vakata.dnd.settings.scroll_speed);
            vakata_dnd.scroll_e.scrollLeft(j + vakata_dnd.scroll_l * $.vakata.dnd.settings.scroll_speed);
            if (i !== vakata_dnd.scroll_e.scrollTop() || j !== vakata_dnd.scroll_e.scrollLeft()) {
                $.vakata.dnd._trigger("scroll", vakata_dnd.scroll_e);
            }
        },
        start: function (e, data, html) {
            if (vakata_dnd.is_drag) { $.vakata.dnd.stop({}); }
            try {
                e.currentTarget.unselectable = "on";
                e.currentTarget.onselectstart = function () { return false; };
                if (e.currentTarget.style) { e.currentTarget.style.MozUserSelect = "none"; }
            } catch (err) { }
            vakata_dnd.init_x = e.pageX;
            vakata_dnd.init_y = e.pageY;
            vakata_dnd.data = data;
            vakata_dnd.is_down = true;
            vakata_dnd.element = e.currentTarget;
            if (html !== false) {
                vakata_dnd.helper = $("<div id='vakata-dnd'></div>").html(html).css({
                    "display": "block",
                    "margin": "0",
                    "padding": "0",
                    "position": "absolute",
                    "top": "-2000px",
                    "lineHeight": "16px",
                    "zIndex": "10000"
                });
            }
            $(document).bind("mousemove", $.vakata.dnd.drag);
            $(document).bind("mouseup", $.vakata.dnd.stop);
            return false;
        },
        drag: function (e) {
            if (!vakata_dnd.is_down) { return; }
            if (!vakata_dnd.is_drag) {
                if (
					Math.abs(e.pageX - vakata_dnd.init_x) > $.vakata.dnd.settings.threshold ||
					Math.abs(e.pageY - vakata_dnd.init_y) > $.vakata.dnd.settings.threshold
				) {
                    if (vakata_dnd.helper) {
                        vakata_dnd.helper.appendTo("body");
                        vakata_dnd.helper_w = vakata_dnd.helper.outerWidth();
                    }
                    vakata_dnd.is_drag = true;
                    $.vakata.dnd._trigger("start", e);
                }
                else { return; }
            }

            var d = false, w = false,
				dh = false, wh = false,
				dw = false, ww = false,
				dt = false, dl = false,
				ht = false, hl = false;

            vakata_dnd.scroll_t = 0;
            vakata_dnd.scroll_l = 0;
            vakata_dnd.scroll_e = false;
            var p = $(e.target)
				.parentsUntil("body").addBack().vakata_reverse()
				.filter(function () {
				    return (/^auto|scroll$/).test($(this).css("overflow")) &&
							(this.scrollHeight > this.offsetHeight || this.scrollWidth > this.offsetWidth);
				})
				.each(function () {
				    var t = $(this), o = t.offset();
				    if (this.scrollHeight > this.offsetHeight) {
				        if (o.top + t.height() - e.pageY < $.vakata.dnd.settings.scroll_proximity) { vakata_dnd.scroll_t = 1; }
				        if (e.pageY - o.top < $.vakata.dnd.settings.scroll_proximity) { vakata_dnd.scroll_t = -1; }
				    }
				    if (this.scrollWidth > this.offsetWidth) {
				        if (o.left + t.width() - e.pageX < $.vakata.dnd.settings.scroll_proximity) { vakata_dnd.scroll_l = 1; }
				        if (e.pageX - o.left < $.vakata.dnd.settings.scroll_proximity) { vakata_dnd.scroll_l = -1; }
				    }
				    if (vakata_dnd.scroll_t || vakata_dnd.scroll_l) {
				        vakata_dnd.scroll_e = $(this);
				        return false;
				    }
				});

            if (!vakata_dnd.scroll_e) {
                d = $(document); w = $(window);
                dh = d.height(); wh = w.height();
                dw = d.width(); ww = w.width();
                dt = d.scrollTop(); dl = d.scrollLeft();
                if (dh > wh && e.pageY - dt < $.vakata.dnd.settings.scroll_proximity) { vakata_dnd.scroll_t = -1; }
                if (dh > wh && wh - (e.pageY - dt) < $.vakata.dnd.settings.scroll_proximity) { vakata_dnd.scroll_t = 1; }
                if (dw > ww && e.pageX - dl < $.vakata.dnd.settings.scroll_proximity) { vakata_dnd.scroll_l = -1; }
                if (dw > ww && ww - (e.pageX - dl) < $.vakata.dnd.settings.scroll_proximity) { vakata_dnd.scroll_l = 1; }
                if (vakata_dnd.scroll_t || vakata_dnd.scroll_l) {
                    vakata_dnd.scroll_e = d;
                }
            }
            if (vakata_dnd.scroll_e) { $.vakata.dnd._scroll(true); }

            if (vakata_dnd.helper) {
                ht = parseInt(e.pageY + $.vakata.dnd.settings.helper_top, 10);
                hl = parseInt(e.pageX + $.vakata.dnd.settings.helper_left, 10);
                if (dh && ht + 25 > dh) { ht = dh - 50; }
                if (dw && hl + vakata_dnd.helper_w > dw) { hl = dw - (vakata_dnd.helper_w + 2); }
                vakata_dnd.helper.css({
                    left: hl + "px",
                    top: ht + "px"
                });
            }
            $.vakata.dnd._trigger("move", e);
        },
        stop: function (e) {
            if (vakata_dnd.is_drag) {
                $.vakata.dnd._trigger("stop", e);
            }
            $.vakata.dnd._clean();
        }
    };
})(jQuery);

/**
 * ### HTML data plugin
 */
(function ($) {
    $.jstree.defaults.html = {
        data: false,
        ajax: false
    };

    $.jstree.plugins.html = function (options, parent) {
        this.append_html_data = function (dom, data) {
            data = $(data);
            dom = this.get_node(dom);
            if (!data || !data.length || !data.is('ul, li')) {
                if (dom && dom !== -1 && dom.is('li')) {
                    dom.removeClass('jstree-closed').addClass('jstree-leaf').children('ul').remove();
                }
                return true;
            }
            if (dom === -1) { dom = this.element; }
            if (!dom.length) { return false; }
            if (!dom.children('ul').length) { dom.append('<ul />'); }
            dom.children('ul').empty().append(data.is('ul') ? data.children('li') : data);
            return true;
        };
        this._load_node = function (obj, callback) {
            var d = false,
				s = $.extend(true, {}, this.settings.html);
            obj = this.get_node(obj);
            if (!obj) { return false; }

            switch (!0) {
                // no settings - use parent
                case (!s.data && !s.ajax):
                    return parent._load_node.call(this, obj, callback);
                    // data is function
                case ($.isFunction(s.data)):
                    return s.data.call(this, obj, $.proxy(function (d) {
                        return callback.call(this, this._append_html_data(obj, d));
                    }, this));
                    // data is set, ajax is not set, or both are set, but we are dealing with root node
                case ((!!s.data && !s.ajax) || (!!s.data && !!s.ajax && obj === -1)):
                    return callback.call(this, this._append_html_data(obj, s.data));
                    // data is not set, ajax is set, or both are set, but we are dealing with a normal node
                case ((!s.data && !!s.ajax) || (!!s.data && !!s.ajax && obj !== -1)):
                    s.ajax.success = $.proxy(function (d, t, x) {
                        var s = this.settings.html.ajax;
                        if ($.isFunction(s.success)) {
                            d = s.success.call(this, d, t, x) || d;
                        }
                        callback.call(this, this._append_html_data(obj, d));
                    }, this);
                    s.ajax.error = $.proxy(function (x, t, e) {
                        var s = this.settings.html.ajax;
                        if ($.isFunction(s.error)) {
                            s.error.call(this, x, t, e);
                        }
                        callback.call(this, false);
                    }, this);
                    if (!s.ajax.dataType) { s.ajax.dataType = "html"; }
                    if ($.isFunction(s.ajax.url)) { s.ajax.url = s.ajax.url.call(this, obj); }
                    if ($.isFunction(s.ajax.data)) { s.ajax.data = s.ajax.data.call(this, obj); }
                    return $.ajax(s.ajax);
            }
        };
    };
    // include the html plugin by default
    $.jstree.defaults.plugins.push("html");
})(jQuery);
/**
 * ### JSON data plugin
 */
(function ($) {
    $.jstree.defaults.json = {
        data: false,
        ajax: false,
        progressive_render: false, // get_json, data on each node
        progressive_unload: false
    };

    $.jstree.plugins.json = function (options, parent) {
        this.bind = function () {
            parent.bind.call(this);
            this.element
				.bind("ready.jstree", $.proxy(function () {
				    this.element
						.bind("after_close.jstree", $.proxy(function (e, data) {
						    var t = $(data.node);
						    if (this.settings.json.progressive_unload && t.find('.jstree-clicked:eq(0)').length === 0) {
						        t.data('jstree').children = this.get_json(t)[0].children;
						        t.children("ul").remove();
						    }
						}, this));
				}, this));
        };
        this.parse_json = function (node) {
            var s = this.settings.json;
            if (s.progressive_render && $.isArray(node.children) && !this._json_has_selected(node.children)) {
                if (!node.data) { node.data = {}; }
                if (!node.data.jstree) { node.data.jstree = {}; }
                node.data.jstree.children = node.children;
                node.children = true;
            }
            return parent.parse_json.call(this, node);
        };
        this._json_has_selected = function (data) {
            var r = false;
            for (var i = 0, j = data.length; i < j; i++) {
                if (data[i].data && data[i].data.jstree && data[i].data.jstree.selected) {
                    r = true;
                }
                else if (data[i].children) {
                    r = r || this._json_has_selected(data[i].children);
                }
                else {
                    r = false;
                }
                if (r === true) { break; }
            }
            return r;
        };
        this._append_json_data = function (dom, data) {
            dom = this.get_node(dom);
            if (dom === -1) { dom = this.element; }
            data = this.parse_json(data);
            if (!dom.length) { return false; }
            if (!data) {
                if (dom && dom.is('li')) {
                    dom.removeClass('jstree-closed').addClass('jstree-leaf').children('ul').remove();
                }
                return true;
            }
            if (!dom.children('ul').length) { dom.append('<ul />'); }
            dom.children('ul').empty().append(data.is('li') ? data : data.children('li'));
            return true;
        };
        this._load_node = function (obj, callback) {
            var d = false,
				s = $.extend(true, {}, this.settings.json);
            obj = this.get_node(obj);
            if (!obj) { return false; }

            switch (!0) {
                // root node with data
                case (obj === -1 && this.get_container().data('jstree') && $.isArray(this.get_container().data('jstree').children)):
                    d = this.element.data('jstree').children;
                    this.get_container().data('jstree').children = null;
                    return callback.call(this, this._append_json_data(obj, d));
                    // normal node with data
                case (obj !== -1 && obj.length && obj.data('jstree') && $.isArray(obj.data('jstree').children)):
                    d = obj.data('jstree').children;
                    obj.data('jstree').children = null;
                    return callback.call(this, this._append_json_data(obj, d));
                    // no settings - use parent
                case (!s.data && !s.ajax):
                    return parent._load_node.call(this, obj, callback);
                    // data is function
                case ($.isFunction(s.data)):
                    return s.data.call(this, obj, $.proxy(function (d) {
                        return callback.call(this, this._append_json_data(obj, d));
                    }, this));
                    // data is set, ajax is not set, or both are set, but we are dealing with root node
                case ((!!s.data && !s.ajax) || (!!s.data && !!s.ajax && obj === -1)):
                    return callback.call(this, this._append_json_data(obj, s.data));
                    // data is not set, ajax is set, or both are set, but we are dealing with a normal node
                case ((!s.data && !!s.ajax) || (!!s.data && !!s.ajax && obj !== -1)):
                    s.ajax.success = $.proxy(function (d, t, x) {
                        var s = this.settings.json.ajax;
                        if ($.isFunction(s.success)) {
                            d = s.success.call(this, d, t, x) || d;
                        }
                        callback.call(this, this._append_json_data(obj, d));
                    }, this);
                    s.ajax.error = $.proxy(function (x, t, e) {
                        var s = this.settings.json.ajax;
                        if ($.isFunction(s.error)) {
                            s.error.call(this, x, t, e);
                        }
                        callback.call(this, false);
                    }, this);
                    if (!s.ajax.dataType) { s.ajax.dataType = "json"; }
                    if ($.isFunction(s.ajax.url)) { s.ajax.url = s.ajax.url.call(this, obj); }
                    if ($.isFunction(s.ajax.data)) { s.ajax.data = s.ajax.data.call(this, obj); }
                    return $.ajax(s.ajax);
            }
        };
    };
    // include the json plugin by default
    $.jstree.defaults.plugins.push("json");
})(jQuery);
/**
 * ### Rules plugin
 */
(function ($) {
    var last_depth_node = false,
		last_depth_value = 0;

    $.jstree.defaults.rules = {
        'check_max_depth': true,
        'check_max_children': true,
        'check_valid_children': true,
        'types': {}
    };

    $.jstree.plugins.rules = function (options, parent) {
        this.bind = function () {
            parent.bind.call(this);

            this.element.on('load_node.jstree', $.proxy(function (e, data) {
                if (this.settings.rules.check_max_depth) {
                    var o = data.node === -1 ? this.element : data.node,
						t = this,
						f = function () {
						    if (t.apply_max_depth(this)) {
						        o = o.not(this);
						    }
						};
                    if (!this.apply_max_depth(o)) {
                        while (o.length) {
                            o = o.children("ul").children("li");
                            o.each(f);
                        }
                    }
                }
            }, this));
        };
        this.apply_max_depth = function (obj) {
            obj = this.get_node(obj);
            if (!obj || !obj.length) {
                return false;
            }
            obj = obj === -1 ? this.element : obj;
            var d = obj.data('jstree'),
				t = {},
				f1 = function () {
				    t = $(this).data('jstree') || {};
				    t.max_depth = 0;
				    $(this).data('jstree', t);
				},
				f2 = function () {
				    t = $(this).data('jstree') || {};
				    t.max_depth = t.max_depth && t.max_depth !== -1 ? Math.min(t.max_depth, d) : d;
				    $(this).data('jstree', t);
				};
            if (d && typeof d.max_depth !== 'undefined' && d.max_depth !== -1) {
                d = d.max_depth;
                while (obj.length > 0) {
                    obj = obj.children("ul").children("li");
                    d = Math.max(d - 1, 0);
                    if (d === 0) {
                        obj.find('li').addBack().each(f1);
                        break;
                    }
                    obj.each(f2);
                }
                return true;
            }
            return false;
        };
        this.get_rules = function (obj) {
            obj = this.get_node(obj);
            if (obj === -1) {
                obj = this.element;
                obj = obj.data('jstree');
                return {
                    'type': false,
                    'max_depth': obj && obj.max_depth ? obj.max_depth : -1,
                    'max_children': obj && obj.max_children ? obj.max_children : -1,
                    'valid_children': obj && obj.valid_children ? obj.valid_children : -1
                };
            }
            if (!obj || !obj.length) { return false; }

            var s = this.settings.rules,
				t = this.get_type(obj),
				r = {
				    'type': t,
				    'max_depth': -1,
				    'max_children': -1,
				    'valid_children': -1
				};
            obj = obj.data('jstree');
            if (t && s[t]) {
                if (s[t].max_depth) { r.max_depth = s[t].max_depth; }
                if (s[t].max_children) { r.max_children = s[t].max_children; }
                if (s[t].valid_children) { r.valid_children = s[t].valid_children; }
            }
            if (obj && typeof obj.max_children !== 'undefined') { r.max_children = obj.max_children; }
            if (obj && typeof obj.valid_children !== 'undefined') { r.valid_children = obj.valid_children; }
            if (obj && typeof obj.max_depth !== 'undefined' && (r.max_depth === -1 || (obj.max_depth !== -1 && obj.max_depth < r.max_depth))) {
                r.max_depth = obj.max_depth;
            }

            return r;
        };
        this.get_type = function (obj) {
            obj = this.get_node(obj);
            if (obj === -1) { obj = this.element; }
            if (!obj || !obj.length) { return false; }
            obj = obj.data('jstree');
            return obj && obj.type ? obj.type : false;
        };
        this.set_type = function (obj, type) {
            obj = this.get_node(obj);
            if (obj === -1) { obj = this.element; }
            if (!obj || !obj.length) { return false; }
            var d = obj.data('jstree');
            if (!d) { d = {}; }
            d.type = type;
            obj.data('jstree', d);
            return true;
        };
        this.check = function (chk, obj, par, pos) {
            if (parent.check.call(this, chk, obj, par, pos) === false) { return false; }
            var r = false,
				s = this.settings.rules,
				t = this,
				o = false,
				d = 0;

            switch (chk) {
                case "create_node":
                case "move_node":
                case "copy_node":
                    if (s.check_max_children || s.check_valid_children || s.check_max_depth) {
                        r = this.get_rules(par);
                    }
                    else {
                        return true;
                    }
                    if (s.check_max_children) {
                        if (typeof r.max_children !== 'undefined' && r.max_children !== -1) {
                            if (par.children("ul").children("li").not(chk === 'move_node' ? obj : null).length + obj.length > r.max_children) {
                                return false;
                            }
                        }
                    }
                    if (s.check_valid_children) {
                        if (typeof r.valid_children !== 'undefined' && r.valid_children !== -1) {
                            if (!$.isArray(r.valid_children)) { return false; }
                            obj.each(function () {
                                if ($.inArray(t.get_type(this), r.valid_children) === -1) {
                                    t = false;
                                    return false;
                                }
                            });
                            if (t === false) {
                                return false;
                            }
                        }
                    }
                    if (s.check_max_depth && r.max_depth !== -1) {
                        d = 0;
                        do {
                            d++;
                            obj = obj.children("ul").children("li");
                        } while (obj.length && chk !== 'create_node');
                        if (r.max_depth - d < 0) { return false; }
                    }
                    break;
            }
            return true;
        };
    };

    // include the rules plugin by default
    $.jstree.defaults.plugins.push("rules");
})(jQuery);
/**
 * ### Search plugin
 */
(function ($) {
    $.jstree.defaults.search = {
        ajax: false,
        case_sensitive: false,
        show_only_matches: true
    };

    $.jstree.plugins.search = function (options, parent) {
        this.bind = function () {
            parent.bind.call(this);

            this._data.search.str = "";
            this._data.search.res = $();

            if (this.settings.search.show_only_matches) {
                this.element
					.on("search.jstree", function (e, data) {
					    if (data.nodes.length) {
					        $(this).children("ul").find("li").hide().removeClass("jstree-last");
					        data.nodes.parentsUntil(".jstree").addBack().show()
								.filter("ul").each(function () { $(this).children("li:visible").eq(-1).addClass("jstree-last"); });
					    }
					})
					.on("clear_search.jstree", function (e, data) {
					    if (data.nodes.length) {
					        $(this).children("ul").find("li").css("display", "").end().end().jstree("correct_node", -1, true);
					    }
					});
            }
        };
        this.search = function (str, skip_async) {
            if (str === false || $.trim(str) === "") {
                return this.clear_search();
            }
            var s = this.settings.search,
				t = this;

            if (!skip_async && s.ajax !== false && this.get_container_ul().find("li.jstree-closed:not(:has(ul)):eq(0)").length > 0) {
                s.ajax.success = $.proxy(function (d, t, x) {
                    var s = this.settings.search.ajax;
                    if ($.isFunction(s.success)) {
                        d = s.success.call(this, d, t, x) || d;
                    }
                    this._search_open(d, str);
                }, this);
                s.ajax.error = $.proxy(function (x, t, e) {
                    var s = this.settings.search.ajax;
                    if ($.isFunction(s.error)) {
                        s.error.call(this, x, t, e);
                    }
                    // do stuff
                }, this);
                if (!s.ajax.dataType) {
                    s.ajax.dataType = "json";
                }
                if ($.isFunction(s.ajax.url)) {
                    s.ajax.url = s.ajax.url.call(this, str);
                }
                if ($.isFunction(s.ajax.data)) {
                    s.ajax.data = s.ajax.data.call(this, str);
                }
                else {
                    if (!s.ajax.data) { s.ajax.data = {}; }
                    s.ajax.data.str = str;
                }
                $.ajax(s.ajax);
                return;
            }
            if (this._data.search.res.length) {
                this.clear_search();
            }
            this._data.search.str = str;
            this._data.search.res = this._search(str);

            this._data.search.res.addClass("jstree-search").parent().parentsUntil(".jstree", ".jstree-closed").each(function () {
                t.open_node(this, false, 0);
            });
            this.trigger('search', { nodes: this._data.search.res, str: str });
        };
        this.clear_search = function () {
            this._data.search.res.removeClass("jstree-search");
            this.trigger('clear_search', { 'nodes': this._data.search.res, str: this._data.search.str });
            this._data.search.str = "";
            this._data.search.res = $();
        };
        this._search = function (str) {
            str = this.settings.search.case_sensitive ? str : str.toLowerCase();

            if (this.settings.json && this.settings.json.progressive_render) {
                this.get_container_ul().find("li.jstree-closed:not(:has(ul))").each($.proxy(function (i, v) {
                    if (this._search_data(str, $(v).data('jstree'))) {
                        this.open_node(v, false, 0);
                    }
                }, this));
            }
            return this.element.find(".jstree-anchor:" + (this.settings.search.case_sensitive ? 'contains' : 'vakata_icontains') + "(" + str + ")");
        };
        this._search_data = function (str, d) {
            if (!d || !d.children || !$.isArray(d.children)) {
                return false;
            }
            var res = false;
            $.each(d.children, $.proxy(function (i, v) {
                var t = typeof v === "string" ? v : v.title,
					u;
                t = this.settings.search.case_sensitive ? t : t.toLowerCase();
                u = t.indexOf(str) !== -1 || this._search_data(str, v);
                if (u) {
                    if (!d.data) {
                        d.data = {};
                    }
                    if (!d.data.jstree) {
                        d.data.jstree = {};
                    }
                    d.data.jstree.opened = true;
                }
                res = res || u;
            }, this));
            return res;
        };
        this._search_open = function (d, str) {
            var res = true,
				t = this;
            $.each(d.concat([]), function (i, v) {
                v = document.getElementById(v);
                if (v) {
                    if (t.is_loaded(v)) {
                        if (t.is_closed(v)) {
                            t.open_node(v, false, 0);
                        }
                        $.vakata.array_remove(d, i);
                    }
                    else {
                        if (!t.is_loading(v)) {
                            t.open_node(v, $.proxy(function () { this._search_open(d, str); }, t), 0);
                        }
                        res = false;
                    }
                }
            });
            if (res) {
                this.search(str, true);
            }
        };
    };

    // helper for case-insensitive search
    $.expr[':'].vakata_icontains = $.expr.createPseudo(function (search) {
        return function (a) {
            return (a.textContent || a.innerText || "").toLowerCase().indexOf(search.toLowerCase()) >= 0;
        };
    });

    // include the json plugin by default
    $.jstree.defaults.plugins.push("search");
})(jQuery);

/**
 * ### Sort plugin
 */
(function ($) {
    $.jstree.defaults.sort = function (a, b) {
        return this.get_text(a, true) > this.get_text(b, true) ? 1 : -1;
    };
    $.jstree.plugins.sort = function (options, parent) {
        this.bind = function () {
            parent.bind.call(this);

            this.element
				.on("load_node.jstree", $.proxy(function (e, data) {
				    var obj = this.get_node(data.node);
				    obj = obj === -1 ? this.get_container_ul() : obj.children("ul");
				    this.sort(obj, true);
				}, this))
				.on("rename_node.jstree create_node.jstree", $.proxy(function (e, data) {
				    this.sort(data.node.parent(), false);
				}, this))
				.on("move_node.jstree copy_node.jstree", $.proxy(function (e, data) {
				    var m = data.parent === -1 ? this.get_container_ul() : data.parent.children('ul');
				    this.sort(m, false);
				}, this));
        };
        this.sort = function (obj, deep) {
            var s = this.settings.sort,
				t = this;
            obj.append($.makeArray(obj.children("li")).sort($.proxy(s, t)));
            obj.children('li').each(function () { t.correct_node(this, false); });
            if (deep) {
                obj.children("li").children("ul").each(function () { t.sort($(this)); });
                t.correct_node(obj.children('li'), true);
            }
        };
    };

    // include the sort plugin by default
    $.jstree.defaults.plugins.push("sort");
})(jQuery);
/**
 * ### State plugin
 */
(function ($) {
    var to = false;

    $.jstree.defaults.state = {
        key: 'jstree',
        events: 'changed.jstree open_node.jstree close_node.jstree',
        ttl: false
    };
    $.jstree.plugins.state = function (options, parent) {
        this.bind = function () {
            parent.bind.call(this);

            this.element
				.on("ready.jstree", $.proxy(function (e, data) {
				    this.element.one("restore_state.jstree set_state.jstree", $.proxy(function () {
				        this.element.on(this.settings.state.events, $.proxy(function () {
				            if (to) { clearTimeout(to); }
				            to = setTimeout($.proxy(function () { this.save_state(); }, this), 100);
				        }, this));
				    }, this));
				    this.restore_state();
				}, this));
        };
        this.save_state = function () {
            $.vakata.storage.set(this.settings.state.key, this.get_state(), this.settings.state.ttl);
        };
        this.restore_state = function () {
            var k = $.vakata.storage.get(this.settings.state.key);

            if (!!k) { this.set_state(k); }
            this.trigger('restore_state', { 'state': k });
        };
        this.clear_state = function () {
            return $.vakata.storage.del(this.settings.state.key);
        };
    };

    // include the state plugin by default
    // $.jstree.defaults.plugins.push("state");
})(jQuery);

(function ($, document, undefined) {
    var raw = function (s) { return s; },
		decoded = function (s) { return decodeURIComponent(s.replace(/\+/g, ' ')); };
    var config = $.vakata.cookie = function (key, value, options) {
        // write
        if (value !== undefined) {
            options = $.extend({}, config.defaults, options);

            if (value === null) {
                options.expires = -1;
            }

            if (typeof options.expires === 'number') {
                var days = options.expires, t = options.expires = new Date();
                t.setDate(t.getDate() + days);
            }

            value = config.json ? $.vakata.json.encode(value) : String(value);

            return (document.cookie = [
				encodeURIComponent(key), '=', config.raw ? value : encodeURIComponent(value),
				options.expires ? '; expires=' + options.expires.toUTCString() : '', // use expires attribute, max-age is not supported by IE
				options.path ? '; path=' + options.path : '',
				options.domain ? '; domain=' + options.domain : '',
				options.secure ? '; secure' : ''
            ].join(''));
        }
        // read
        var decode = config.raw ? raw : decoded;
        var cookies = document.cookie.split('; ');
        for (var i = 0, l = cookies.length; i < l; i++) {
            var parts = cookies[i].split('=');
            if (decode(parts.shift()) === key) {
                var cookie = decode(parts.join('='));
                return config.json ? $.vakata.json.decode(cookie) : cookie;
            }
        }
        return null;
    };
    config.defaults = {};
    $.vakata.removeCookie = function (key, options) {
        if ($.cookie(key) !== null) {
            $.cookie(key, null, options);
            return true;
        }
        return false;
    };
})(jQuery, document);

(function ($) {
    var _storage = {},
		_storage_service = { jStorage: "{}" },
		_storage_elm = null,
		_storage_size = 0,
		json_encode = $.vakata.json.encode,
		json_decode = $.vakata.json.decode,
		_backend = false,
		_ttl_timeout = false;

    function _init() {
        var localStorageReallyWorks = false;
        if ("localStorage" in window) {
            try {
                window.localStorage.setItem('_tmptest', 'tmpval');
                localStorageReallyWorks = true;
                window.localStorage.removeItem('_tmptest');
            } catch (BogusQuotaExceededErrorOnIos5) {
                // Thanks be to iOS5 Private Browsing mode which throws
                // QUOTA_EXCEEDED_ERRROR DOM Exception 22.
            }
        }

        if (localStorageReallyWorks) {
            try {
                if (window.localStorage) {
                    _storage_service = window.localStorage;
                    _backend = "localStorage";
                }
            } catch (E3) {/* Firefox fails when touching localStorage and cookies are disabled */ }
        }
        else if ("globalStorage" in window) {
            try {
                if (window.globalStorage) {
                    _storage_service = window.globalStorage[window.location.hostname];
                    _backend = "globalStorage";
                }
            } catch (E4) {/* Firefox fails when touching localStorage and cookies are disabled */ }
        }
        else {
            _storage_elm = document.createElement('link');
            if (_storage_elm.addBehavior) {
                _storage_elm.style.behavior = 'url(#default#userData)';
                document.getElementsByTagName('head')[0].appendChild(_storage_elm);
                try {
                    _storage_elm.load("jStorage");
                    var data = "{}";
                    data = _storage_elm.getAttribute("jStorage");
                    _storage_service.jStorage = data;
                    _backend = "userDataBehavior";
                } catch (E5) { }
            }
            if (
				!_backend && (
					!!$.vakata.cookie('__vjstorage') ||
					($.vakata.cookie('__vjstorage', '{}', { 'expires': 365 }) && $.vakata.cookie('__vjstorage') === '{}')
				)
			) {
                _storage_elm = null;
                _storage_service.jStorage = $.vakata.cookie('__vjstorage');
                _backend = "cookie";
            }

            if (!_backend) {
                _storage_elm = null;
                return;
            }
        }
        _load_storage();
        _handleTTL();
    }

    function _load_storage() {
        if (_storage_service.jStorage) {
            try {
                _storage = json_decode(String(_storage_service.jStorage));
            } catch (E6) { _storage_service.jStorage = "{}"; }
        } else {
            _storage_service.jStorage = "{}";
        }
        _storage_size = _storage_service.jStorage ? String(_storage_service.jStorage).length : 0;
    }

    function _save() {
        try {
            _storage_service.jStorage = json_encode(_storage);
            if (_backend === 'userDataBehavior') {
                _storage_elm.setAttribute("jStorage", _storage_service.jStorage);
                _storage_elm.save("jStorage");
            }
            if (_backend === 'cookie') {
                $.vakata.cookie('__vjstorage', _storage_service.jStorage, { 'expires': 365 });
            }
            _storage_size = _storage_service.jStorage ? String(_storage_service.jStorage).length : 0;
        } catch (E7) { /* probably cache is full, nothing is saved this way*/ }
    }

    function _checkKey(key) {
        if (!key || (typeof key !== "string" && typeof key !== "number")) {
            throw new TypeError('Key name must be string or numeric');
        }
        if (key === "__jstorage_meta") {
            throw new TypeError('Reserved key name');
        }
        return true;
    }

    function _handleTTL() {
        var curtime = +new Date(),
			i,
			TTL,
			nextExpire = Infinity,
			changed = false;

        if (_ttl_timeout !== false) {
            clearTimeout(_ttl_timeout);
        }
        if (!_storage.__jstorage_meta || typeof _storage.__jstorage_meta.TTL !== "object") {
            return;
        }
        TTL = _storage.__jstorage_meta.TTL;
        for (i in TTL) {
            if (TTL.hasOwnProperty(i)) {
                if (TTL[i] <= curtime) {
                    delete TTL[i];
                    delete _storage[i];
                    changed = true;
                }
                else if (TTL[i] < nextExpire) {
                    nextExpire = TTL[i];
                }
            }
        }

        // set next check
        if (nextExpire !== Infinity) {
            _ttl_timeout = setTimeout(_handleTTL, nextExpire - curtime);
        }
        // save changes
        if (changed) {
            _save();
        }
    }

    /*
		Variable: $.vakata.storage
		*object* holds all storage related functions and properties.
	*/
    $.vakata.storage = {
        /*
			Variable: $.vakata.storage.version
			*string* the version of jstorage used HEAVILY MODIFIED
		*/
        version: "0.3.0",
        /*
			Function: $.vakata.storage.set
			Set a key to a value

			Parameters:
				key - the key
				value - the value

			Returns:
				_value_
		*/
        set: function (key, value, ttl) {
            _checkKey(key);
            if (typeof value === "object") {
                value = json_decode(json_encode(value));
            }
            _storage[key] = value;
            _save();
            if (ttl && parseInt(ttl, 10)) {
                $.vakata.storage.setTTL(key, parseInt(ttl, 10));
            }
            return value;
        },
        /*
			Function: $.vakata.storage.get
			Get a value by key.

			Parameters:
				key - the key
				def - the value to return if _key_ is not found

			Returns:
				The found value, _def_ if key not found or _null_ if _def_ is not supplied.
		*/
        get: function (key, def) {
            _checkKey(key);
            if (key in _storage) {
                return _storage[key];
            }
            return typeof (def) === 'undefined' ? null : def;
        },
        /*
			Function: $.vakata.storage.del
			Remove a key.

			Parameters:
				key - the key

			Returns:
				*boolean*
		*/
        del: function (key) {
            _checkKey(key);
            if (key in _storage) {
                delete _storage[key];

                if (_storage.__jstorage_meta && typeof _storage.__jstorage_meta.TTL === "object" && key in _storage.__jstorage_meta.TTL) {
                    delete _storage.__jstorage_meta.TTL[key];
                }
                _save();
                return true;
            }
            return false;
        },

        setTTL: function (key, ttl) {
            var curtime = +new Date();

            _checkKey(key);
            ttl = Number(ttl) || 0;
            if (key in _storage) {
                if (!_storage.__jstorage_meta) {
                    _storage.__jstorage_meta = {};
                }
                if (!_storage.__jstorage_meta.TTL) {
                    _storage.__jstorage_meta.TTL = {};
                }
                if (ttl > 0) {
                    _storage.__jstorage_meta.TTL[key] = curtime + ttl;
                }
                else {
                    delete _storage.__jstorage_meta.TTL[key];
                }
                _save();
                _handleTTL();
                return true;
            }
            return false;
        },
        getTTL: function (key) {
            var curtime = +new Date(), ttl;
            _checkKey(key);
            if (key in _storage && _storage.__jstorage_meta.TTL && _storage.__jstorage_meta.TTL[key]) {
                ttl = _storage.__jstorage_meta.TTL[key] - curtime;
                return ttl || 0;
            }
            return 0;
        },

        /*
			Function: $.vakata.storage.flush
			Empty the storage.

			Returns:
				_true_
		*/
        flush: function () {
            _storage = {};
            _save();
            // try{ window.localStorage.clear(); } catch(E8) { }
            return true;
        },
        /*
			Function: $.vakata.storage.storageObj
			Get a read only copy of the whole storage.

			Returns:
				*object*
		*/
        storageObj: function () {
            return $.extend(true, {}, _storage);
        },
        /*
			Function: $.vakata.storage.index
			Get an array of all the set keys in the storage.

			Returns:
				*array*
		*/
        index: function () {
            var index = [], i;
            $.each(_storage, function (i, v) { if (i !== "__jstorage_meta") { index.push(i); } });
            return index;
        },
        /*
			Function: $.vakata.storage.storageSize
			Get the size of all items in the storage in bytes.

			Returns:
				*number*
		*/
        storageSize: function () {
            return _storage_size;
        },
        /*
			Function: $.vakata.storage.currentBackend
			Get the current backend used.

			Returns:
				*string*
		*/
        currentBackend: function () {
            return _backend;
        },
        /*
			Function: $.vakata.storage.storageAvailable
			See if storage functionality is available.

			Returns:
				*boolean*
		*/
        storageAvailable: function () {
            return !!_backend;
        }
    };
    _init();
})(jQuery);

/**
 * ### Unique plugin
 */
(function ($) {
    $.jstree.plugins.unique = function (options, parent) {
        // TODO: think about an option to work with HTML or not?
        // TODO: add callback - to handle errors and for example types
        this.check = function (chk, obj, par, pos) {
            if (parent.check.call(this, chk, obj, par, pos) === false) { return false; }

            par = par === -1 ? this.element : par;
            var n = chk === "rename_node" ? $('<div />').html(pos).text() : this.get_text(obj, true),
				c = [],
				t = this;
            par.children('ul').children('li').each(function () { c.push(t.get_text(this, true)); });
            switch (chk) {
                case "delete_node":
                    return true;
                case "rename_node":
                case "copy_node":
                    return ($.inArray(n, c) === -1);
                case "move_node":
                    return (par.children('ul').children('li').index(obj) !== -1 || $.inArray(n, c) === -1);
            }
            return true;
        };
    };

    // include the unique plugin by default
    $.jstree.defaults.plugins.push("unique");
})(jQuery);

/**
 * ### Wholerow plugin
 */
(function ($) {
    $.jstree.plugins.wholerow = function (options, parent) {
        this.bind = function () {
            parent.bind.call(this);

            this.element
				.on('ready.jstree set_state.jstree', $.proxy(function () {
				    this.hide_dots();
				}, this))
				.on("ready.jstree", $.proxy(function () {
				    this.get_container_ul().addClass('jstree-wholerow-ul');
				}, this))
				.on("deselect_all.jstree", $.proxy(function (e, data) {
				    this.element.find('.jstree-wholerow-clicked').removeClass('jstree-wholerow-clicked');
				}, this))
				.on("changed.jstree ", $.proxy(function (e, data) {
				    this.element.find('.jstree-wholerow-clicked').removeClass('jstree-wholerow-clicked');
				    data.selected.children('.jstree-wholerow').addClass('jstree-wholerow-clicked');
				}, this))
				.on("hover_node.jstree dehover_node.jstree", $.proxy(function (e, data) {
				    this.element.find('.jstree-wholerow-hovered').removeClass('jstree-wholerow-hovered');
				    if (e.type === "hover_node") {
				        data.node.each(function () {
				            $(this).children('.jstree-wholerow').addClass('jstree-wholerow-hovered');
				        });
				    }
				}, this))
				.on("contextmenu.jstree", ".jstree-wholerow", $.proxy(function (e) {
				    if (typeof this._data.contextmenu !== 'undefined') {
				        e.preventDefault();
				        $(e.currentTarget).closest("li").children("a:eq(0)").trigger('contextmenu', e);
				    }
				}, this))
				.on("click.jstree", ".jstree-wholerow", function (e) {
				    e.stopImmediatePropagation();
				    $(e.currentTarget).closest("li").children("a:eq(0)").trigger('click', e);
				})
				.on("click.jstree", ".jstree-leaf > .jstree-ocl", $.proxy(function (e) {
				    e.stopImmediatePropagation();
				    $(e.currentTarget).closest("li").children("a:eq(0)").trigger('click', e);
				}, this))
				.on("mouseover.jstree", "li", $.proxy(function (e) {
				    e.stopImmediatePropagation();
				    if ($(e.currentTarget).closest('li').children(".jstree-hovered, .jstree-clicked").length) {
				        return false;
				    }
				    this.hover_node(e.currentTarget);
				    return false;
				}, this))
				.on("mouseleave.jstree", "li", $.proxy(function (e) {
				    this.dehover_node(e.currentTarget);
				}, this));
        };
        this.teardown = function () {
            this.element.find(".jstree-wholerow").remove();
            parent.teardown.call(this);
        },
		this.clean_node = function (obj) {
		    obj = parent.clean_node.call(this, obj);
		    var t = this;
		    return obj.each(function () {
		        var o = $(this);
		        if (!o.children(".jstree-wholerow").length) {
		            o.prepend("<div class='jstree-wholerow' style='position:absolute; height:" + t._data.core.li_height + "px;' unselectable='on'>&#160;</div>");
		        }
		    });
		};
    };

    $(function () {
        var css_string = '' +
				'.jstree .jstree-wholerow-ul { position:relative; display:inline-block; min-width:100%; }' +
				'.jstree-wholerow-ul li > a, .jstree-wholerow-ul li > i { position:relative; }' +
				'.jstree-wholerow-ul .jstree-wholerow { width:100%; cursor:pointer; position:absolute; left:0; user-select:none;-webkit-user-select:none; -moz-user-select:none; -ms-user-select:none; }';
        if (!$.jstree.no_css) {
            $('head').append('<style type="text/css">' + css_string + '</style>');
        }
    });

    // include the wholerow plugin by default
    // $.jstree.defaults.plugins.push("wholerow");
})(jQuery);

/**
 * ### XML data plugin
 */
(function ($) {
    var xsl = {
        'nest': '' +
			'<' + '?xml version="1.0" encoding="utf-8" ?>' +
			'<' + 'xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" >' +
			'<' + 'xsl:output method="html" encoding="utf-8" omit-xml-declaration="yes" standalone="no" indent="no" media-type="text/html" />' +
			'<' + 'xsl:template match="/">' +
			'	<' + 'xsl:call-template name="nodes">' +
			'		<' + 'xsl:with-param name="node" select="/root" />' +
			'	<' + '/xsl:call-template>' +
			'<' + '/xsl:template>' +
			'<' + 'xsl:template name="nodes">' +
			'	<' + 'xsl:param name="node" />' +
			'	<' + 'ul>' +
			'	<' + 'xsl:for-each select="$node/item">' +
			'		<' + 'xsl:variable name="children" select="count(./item) &gt; 0" />' +
			'		<' + 'li>' +
			'			<' + 'xsl:for-each select="@*"><' + 'xsl:attribute name="{name()}"><' + 'xsl:value-of select="." /><' + '/xsl:attribute><' + '/xsl:for-each>' +
			'			<' + 'a>' +
			'				<' + 'xsl:for-each select="./content/@*"><' + 'xsl:attribute name="{name()}"><' + 'xsl:value-of select="." /><' + '/xsl:attribute><' + '/xsl:for-each>' +
			'				<' + 'xsl:copy-of select="./content/child::node()" />' +
			'			<' + '/a>' +
			'			<' + 'xsl:if test="$children"><' + 'xsl:call-template name="nodes"><' + 'xsl:with-param name="node" select="current()" /><' + '/xsl:call-template><' + '/xsl:if>' +
			'		<' + '/li>' +
			'	<' + '/xsl:for-each>' +
			'	<' + '/ul>' +
			'<' + '/xsl:template>' +
			'<' + '/xsl:stylesheet>',
        'flat': '' +
			'<' + '?xml version="1.0" encoding="utf-8" ?>' +
			'<' + 'xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" >' +
			'<' + 'xsl:output method="html" encoding="utf-8" omit-xml-declaration="yes" standalone="no" indent="no" media-type="text/xml" />' +
			'<' + 'xsl:template match="/">' +
			'	<' + 'ul>' +
			'	<' + 'xsl:for-each select="//item[not(@parent_id) or @parent_id=0 or not(@parent_id = //item/@id)]">' + /* the last `or` may be removed */
			'		<' + 'xsl:call-template name="nodes">' +
			'			<' + 'xsl:with-param name="node" select="." />' +
			'		<' + '/xsl:call-template>' +
			'	<' + '/xsl:for-each>' +
			'	<' + '/ul>' +
			'<' + '/xsl:template>' +
			'<' + 'xsl:template name="nodes">' +
			'	<' + 'xsl:param name="node" />' +
			'	<' + 'xsl:variable name="children" select="count(//item[@parent_id=$node/attribute::id]) &gt; 0" />' +
			'	<' + 'li>' +
			'		<' + 'xsl:for-each select="@*">' +
			'			<' + 'xsl:if test="name() != \'parent_id\'">' +
			'				<' + 'xsl:attribute name="{name()}"><' + 'xsl:value-of select="." /><' + '/xsl:attribute>' +
			'			<' + '/xsl:if>' +
			'		<' + '/xsl:for-each>' +
			'		<' + 'a>' +
			'			<' + 'xsl:for-each select="./content/@*"><' + 'xsl:attribute name="{name()}"><' + 'xsl:value-of select="." /><' + '/xsl:attribute><' + '/xsl:for-each>' +
			'			<' + 'xsl:copy-of select="./content/child::node()" />' +
			'		<' + '/a>' +
			'		<' + 'xsl:if test="$children">' +
			'		<' + 'ul>' +
			'			<' + 'xsl:for-each select="//item[@parent_id=$node/attribute::id]">' +
			'				<' + 'xsl:call-template name="nodes">' +
			'					<' + 'xsl:with-param name="node" select="." />' +
			'				<' + '/xsl:call-template>' +
			'			<' + '/xsl:for-each>' +
			'		<' + '/ul>' +
			'		<' + '/xsl:if>' +
			'	<' + '/li>' +
			'<' + '/xsl:template>' +
			'<' + '/xsl:stylesheet>'
    },
	escape_xml = function (string) {
	    return string
			.toString()
			.replace(/&/g, '&amp;')
			.replace(/<'+'/g, '&lt;')
			.replace(/>/g, '&gt;')
			.replace(/"/g, '&quot;')
			.replace(/'/g, '&apos;');
	};

    $.jstree.defaults.xml = {
        xsl: "flat",
        data: false,
        ajax: false
    };

    $.jstree.plugins.xml = function (options, parent) {
        this._append_xml_data = function (dom, data) {
            data = $.vakata.xslt(data, xsl[this.settings.xml.xsl]);
            if (data === false) { return false; }
            data = $(data);
            dom = this.get_node(dom);
            if (!data || !data.length || !data.is('ul, li')) {
                if (dom && dom !== -1 && dom.is('li')) {
                    dom.removeClass('jstree-closed').addClass('jstree-leaf').children('ul').remove();
                }
                return true;
            }
            if (dom === -1) { dom = this.element; }
            if (!dom.length) { return false; }
            if (!dom.children('ul').length) { dom.append('<' + 'ul />'); }
            dom.children('ul').empty().append(data.is('ul') ? data.children('li') : data);
            return true;
        };
        this._load_node = function (obj, callback) {
            var d = false,
				s = $.extend(true, {}, this.settings.xml);
            obj = this.get_node(obj);
            if (!obj) { return false; }
            switch (!0) {
                // no settings - use parent
                case (!s.data && !s.ajax):
                    return parent._load_node.call(this, obj, callback);
                    // data is function
                case ($.isFunction(s.data)):
                    return s.data.call(this, obj, $.proxy(function (d) {
                        return callback.call(this, this._append_xml_data(obj, d));
                    }, this));
                    // data is set, ajax is not set, or both are set, but we are dealing with root node
                case ((!!s.data && !s.ajax) || (!!s.data && !!s.ajax && obj === -1)):
                    return callback.call(this, this._append_xml_data(obj, s.data));
                    // data is not set, ajax is set, or both are set, but we are dealing with a normal node
                case ((!s.data && !!s.ajax) || (!!s.data && !!s.ajax && obj !== -1)):
                    s.ajax.success = $.proxy(function (d, t, x) {
                        var s = this.settings.xml.ajax;
                        if ($.isFunction(s.success)) {
                            d = s.success.call(this, d, t, x) || d;
                        }
                        callback.call(this, this._append_xml_data(obj, d));
                    }, this);
                    s.ajax.error = $.proxy(function (x, t, e) {
                        var s = this.settings.xml.ajax;
                        if ($.isFunction(s.error)) {
                            s.error.call(this, x, t, e);
                        }
                        callback.call(this, false);
                    }, this);
                    if (!s.ajax.dataType) { s.ajax.dataType = "xml"; }
                    if ($.isFunction(s.ajax.url)) { s.ajax.url = s.ajax.url.call(this, obj); }
                    if ($.isFunction(s.ajax.data)) { s.ajax.data = s.ajax.data.call(this, obj); }
                    return $.ajax(s.ajax);
            }
        };
        this.get_xml = function (mode, obj, is_callback) {
            var r = '';
            if (!mode) { mode = 'flat'; }
            if (typeof is_callback === 'undefined') {
                obj = this.get_json(obj);
                $.each(obj, $.proxy(function (i, v) {
                    r += this.get_xml(mode, v, true);
                }, this));
                return '' +
					'<' + '?xml version="1.0" encoding="utf-8" ?>' +
					'<' + 'root>' + r + '<' + '/root>';
            }
            r += '<' + 'item';
            if (mode === 'flat' && is_callback !== true) {
                r += ' parent_id="' + escape_xml(is_callback) + '"';
            }
            if (obj.data && !$.isEmptyObject(obj.data)) {
                $.each(obj.data, function (i, v) {
                    if (!$.isEmptyObject(v)) {
                        r += ' data-' + i + '="' + escape_xml($.vakata.json.encode(v)) + '"';
                    }
                });
            }
            $.each(obj.li_attr, function (i, v) {
                r += ' ' + i + '="' + escape_xml(v) + '"';
            });
            r += '>';
            r += '<' + 'content';
            $.each(obj.a_attr, function (i, v) {
                r += ' ' + i + '="' + escape_xml(v) + '"';
            });
            r += '><' + '![CDATA[' + obj.title + ']]><' + '/content>';

            if (mode === 'flat') { r += '<' + '/item>'; }
            if (obj.children) {
                $.each(obj.children, $.proxy(function (i, v) {
                    r += this.get_xml(mode, v, obj.li_attr && obj.li_attr.id ? obj.li_attr.id : true);
                }, this));
            }
            if (mode === 'nest') { r += '<' + '/item>'; }
            return r;
        };
    };

    // include the html plugin by default
    $.jstree.defaults.plugins.push("xml");

    // helpers
    $.vakata.xslt = function (xml, xsl) {
        var r = false, p, q, s, xm = $.parseXML(xml), xs = $.parseXML(xsl);

        // FF, Chrome, IE10
        if (typeof (XSLTProcessor) !== "undefined") {
            p = new XSLTProcessor();
            p.importStylesheet(xs);
            r = p.transformToFragment(xm, document);
            return $('<' + 'div />').append(r).html();
        }
        // OLD IE
        if (typeof (xm.transformNode) !== "undefined") {
            return xm.transformNode(xs);
        }
        // IE9, IE10
        if (window.ActiveXObject) {
            try {
                r = new ActiveXObject("Msxml2.XSLTemplate");
                q = new ActiveXObject("Msxml2.DOMDocument");
                q.loadXML(xml);
                s = new ActiveXObject("Msxml2.FreeThreadedDOMDocument");
                s.loadXML(xsl);
                r.stylesheet = s;
                p = r.createProcessor();
                p.input = q;
                p.transform();
                r = p.output;
            }
            catch (e) { }
        }
        return r;
    };
})(jQuery);(function () {
    var skipLinkUl = $("<ul class='ym-skiplinks'></ul>");
    $(".skip-link-target").each(function () {
        var label = $(this).attr("data-label");
        var href = $(this).attr("id");
        skipLinkUl.append("<li><a href=#" + href + " class='ym-skip'>Skip to " + label + " (Press Enter)</a></li>");
    });
    $("body").prepend(skipLinkUl);
    $(".ym-skiplinks a").click(function () {
        var id = $(this).attr("href");
        $(id).attr("tabindex", 0);
    });
    $(".skip-link-target").blur(function () {
        $(this).removeAttr("tabindex");
    });
})();/*!
	Colorbox v1.4.33 - 2013-10-31
	jQuery lightbox and modal window plugin
	(c) 2013 Jack Moore - http://www.jacklmoore.com/colorbox
	license: http://www.opensource.org/licenses/mit-license.php
*/
(function ($, document, window) {
    var
	// Default settings object.
	// See http://jacklmoore.com/colorbox for details.
	defaults = {
	    // data sources
	    html: false,
	    photo: false,
	    iframe: false,
	    inline: false,

	    // behavior and appearance
	    transition: "elastic",
	    speed: 300,
	    fadeOut: 300,
	    width: false,
	    initialWidth: "600",
	    innerWidth: false,
	    maxWidth: false,
	    height: false,
	    initialHeight: "450",
	    innerHeight: false,
	    maxHeight: false,
	    scalePhotos: true,
	    scrolling: true,
	    href: false,
	    title: false,
	    rel: false,
	    opacity: 0.9,
	    preloading: true,
	    className: false,
	    overlayClose: true,
	    escKey: true,
	    arrowKey: true,
	    top: false,
	    bottom: false,
	    left: false,
	    right: false,
	    fixed: false,
	    data: undefined,
	    closeButton: true,
	    fastIframe: true,
	    open: false,
	    reposition: true,
	    loop: true,
	    slideshow: false,
	    slideshowAuto: true,
	    slideshowSpeed: 2500,
	    slideshowStart: "start slideshow",
	    slideshowStop: "stop slideshow",
	    photoRegex: /\.(gif|png|jp(e|g|eg)|bmp|ico|webp)((#|\?).*)?$/i,

	    // alternate image paths for high-res displays
	    retinaImage: false,
	    retinaUrl: false,
	    retinaSuffix: '@2x.$1',

	    // internationalization
	    current: "image {current} of {total}",
	    previous: "previous",
	    next: "next",
	    close: "close",
	    xhrError: "This content failed to load.",
	    imgError: "This image failed to load.",

	    // accessbility
	    returnFocus: true,
	    trapFocus: true,

	    // callbacks
	    onOpen: false,
	    onLoad: false,
	    onComplete: false,
	    onCleanup: false,
	    onClosed: false
	},

	// Abstracting the HTML and event identifiers for easy rebranding
	colorbox = 'colorbox',
	prefix = 'cbox',
	boxElement = prefix + 'Element',

	// Events
	event_open = prefix + '_open',
	event_load = prefix + '_load',
	event_complete = prefix + '_complete',
	event_cleanup = prefix + '_cleanup',
	event_closed = prefix + '_closed',
	event_purge = prefix + '_purge',

	// Cached jQuery Object Variables
	$overlay,
	$box,
	$wrap,
	$content,
	$topBorder,
	$leftBorder,
	$rightBorder,
	$bottomBorder,
	$related,
	$window,
	$loaded,
	$loadingBay,
	$loadingOverlay,
	$title,
	$current,
	$slideshow,
	$next,
	$prev,
	$close,
	$groupControls,
	$events = $('<a/>'), // $([]) would be prefered, but there is an issue with jQuery 1.4.2

	// Variables for cached values or use across multiple functions
	settings,
	interfaceHeight,
	interfaceWidth,
	loadedHeight,
	loadedWidth,
	element,
	index,
	photo,
	open,
	active,
	closing,
	loadingTimer,
	publicMethod,
	div = "div",
	className,
	requests = 0,
	previousCSS = {},
	init;

    // ****************
    // HELPER FUNCTIONS
    // ****************

    // Convenience function for creating new jQuery objects
    function $tag(tag, id, css) {
        var element = document.createElement(tag);

        if (id) {
            element.id = prefix + id;
        }

        if (css) {
            element.style.cssText = css;
        }

        return $(element);
    }

    // Get the window height using innerHeight when available to avoid an issue with iOS
    // http://bugs.jquery.com/ticket/6724
    function winheight() {
        return window.innerHeight ? window.innerHeight : $(window).height();
    }

    // Determine the next and previous members in a group.
    function getIndex(increment) {
        var
		max = $related.length,
		newIndex = (index + increment) % max;

        return (newIndex < 0) ? max + newIndex : newIndex;
    }

    // Convert '%' and 'px' values to integers
    function setSize(size, dimension) {
        return Math.round((/%/.test(size) ? ((dimension === 'x' ? $window.width() : winheight()) / 100) : 1) * parseInt(size, 10));
    }

    // Checks an href to see if it is a photo.
    // There is a force photo option (photo: true) for hrefs that cannot be matched by the regex.
    function isImage(settings, url) {
        return settings.photo || settings.photoRegex.test(url);
    }

    function retinaUrl(settings, url) {
        return settings.retinaUrl && window.devicePixelRatio > 1 ? url.replace(settings.photoRegex, settings.retinaSuffix) : url;
    }

    function trapFocus(e) {
        if ('contains' in $box[0] && !$box[0].contains(e.target)) {
            e.stopPropagation();
            $box.focus();
        }
    }

    // Assigns function results to their respective properties




    // Colorbox's markup needs to be added to the DOM prior to being called
    // so that the browser will go ahead and load the CSS background images.
    function appendHTML() {
        if (!$box && document.body) {
            init = false;
            $window = $(window);
            $box = $tag(div).attr({
                id: colorbox,
                'class': $.support.opacity === false ? prefix + 'IE' : '', // class for optional IE8 & lower targeted CSS.
                role: 'dialog',
                tabindex: '-1'
            }).hide();
            $overlay = $tag(div, "Overlay").hide();
            $loadingOverlay = $([$tag(div, "LoadingOverlay")[0], $tag(div, "LoadingGraphic")[0]]);
            $wrap = $tag(div, "Wrapper");
            $content = $tag(div, "Content").append(
				$title = $tag(div, "Title"),
				$current = $tag(div, "Current"),
				$prev = $('<button type="button"/>').attr({ id: prefix + 'Previous' }),
				$next = $('<button type="button"/>').attr({ id: prefix + 'Next' }),
				$slideshow = $tag('button', "Slideshow"),
				$loadingOverlay
			);

            $close = $('<button type="button"/>').attr({ id: prefix + 'Close' });

            $wrap.append( // The 3x3 Grid that makes up Colorbox
				$tag(div).append(
					$tag(div, "TopLeft"),
					$topBorder = $tag(div, "TopCenter"),
					$tag(div, "TopRight")
				),
				$tag(div, false, 'clear:left').append(
					$leftBorder = $tag(div, "MiddleLeft"),
					$content,
					$rightBorder = $tag(div, "MiddleRight")
				),
				$tag(div, false, 'clear:left').append(
					$tag(div, "BottomLeft"),
					$bottomBorder = $tag(div, "BottomCenter"),
					$tag(div, "BottomRight")
				)
			).find('div div').css({ 'float': 'left' });

            $loadingBay = $tag(div, false, 'position:absolute; width:9999px; visibility:hidden; display:none; max-width:none;');

            $groupControls = $next.add($prev).add($current).add($slideshow);

            $(document.body).append($overlay, $box.append($wrap, $loadingBay));
        }
    }

    // Add Colorbox's event bindings
    function addBindings() {
        function clickHandler(e) {
            // ignore non-left-mouse-clicks and clicks modified with ctrl / command, shift, or alt.
            // See: http://jacklmoore.com/notes/click-events/
            if (!(e.which > 1 || e.shiftKey || e.altKey || e.metaKey || e.ctrlKey)) {
                e.preventDefault();
                launch(this);
            }
        }

        if ($box) {
            if (!init) {
                init = true;

                // Anonymous functions here keep the public method from being cached, thereby allowing them to be redefined on the fly.
                $next.click(function () {
                    publicMethod.next();
                });
                $prev.click(function () {
                    publicMethod.prev();
                });
                $close.click(function () {
                    publicMethod.close();
                });
                $overlay.click(function () {
                    if (settings.overlayClose) {
                        publicMethod.close();
                    }
                });

                // Key Bindings
                $(document).bind('keydown.' + prefix, function (e) {
                    var key = e.keyCode;
                    if (open && settings.escKey && key === 27) {
                        e.preventDefault();
                        publicMethod.close();
                    }
                    if (open && settings.arrowKey && $related[1] && !e.altKey) {
                        if (key === 37) {
                            e.preventDefault();
                            $prev.click();
                        } else if (key === 39) {
                            e.preventDefault();
                            $next.click();
                        }
                    }
                });

                if ($.isFunction($.fn.on)) {
                    // For jQuery 1.7+
                    $(document).on('click.' + prefix, '.' + boxElement, clickHandler);
                } else {
                    // For jQuery 1.3.x -> 1.6.x
                    // This code is never reached in jQuery 1.9, so do not contact me about 'live' being removed.
                    // This is not here for jQuery 1.9, it's here for legacy users.
                    $('.' + boxElement).live('click.' + prefix, clickHandler);
                }
            }
            return true;
        }
        return false;
    }

    // Don't do anything if Colorbox already exists.
    if ($.colorbox) {
        return;
    }

    // Append the HTML when the DOM loads
    $(appendHTML);


    // ****************
    // PUBLIC FUNCTIONS
    // Usage format: $.colorbox.close();
    // Usage from within an iframe: parent.jQuery.colorbox.close();
    // ****************

    publicMethod = $.fn[colorbox] = $[colorbox] = function (options, callback) {
        var $this = this;

        options = options || {};

        appendHTML();

        if (addBindings()) {
            if ($.isFunction($this)) { // assume a call to $.colorbox
                $this = $('<a/>');
                options.open = true;
            } else if (!$this[0]) { // colorbox being applied to empty collection
                return $this;
            }

            if (callback) {
                options.onComplete = callback;
            }

            $this.each(function () {
                $.data(this, colorbox, $.extend({}, $.data(this, colorbox) || defaults, options));
            }).addClass(boxElement);

            if (($.isFunction(options.open) && options.open.call($this)) || options.open) {
                launch($this[0]);
            }
        }

        return $this;
    };

    publicMethod.position = function (speed, loadedCallback) {
        var
		css,
		top = 0,
		left = 0,
		offset = $box.offset(),
		scrollTop,
		scrollLeft;

        $window.unbind('resize.' + prefix);

        // remove the modal so that it doesn't influence the document width/height
        $box.css({ top: -9e4, left: -9e4 });

        scrollTop = $window.scrollTop();
        scrollLeft = $window.scrollLeft();

        if (settings.fixed) {
            offset.top -= scrollTop;
            offset.left -= scrollLeft;
            $box.css({ position: 'fixed' });
        } else {
            top = scrollTop;
            left = scrollLeft;
            $box.css({ position: 'absolute' });
        }

        // keeps the top and left positions within the browser's viewport.
        if (settings.right !== false) {
            left += Math.max($window.width() - settings.w - loadedWidth - interfaceWidth - setSize(settings.right, 'x'), 0);
        } else if (settings.left !== false) {
            left += setSize(settings.left, 'x');
        } else {
            left += Math.round(Math.max($window.width() - settings.w - loadedWidth - interfaceWidth, 0) / 2);
        }

        if (settings.bottom !== false) {
            top += Math.max(winheight() - settings.h - loadedHeight - interfaceHeight - setSize(settings.bottom, 'y'), 0);
        } else if (settings.top !== false) {
            top += setSize(settings.top, 'y');
        } else {
            top += Math.round(Math.max(winheight() - settings.h - loadedHeight - interfaceHeight, 0) / 2);
        }

        $box.css({ top: offset.top, left: offset.left, visibility: 'visible' });

        // this gives the wrapper plenty of breathing room so it's floated contents can move around smoothly,
        // but it has to be shrank down around the size of div#colorbox when it's done.  If not,
        // it can invoke an obscure IE bug when using iframes.
        $wrap[0].style.width = $wrap[0].style.height = "9999px";

        function modalDimensions() {
            $topBorder[0].style.width = $bottomBorder[0].style.width = $content[0].style.width = (parseInt($box[0].style.width, 10) - interfaceWidth) + 'px';
            $content[0].style.height = $leftBorder[0].style.height = $rightBorder[0].style.height = (parseInt($box[0].style.height, 10) - interfaceHeight) + 'px';
        }

        css = { width: settings.w + loadedWidth + interfaceWidth, height: settings.h + loadedHeight + interfaceHeight, top: top, left: left };

        // setting the speed to 0 if the content hasn't changed size or position
        if (speed) {
            var tempSpeed = 0;
            $.each(css, function (i) {
                if (css[i] !== previousCSS[i]) {
                    tempSpeed = speed;
                    return;
                }
            });
            speed = tempSpeed;
        }

        previousCSS = css;

        if (!speed) {
            $box.css(css);
        }

        $box.dequeue().animate(css, {
            duration: speed || 0,
            complete: function () {
                modalDimensions();

                active = false;

                // shrink the wrapper down to exactly the size of colorbox to avoid a bug in IE's iframe implementation.
                $wrap[0].style.width = (settings.w + loadedWidth + interfaceWidth) + "px";
                $wrap[0].style.height = (settings.h + loadedHeight + interfaceHeight) + "px";

                if (settings.reposition) {
                    setTimeout(function () {  // small delay before binding onresize due to an IE8 bug.
                        $window.bind('resize.' + prefix, publicMethod.position);
                    }, 1);
                }

                if (loadedCallback) {
                    loadedCallback();
                }
            },
            step: modalDimensions
        });
    };

    publicMethod.resize = function (options) {
        var scrolltop;

        if (open) {
            options = options || {};

            if (options.width) {
                settings.w = setSize(options.width, 'x') - loadedWidth - interfaceWidth;
            }

            if (options.innerWidth) {
                settings.w = setSize(options.innerWidth, 'x');
            }

            $loaded.css({ width: settings.w });

            if (options.height) {
                settings.h = setSize(options.height, 'y') - loadedHeight - interfaceHeight;
            }

            if (options.innerHeight) {
                settings.h = setSize(options.innerHeight, 'y');
            }

            if (!options.innerHeight && !options.height) {
                scrolltop = $loaded.scrollTop();
                $loaded.css({ height: "auto" });
                settings.h = $loaded.height();
            }

            $loaded.css({ height: settings.h });

            if (scrolltop) {
                $loaded.scrollTop(scrolltop);
            }

            publicMethod.position(settings.transition === "none" ? 0 : settings.speed);
        }
    };

    publicMethod.prep = function (object) {
        if (!open) {
            return;
        }

        var callback, speed = settings.transition === "none" ? 0 : settings.speed;

        $loaded.empty().remove(); // Using empty first may prevent some IE7 issues.

        $loaded = $tag(div, 'LoadedContent').append(object);

        function getWidth() {
            settings.w = settings.w || $loaded.width();
            settings.w = settings.mw && settings.mw < settings.w ? settings.mw : settings.w;
            return settings.w;
        }
        function getHeight() {
            settings.h = settings.h || $loaded.height();
            settings.h = settings.mh && settings.mh < settings.h ? settings.mh : settings.h;
            return settings.h;
        }

        $loaded.hide()
		.appendTo($loadingBay.show())// content has to be appended to the DOM for accurate size calculations.
		.css({ width: getWidth(), overflow: settings.scrolling ? 'auto' : 'hidden' })
		.css({ height: getHeight() })// sets the height independently from the width in case the new width influences the value of height.
		.prependTo($content);

        $loadingBay.hide();

        // floating the IMG removes the bottom line-height and fixed a problem where IE miscalculates the width of the parent element as 100% of the document width.

        $(photo).css({ 'float': 'none' });

        callback = function () {
            var total = $related.length,
				iframe,
				frameBorder = 'frameBorder',
				allowTransparency = 'allowTransparency',
				complete;

            if (!open) {
                return;
            }

            function removeFilter() { // Needed for IE7 & IE8 in versions of jQuery prior to 1.7.2
                if ($.support.opacity === false) {
                    $box[0].style.removeAttribute('filter');
                }
            }

            complete = function () {
                clearTimeout(loadingTimer);
                $loadingOverlay.hide();
                trigger(event_complete, settings.onComplete);
            };


            $title.html(settings.title).add($loaded).show();

            if (total > 1) { // handle grouping
                if (typeof settings.current === "string") {
                    $current.html(settings.current.replace('{current}', index + 1).replace('{total}', total)).show();
                }

                $next[(settings.loop || index < total - 1) ? "show" : "hide"]().html(settings.next);
                $prev[(settings.loop || index) ? "show" : "hide"]().html(settings.previous);

                slideshow();

                // Preloads images within a rel group
                if (settings.preloading) {
                    $.each([getIndex(-1), getIndex(1)], function () {
                        var src,
							img,
							i = $related[this],
							data = $.data(i, colorbox);

                        if (data && data.href) {
                            src = data.href;
                            if ($.isFunction(src)) {
                                src = src.call(i);
                            }
                        } else {
                            src = $(i).attr('href');
                        }

                        if (src && isImage(data, src)) {
                            src = retinaUrl(data, src);
                            img = document.createElement('img');
                            img.src = src;
                        }
                    });
                }
            } else {
                $groupControls.hide();
            }

            if (settings.iframe) {
                iframe = $tag('iframe')[0];

                if (frameBorder in iframe) {
                    iframe[frameBorder] = 0;
                }

                if (allowTransparency in iframe) {
                    iframe[allowTransparency] = "true";
                }

                if (!settings.scrolling) {
                    iframe.scrolling = "no";
                }

                $(iframe)
					.attr({
					    src: settings.href,
					    name: (new Date()).getTime(), // give the iframe a unique name to prevent caching
					    'class': prefix + 'Iframe',
					    allowFullScreen: true, // allow HTML5 video to go fullscreen
					    webkitAllowFullScreen: true,
					    mozallowfullscreen: true
					})
					.one('load', complete)
					.appendTo($loaded);

                $events.one(event_purge, function () {
                    iframe.src = "//about:blank";
                });

                if (settings.fastIframe) {
                    $(iframe).trigger('load');
                }
            } else {
                complete();
            }

            if (settings.transition === 'fade') {
                $box.fadeTo(speed, 1, removeFilter);
            } else {
                removeFilter();
            }
        };

        if (settings.transition === 'fade') {
            $box.fadeTo(speed, 0, function () {
                publicMethod.position(0, callback);
            });
        } else {
            publicMethod.position(speed, callback);
        }
    };

    function load() {
        var href, setResize, prep = publicMethod.prep, $inline, request = ++requests;

        active = true;

        photo = false;

        element = $related[index];

        makeSettings();

        trigger(event_purge);

        trigger(event_load, settings.onLoad);

        settings.h = settings.height ?
				setSize(settings.height, 'y') - loadedHeight - interfaceHeight :
				settings.innerHeight && setSize(settings.innerHeight, 'y');

        settings.w = settings.width ?
				setSize(settings.width, 'x') - loadedWidth - interfaceWidth :
				settings.innerWidth && setSize(settings.innerWidth, 'x');

        // Sets the minimum dimensions for use in image scaling
        settings.mw = settings.w;
        settings.mh = settings.h;

        // Re-evaluate the minimum width and height based on maxWidth and maxHeight values.
        // If the width or height exceed the maxWidth or maxHeight, use the maximum values instead.
        if (settings.maxWidth) {
            settings.mw = setSize(settings.maxWidth, 'x') - loadedWidth - interfaceWidth;
            settings.mw = settings.w && settings.w < settings.mw ? settings.w : settings.mw;
        }
        if (settings.maxHeight) {
            settings.mh = setSize(settings.maxHeight, 'y') - loadedHeight - interfaceHeight;
            settings.mh = settings.h && settings.h < settings.mh ? settings.h : settings.mh;
        }

        href = settings.href;

        loadingTimer = setTimeout(function () {
            $loadingOverlay.show();
        }, 100);

        if (settings.inline) {
            // Inserts an empty placeholder where inline content is being pulled from.
            // An event is bound to put inline content back when Colorbox closes or loads new content.
            $inline = $tag(div).hide().insertBefore($(href)[0]);

            $events.one(event_purge, function () {
                $inline.replaceWith($loaded.children());
            });

            prep($(href));
        } else if (settings.iframe) {
            // IFrame element won't be added to the DOM until it is ready to be displayed,
            // to avoid problems with DOM-ready JS that might be trying to run in that iframe.
            prep(" ");
        } else if (settings.html) {
            prep(settings.html);
        } else if (isImage(settings, href)) {

            href = retinaUrl(settings, href);

            photo = document.createElement('img');

            $(photo)
			.addClass(prefix + 'Photo')
			.bind('error', function () {
			    settings.title = false;
			    prep($tag(div, 'Error').html(settings.imgError));
			})
			.one('load', function () {
			    var percent;

			    if (request !== requests) {
			        return;
			    }

			    $.each(['alt', 'longdesc', 'aria-describedby'], function (i, val) {
			        var attr = $(element).attr(val) || $(element).attr('data-' + val);
			        if (attr) {
			            photo.setAttribute(val, attr);
			        }
			    });

			    if (settings.retinaImage && window.devicePixelRatio > 1) {
			        photo.height = photo.height / window.devicePixelRatio;
			        photo.width = photo.width / window.devicePixelRatio;
			    }

			    if (settings.scalePhotos) {
			        setResize = function () {
			            photo.height -= photo.height * percent;
			            photo.width -= photo.width * percent;
			        };
			        if (settings.mw && photo.width > settings.mw) {
			            percent = (photo.width - settings.mw) / photo.width;
			            setResize();
			        }
			        if (settings.mh && photo.height > settings.mh) {
			            percent = (photo.height - settings.mh) / photo.height;
			            setResize();
			        }
			    }

			    if (settings.h) {
			        photo.style.marginTop = Math.max(settings.mh - photo.height, 0) / 2 + 'px';
			    }

			    if ($related[1] && (settings.loop || $related[index + 1])) {
			        photo.style.cursor = 'pointer';
			        photo.onclick = function () {
			            publicMethod.next();
			        };
			    }

			    photo.style.width = photo.width + 'px';
			    photo.style.height = photo.height + 'px';

			    setTimeout(function () { // A pause because Chrome will sometimes report a 0 by 0 size otherwise.
			        prep(photo);
			    }, 1);
			});

            setTimeout(function () { // A pause because Opera 10.6+ will sometimes not run the onload function otherwise.
                photo.src = href;
            }, 1);
        } else if (href) {
            $loadingBay.load(href, settings.data, function (data, status) {
                if (request === requests) {
                    prep(status === 'error' ? $tag(div, 'Error').html(settings.xhrError) : $(this).contents());
                }
            });
        }
    }

    // Navigates to the next page/image in a set.
    publicMethod.next = function () {
        if (!active && $related[1] && (settings.loop || $related[index + 1])) {
            index = getIndex(1);
            launch($related[index]);
        }
    };

    publicMethod.prev = function () {
        if (!active && $related[1] && (settings.loop || index)) {
            index = getIndex(-1);
            launch($related[index]);
        }
    };

    // Note: to use this within an iframe use the following format: parent.jQuery.colorbox.close();
    publicMethod.close = function () {
        if (open && !closing) {

            closing = true;

            open = false;

            trigger(event_cleanup, settings.onCleanup);

            $window.unbind('.' + prefix);

            $overlay.fadeTo(settings.fadeOut || 0, 0);

            $box.stop().fadeTo(settings.fadeOut || 0, 0, function () {

                $box.add($overlay).css({ 'opacity': 1, cursor: 'auto' }).hide();

                trigger(event_purge);

                $loaded.empty().remove(); // Using empty first may prevent some IE7 issues.

                setTimeout(function () {
                    closing = false;
                    trigger(event_closed, settings.onClosed);
                }, 1);
            });
        }
    };

    // Removes changes Colorbox made to the document, but does not remove the plugin.
    publicMethod.remove = function () {
        if (!$box) { return; }

        $box.stop();
        $.colorbox.close();
        $box.stop().remove();
        $overlay.remove();
        closing = false;
        $box = null;
        $('.' + boxElement)
			.removeData(colorbox)
			.removeClass(boxElement);

        $(document).unbind('click.' + prefix);
    };

    // A method for fetching the current element Colorbox is referencing.
    // returns a jQuery object.
    publicMethod.element = function () {
        return $(element);
    };

    publicMethod.settings = defaults;

}(jQuery, document, window));function toggleVisaFinderFields() {
    var purpose = $('#visaFinderPurpose select').find(":selected").text();
    var showType = false;
    var showSponsor = false;
    var showAllowMeToBring = true;

    switch (purpose) {
        case "Visit Australia":
            showAllowMeToBring = false;
            break;
        case "Live in Australia":
            showType = true;
            break;
        case "Work in Australia":
        case "Study in Australia":
            showSponsor = true;
            break;
    }
    if (showAllowMeToBring)
        $('#visaFinderSponsor').prev().show();
    else
        $('#visaFinderSponsor').prev().hide();
    if (showType)
        $('#visaFinderType').show();
    else
        $('#visaFinderType').hide();

    if (showSponsor)
        $('#visaFinderSponsor').show();
    else
        $('#visaFinderSponsor').hide();
}

function toggleFormFinderFields() {
    var purpose = $('#formFinderPurpose select').find(":selected").text();
    var showVisaFields = false;
    var showGeneralFields = false;

    showVisaFields = ("Visa" == purpose);
    showGeneralFields = ("General" == purpose);

    if (showGeneralFields)
        $('.formFinderGeneral').show();
    else
        $('.formFinderGeneral').hide();

    if (showVisaFields)
        $('.formFinderVisa').show();
    else
        $('.formFinderVisa').hide();
}

function FindVisa() {
    var nationality = $(nationalityId).val();
    nationality = nationality.replace(",", "_");
    var applyFrom = $(applyFromId).val();
    applyFrom = applyFrom.replace(",", "_");
    window.location = visaFinderResultsPage + "?Purpose=" + $(purposeId).val() + "&ApplyFrom=" + applyFrom + "&Nationality=" + nationality;

}/**
 * "Yet Another Multicolumn Layout" - YAML CSS Framework
 *
 * (en) Workaround for IE8 und Webkit browsers to fix focus problems when using skiplinks
 * (de) Workaround fr IE8 und Webkit browser, um den Focus zu korrigieren, bei Verwendung von Skiplinks
 *
 * @note			inspired by Paul Ratcliffe's article
 *					http://www.communis.co.uk/blog/2009-06-02-skip-links-chrome-safari-and-added-wai-aria
 *                  Many thanks to Mathias Schfer (http://molily.de/) for his code improvements
 *
 * @copyright       Copyright 2005-2012, Dirk Jesse
 * @license         CC-BY 2.0 (http://creativecommons.org/licenses/by/2.0/),
 *                  YAML-CDL (http://www.yaml.de/license.html)
 * @link            http://www.yaml.de
 * @package         yaml
 * @version         4.0+
 * @revision        $Revision: 617 $
 * @lastmodified    $Date: 2012-01-05 23:56:54 +0100 (Do, 05 Jan 2012) $
 */

function getParameterByName(name) {
    name = name.replace(/[\[]/, "\\\[").replace(/[\]]/, "\\\]");
    var regex = new RegExp("[\\?&]" + name + "=([^&#]*)")
    var locs = location.href.split("?");
    var locStr = "";
    if (locs.length > 1) { locStr = "?" + locs[1]; }
    results = regex.exec(locStr);
    return results == null ? "" : decodeURIComponent(results[1].replace(/\+/g, " "));
}


/* Start GLOBAL VARIABLES */
$.CssClassNames = {
    slideshow: 'new-slideshow',
    slideshowPlayPause: 'immi-play-pause',
    slideshowPaused: 'immi-paused',
    slideshowSelected: 'immi-selected',
    slideshowMobileWrapper: 'immi-slideshow-wrapper-mobile',
    slideshowMobile: 'immi-slideshow-mobile',
    navFocus: 'immi-sub-open',
    subnav: 'immi-subnav',
    ribbon: 'immi-subnav-ribbon',
    popover: 'immi-popover',
    assistance: 'immi-assistance',
    help: 'immi-subnav-help',
    collapsibleControl: 'collapsible_header',
    collapsibleClosed: 'collapsible_closed',
    carousel: 'immi-carousel',
    carouselButton: 'immi-carousel-button',
    feedbackPopover: 'immi-feedback-popover',
    closeDialog: 'immi-close-popover',
    starControl: 'immi-star-control',
    countryModal: 'immi-country-modal'
}

$.Effects = {
    Enabled: true,
    Duration: 200,
    Interval: 5000,
    Assistance: 800
};

$.Delay = {
    Show: 150,
    Hide: 150,
    Restart: 1000,
    Assistance: 2000
};

$.DynamicLabels = {
    collapsible: {
        openTitle: 'Collapsible section open - activate to close',
        closedTitle: 'Collapsible section closed - activate to open'
    },
    menu: {
        openTitle: 'Sub-menu open - activate to close',
        closedTitle: 'Sub-menu closed - activate to open'
    }
}
$.Element = function () {
    this.cssClass;
    this.text;
    this.element;
    this.__construct = function (element) {
        this.element = document.createElement(element || 'div'); // DIV is the default element type
    }
    this.setText = function (text) {
        try {
            if (!text) throw new Error('setText method requires a text argument');
            this.text = text;
        } catch (err) {
            $.log(err.message);
        }
    }
    this.getText = function () {
        return this.text;
    }
    this.setCssClass = function (cssClass) {
        try {
            if (!cssClass) throw new Error('setClass method requires a text argument');
            if (cssClass instanceof Array) {
                cssClass = cssClass.join(' ');
            }
            this.element.className = cssClass;
        } catch (err) {
            try {
                console.log(err.message);
            } catch (err) {
                // IE8 
            }
        }
    }
    this.getCssClass = function () {
        return this.cssClass;
    }
    this.setTitle = function (title) {
        if (title) {
            this.element.title = title;
        }
    }
    // generate a text node and append it to the element
    this.generateTextNode = function (text) {
        if (text) {
            this.setText(text);
        }
        this.element.appendChild(document.createTextNode(this.getText()));
    }
    // return a reference to the generated element
    this.getElement = function () {
        return this.element;
    }
};
$.PhantomLink = function (text) {
    this.__construct('a');
    this.element.setAttribute('href', '#phantom');
    this.generateTextNode(text || 'null link');
    return this;
};
$.PhantomLink.prototype = new $.Element();

$.fn.safeFadeIn = function (options) {
    var settings = $.extend({
        duration: $.Effects.Duration,
        callback: null
    }, options);
    return this.each(function () {
        if (!jQuery.support.changeBubbles) {
            $(this).show(null, settings.callback);
        } else {
            $(this).fadeIn(settings.duration, settings.callback);
        }
    });
};
$.TipDuration = 1600;
$.KeyDelay = 200;
// jQuery plug-in to handle fade out safely - that is, modern browsers fade out but older browsers (IE8 and less) use hide
$.fn.safeFadeOut = function (options) {
    var settings = $.extend({
        duration: $.Effects.Duration,
        callback: null
    }, options);
    return this.each(function () {
        if (!jQuery.support.changeBubbles) {
            $(this).hide(null, settings.callback);
        } else {
            $(this).fadeOut(settings.duration, settings.callback);
        }
    });
};
$.Paragraph = function (text) {
    this.__construct('p');
    this.generateTextNode(text);
    return this;
};
$.Paragraph.prototype = new $.Element();
var body = document.getElementsByTagName('body')[0];
$.Elements = {
    Body: body,
    $Body: $(body)
};
$.Shim = function (transparent) {
    this.__construct('div');
    var cssClass = ['immi-shim'];
    if (transparent) {
        cssClass.push('immi-transparent');
    }
    this.setCssClass(cssClass);
    return this;
}
$.Shim.prototype = new $.Element();
// "static" method of the $ object to report content to the console (if it is supported by the browser) or throw it out to the FOOTER element
$.log = function (txt) { // handle script logging (ie. Console.log where it is supported otherwise output to the footer in a P element)
    try { console.log(txt); }
    catch (err) {
        // either the browser doesn't support console logging (console.log()) or it (ie. IE8) doesn't have the Dev Tools open - $('#footer').append('<p>' + txt + '</p>');
    }
};

$.Link = function (url, text, css_class, title) {
    this.__construct('a');
    if (css_class) {
        this.setCssClass(css_class);
    }
    this.element.setAttribute('href', url);
    this.setTitle(title);
    if (text) {
        this.generateTextNode(text);
    }
    return this;
};
$.Link.prototype = new $.Element(); // set and call the "superclass"

$.fn.focusFirstInteractiveControl = function () {
    return this.each(function () {
        //$(this.hash).find('a, :input, [tabindex="0"]').not('[href="#phantom"]').first().trigger('focus');
        $(this).find('a, :input, [tabindex="0"]').not('[href="#phantom"]').first().trigger('focus');
    });
}

/// for storage extend the jQuery object with static methods for handling local storage and cookie APIs
try {
    $.Storage = {
        local: window.localStorage, //.setItem(key, value) .getItem(key) etc
        session: window.sessionStorage
    };
} catch (err) {
    $.log(err.message);
    //  cookie fallback depends on jquery.cookie.js
    $.Storage = {
        local: {
            setItem: function (key, value, expiry) {
                if (expiry) {
                    $.cookie(key, value, expiry);
                }
                else {
                    $.cookie(key, value, 20 * 365);
                }
            },
            getItem: function (key) {
                return $.cookie(key);
            }
        }  // local
    }
}/**
 * BxSlider v4.1.1 - Fully loaded, responsive content slider
 * http://bxslider.com
 *
 * Copyright 2013, Steven Wanderski - http://stevenwanderski.com - http://bxcreative.com
 * Written while drinking Belgian ales and listening to jazz
 *
 * Released under the MIT license - http://opensource.org/licenses/MIT
 */
!function (t) { var e = {}, s = { mode: "horizontal", slideSelector: "", infiniteLoop: !0, hideControlOnEnd: !1, speed: 500, easing: null, slideMargin: 0, startSlide: 0, randomStart: !1, captions: !1, ticker: !1, tickerHover: !1, adaptiveHeight: !1, adaptiveHeightSpeed: 500, video: !1, useCSS: !0, preloadImages: "visible", responsive: !0, touchEnabled: !0, swipeThreshold: 50, oneToOneTouch: !0, preventDefaultSwipeX: !0, preventDefaultSwipeY: !1, pager: !0, pagerType: "full", pagerShortSeparator: " / ", pagerSelector: null, buildPager: null, pagerCustom: null, controls: !0, nextText: "Next", prevText: "Prev", nextSelector: null, prevSelector: null, autoControls: !1, startText: "Start", stopText: "Stop", autoControlsCombine: !1, autoControlsSelector: null, auto: !1, pause: 4e3, autoStart: !0, autoDirection: "next", autoHover: !1, autoDelay: 0, minSlides: 1, maxSlides: 1, moveSlides: 0, slideWidth: 0, onSliderLoad: function () { }, onSlideBefore: function () { }, onSlideAfter: function () { }, onSlideNext: function () { }, onSlidePrev: function () { } }; t.fn.bxSlider = function (n) { if (0 == this.length) return this; if (this.length > 1) return this.each(function () { t(this).bxSlider(n) }), this; var o = {}, r = this; e.el = this; var a = t(window).width(), l = t(window).height(), d = function () { o.settings = t.extend({}, s, n), o.settings.slideWidth = parseInt(o.settings.slideWidth), o.children = r.children(o.settings.slideSelector), o.children.length < o.settings.minSlides && (o.settings.minSlides = o.children.length), o.children.length < o.settings.maxSlides && (o.settings.maxSlides = o.children.length), o.settings.randomStart && (o.settings.startSlide = Math.floor(Math.random() * o.children.length)), o.active = { index: o.settings.startSlide }, o.carousel = o.settings.minSlides > 1 || o.settings.maxSlides > 1, o.carousel && (o.settings.preloadImages = "all"), o.minThreshold = o.settings.minSlides * o.settings.slideWidth + (o.settings.minSlides - 1) * o.settings.slideMargin, o.maxThreshold = o.settings.maxSlides * o.settings.slideWidth + (o.settings.maxSlides - 1) * o.settings.slideMargin, o.working = !1, o.controls = {}, o.interval = null, o.animProp = "vertical" == o.settings.mode ? "top" : "left", o.usingCSS = o.settings.useCSS && "fade" != o.settings.mode && function () { var t = document.createElement("div"), e = ["WebkitPerspective", "MozPerspective", "OPerspective", "msPerspective"]; for (var i in e) if (void 0 !== t.style[e[i]]) return o.cssPrefix = e[i].replace("Perspective", "").toLowerCase(), o.animProp = "-" + o.cssPrefix + "-transform", !0; return !1 }(), "vertical" == o.settings.mode && (o.settings.maxSlides = o.settings.minSlides), r.data("origStyle", r.attr("style")), r.children(o.settings.slideSelector).each(function () { t(this).data("origStyle", t(this).attr("style")) }), c() }, c = function () { r.wrap('<div class="bx-wrapper"><div class="bx-viewport"></div></div>'), o.viewport = r.parent(), o.loader = t('<div class="bx-loading" />'), o.viewport.prepend(o.loader), r.css({ width: "horizontal" == o.settings.mode ? 100 * o.children.length + 215 + "%" : "auto", position: "relative" }), o.usingCSS && o.settings.easing ? r.css("-" + o.cssPrefix + "-transition-timing-function", o.settings.easing) : o.settings.easing || (o.settings.easing = "swing"), f(), o.viewport.css({ width: "100%", overflow: "hidden", position: "relative" }), o.viewport.parent().css({ maxWidth: v() }), o.settings.pager || o.viewport.parent().css({ margin: "0 auto 0px" }), o.children.css({ "float": "horizontal" == o.settings.mode ? "left" : "none", listStyle: "none", position: "relative" }), o.children.css("width", u()), "horizontal" == o.settings.mode && o.settings.slideMargin > 0 && o.children.css("marginRight", o.settings.slideMargin), "vertical" == o.settings.mode && o.settings.slideMargin > 0 && o.children.css("marginBottom", o.settings.slideMargin), "fade" == o.settings.mode && (o.children.css({ position: "absolute", zIndex: 0, display: "none" }), o.children.eq(o.settings.startSlide).css({ zIndex: 50, display: "block" })), o.controls.el = t('<div class="bx-controls" />'), o.settings.captions && P(), o.active.last = o.settings.startSlide == x() - 1, o.settings.video && r.fitVids(); var e = o.children.eq(o.settings.startSlide); "all" == o.settings.preloadImages && (e = o.children), o.settings.ticker ? o.settings.pager = !1 : (o.settings.pager && T(), o.settings.controls && C(), o.settings.auto && o.settings.autoControls && E(), (o.settings.controls || o.settings.autoControls || o.settings.pager) && o.viewport.after(o.controls.el)), g(e, h) }, g = function (e, i) { var s = e.find("img, iframe").length; if (0 == s) return i(), void 0; var n = 0; e.find("img, iframe").each(function () { t(this).one("load", function () { ++n == s && i() }).each(function () { this.complete && t(this).load() }) }) }, h = function () { if (o.settings.infiniteLoop && "fade" != o.settings.mode && !o.settings.ticker) { var e = "vertical" == o.settings.mode ? o.settings.minSlides : o.settings.maxSlides, i = o.children.slice(0, e).clone().addClass("bx-clone"), s = o.children.slice(-e).clone().addClass("bx-clone"); r.append(i).prepend(s) } o.loader.remove(), S(), "vertical" == o.settings.mode && (o.settings.adaptiveHeight = !0), o.viewport.height(p()), r.redrawSlider(), o.settings.onSliderLoad(o.active.index), o.initialized = !0, o.settings.responsive && t(window).bind("resize", B), o.settings.auto && o.settings.autoStart && H(), o.settings.ticker && L(), o.settings.pager && I(o.settings.startSlide), o.settings.controls && W(), o.settings.touchEnabled && !o.settings.ticker && O() }, p = function () { var e = 0, s = t(); if ("vertical" == o.settings.mode || o.settings.adaptiveHeight) if (o.carousel) { var n = 1 == o.settings.moveSlides ? o.active.index : o.active.index * m(); for (s = o.children.eq(n), i = 1; i <= o.settings.maxSlides - 1; i++) s = n + i >= o.children.length ? s.add(o.children.eq(i - 1)) : s.add(o.children.eq(n + i)) } else s = o.children.eq(o.active.index); else s = o.children; return "vertical" == o.settings.mode ? (s.each(function () { e += t(this).outerHeight() }), o.settings.slideMargin > 0 && (e += o.settings.slideMargin * (o.settings.minSlides - 1))) : e = Math.max.apply(Math, s.map(function () { return t(this).outerHeight(!1) }).get()), e }, v = function () { var t = "100%"; return o.settings.slideWidth > 0 && (t = "horizontal" == o.settings.mode ? o.settings.maxSlides * o.settings.slideWidth + (o.settings.maxSlides - 1) * o.settings.slideMargin : o.settings.slideWidth), t }, u = function () { var t = o.settings.slideWidth, e = o.viewport.width(); return 0 == o.settings.slideWidth || o.settings.slideWidth > e && !o.carousel || "vertical" == o.settings.mode ? t = e : o.settings.maxSlides > 1 && "horizontal" == o.settings.mode && (e > o.maxThreshold || e < o.minThreshold && (t = (e - o.settings.slideMargin * (o.settings.minSlides - 1)) / o.settings.minSlides)), t }, f = function () { var t = 1; if ("horizontal" == o.settings.mode && o.settings.slideWidth > 0) if (o.viewport.width() < o.minThreshold) t = o.settings.minSlides; else if (o.viewport.width() > o.maxThreshold) t = o.settings.maxSlides; else { var e = o.children.first().width(); t = Math.floor(o.viewport.width() / e) } else "vertical" == o.settings.mode && (t = o.settings.minSlides); return t }, x = function () { var t = 0; if (o.settings.moveSlides > 0) if (o.settings.infiniteLoop) t = o.children.length / m(); else for (var e = 0, i = 0; e < o.children.length;)++t, e = i + f(), i += o.settings.moveSlides <= f() ? o.settings.moveSlides : f(); else t = Math.ceil(o.children.length / f()); return t }, m = function () { return o.settings.moveSlides > 0 && o.settings.moveSlides <= f() ? o.settings.moveSlides : f() }, S = function () { if (o.children.length > o.settings.maxSlides && o.active.last && !o.settings.infiniteLoop) { if ("horizontal" == o.settings.mode) { var t = o.children.last(), e = t.position(); b(-(e.left - (o.viewport.width() - t.width())), "reset", 0) } else if ("vertical" == o.settings.mode) { var i = o.children.length - o.settings.minSlides, e = o.children.eq(i).position(); b(-e.top, "reset", 0) } } else { var e = o.children.eq(o.active.index * m()).position(); o.active.index == x() - 1 && (o.active.last = !0), void 0 != e && ("horizontal" == o.settings.mode ? b(-e.left, "reset", 0) : "vertical" == o.settings.mode && b(-e.top, "reset", 0)) } }, b = function (t, e, i, s) { if (o.usingCSS) { var n = "vertical" == o.settings.mode ? "translate3d(0, " + t + "px, 0)" : "translate3d(" + t + "px, 0, 0)"; r.css("-" + o.cssPrefix + "-transition-duration", i / 1e3 + "s"), "slide" == e ? (r.css(o.animProp, n), r.bind("transitionend webkitTransitionEnd oTransitionEnd MSTransitionEnd", function () { r.unbind("transitionend webkitTransitionEnd oTransitionEnd MSTransitionEnd"), D() })) : "reset" == e ? r.css(o.animProp, n) : "ticker" == e && (r.css("-" + o.cssPrefix + "-transition-timing-function", "linear"), r.css(o.animProp, n), r.bind("transitionend webkitTransitionEnd oTransitionEnd MSTransitionEnd", function () { r.unbind("transitionend webkitTransitionEnd oTransitionEnd MSTransitionEnd"), b(s.resetValue, "reset", 0), N() })) } else { var a = {}; a[o.animProp] = t, "slide" == e ? r.animate(a, i, o.settings.easing, function () { D() }) : "reset" == e ? r.css(o.animProp, t) : "ticker" == e && r.animate(a, speed, "linear", function () { b(s.resetValue, "reset", 0), N() }) } }, w = function () { for (var e = "", i = x(), s = 0; i > s; s++) { var n = ""; o.settings.buildPager && t.isFunction(o.settings.buildPager) ? (n = o.settings.buildPager(s), o.pagerEl.addClass("bx-custom-pager")) : (n = s + 1, o.pagerEl.addClass("bx-default-pager")), e += '<div class="bx-pager-item"><a href="" data-slide-index="' + s + '" class="bx-pager-link">' + n + "</a></div>" } o.pagerEl.html(e) }, T = function () { o.settings.pagerCustom ? o.pagerEl = t(o.settings.pagerCustom) : (o.pagerEl = t('<div class="bx-pager" />'), o.settings.pagerSelector ? t(o.settings.pagerSelector).html(o.pagerEl) : o.controls.el.addClass("bx-has-pager").append(o.pagerEl), w()), o.pagerEl.delegate("a", "click", q) }, C = function () { o.controls.next = t('<a class="bx-next" href="">' + o.settings.nextText + "</a>"), o.controls.prev = t('<a class="bx-prev" href="">' + o.settings.prevText + "</a>"), o.controls.next.bind("click", y), o.controls.prev.bind("click", z), o.settings.nextSelector && t(o.settings.nextSelector).append(o.controls.next), o.settings.prevSelector && t(o.settings.prevSelector).append(o.controls.prev), o.settings.nextSelector || o.settings.prevSelector || (o.controls.directionEl = t('<div class="bx-controls-direction" />'), o.controls.directionEl.append(o.controls.prev).append(o.controls.next), o.controls.el.addClass("bx-has-controls-direction").append(o.controls.directionEl)) }, E = function () { o.controls.start = t('<div class="bx-controls-auto-item"><a class="bx-start" href="">' + o.settings.startText + "</a></div>"), o.controls.stop = t('<div class="bx-controls-auto-item"><a class="bx-stop" href="">' + o.settings.stopText + "</a></div>"), o.controls.autoEl = t('<div class="bx-controls-auto" />'), o.controls.autoEl.delegate(".bx-start", "click", k), o.controls.autoEl.delegate(".bx-stop", "click", M), o.settings.autoControlsCombine ? o.controls.autoEl.append(o.controls.start) : o.controls.autoEl.append(o.controls.start).append(o.controls.stop), o.settings.autoControlsSelector ? t(o.settings.autoControlsSelector).html(o.controls.autoEl) : o.controls.el.addClass("bx-has-controls-auto").append(o.controls.autoEl), A(o.settings.autoStart ? "stop" : "start") }, P = function () { o.children.each(function () { var e = t(this).find("img:first").attr("title"); void 0 != e && ("" + e).length && t(this).append('<div class="bx-caption"><span>' + e + "</span></div>") }) }, y = function (t) { o.settings.auto && r.stopAuto(), r.goToNextSlide(), t.preventDefault() }, z = function (t) { o.settings.auto && r.stopAuto(), r.goToPrevSlide(), t.preventDefault() }, k = function (t) { r.startAuto(), t.preventDefault() }, M = function (t) { r.stopAuto(), t.preventDefault() }, q = function (e) { o.settings.auto && r.stopAuto(); var i = t(e.currentTarget), s = parseInt(i.attr("data-slide-index")); s != o.active.index && r.goToSlide(s), e.preventDefault() }, I = function (e) { var i = o.children.length; return "short" == o.settings.pagerType ? (o.settings.maxSlides > 1 && (i = Math.ceil(o.children.length / o.settings.maxSlides)), o.pagerEl.html(e + 1 + o.settings.pagerShortSeparator + i), void 0) : (o.pagerEl.find("a").removeClass("active"), o.pagerEl.each(function (i, s) { t(s).find("a").eq(e).addClass("active") }), void 0) }, D = function () { if (o.settings.infiniteLoop) { var t = ""; 0 == o.active.index ? t = o.children.eq(0).position() : o.active.index == x() - 1 && o.carousel ? t = o.children.eq((x() - 1) * m()).position() : o.active.index == o.children.length - 1 && (t = o.children.eq(o.children.length - 1).position()), "horizontal" == o.settings.mode ? b(-t.left, "reset", 0) : "vertical" == o.settings.mode && b(-t.top, "reset", 0) } o.working = !1, o.settings.onSlideAfter(o.children.eq(o.active.index), o.oldIndex, o.active.index) }, A = function (t) { o.settings.autoControlsCombine ? o.controls.autoEl.html(o.controls[t]) : (o.controls.autoEl.find("a").removeClass("active"), o.controls.autoEl.find("a:not(.bx-" + t + ")").addClass("active")) }, W = function () { 1 == x() ? (o.controls.prev.addClass("disabled"), o.controls.next.addClass("disabled")) : !o.settings.infiniteLoop && o.settings.hideControlOnEnd && (0 == o.active.index ? (o.controls.prev.addClass("disabled"), o.controls.next.removeClass("disabled")) : o.active.index == x() - 1 ? (o.controls.next.addClass("disabled"), o.controls.prev.removeClass("disabled")) : (o.controls.prev.removeClass("disabled"), o.controls.next.removeClass("disabled"))) }, H = function () { o.settings.autoDelay > 0 ? setTimeout(r.startAuto, o.settings.autoDelay) : r.startAuto(), o.settings.autoHover && r.hover(function () { o.interval && (r.stopAuto(!0), o.autoPaused = !0) }, function () { o.autoPaused && (r.startAuto(!0), o.autoPaused = null) }) }, L = function () { var e = 0; if ("next" == o.settings.autoDirection) r.append(o.children.clone().addClass("bx-clone")); else { r.prepend(o.children.clone().addClass("bx-clone")); var i = o.children.first().position(); e = "horizontal" == o.settings.mode ? -i.left : -i.top } b(e, "reset", 0), o.settings.pager = !1, o.settings.controls = !1, o.settings.autoControls = !1, o.settings.tickerHover && !o.usingCSS && o.viewport.hover(function () { r.stop() }, function () { var e = 0; o.children.each(function () { e += "horizontal" == o.settings.mode ? t(this).outerWidth(!0) : t(this).outerHeight(!0) }); var i = o.settings.speed / e, s = "horizontal" == o.settings.mode ? "left" : "top", n = i * (e - Math.abs(parseInt(r.css(s)))); N(n) }), N() }, N = function (t) { speed = t ? t : o.settings.speed; var e = { left: 0, top: 0 }, i = { left: 0, top: 0 }; "next" == o.settings.autoDirection ? e = r.find(".bx-clone").first().position() : i = o.children.first().position(); var s = "horizontal" == o.settings.mode ? -e.left : -e.top, n = "horizontal" == o.settings.mode ? -i.left : -i.top, a = { resetValue: n }; b(s, "ticker", speed, a) }, O = function () { o.touch = { start: { x: 0, y: 0 }, end: { x: 0, y: 0 } }, o.viewport.bind("touchstart", X) }, X = function (t) { if (o.working) t.preventDefault(); else { o.touch.originalPos = r.position(); var e = t.originalEvent; o.touch.start.x = e.changedTouches[0].pageX, o.touch.start.y = e.changedTouches[0].pageY, o.viewport.bind("touchmove", Y), o.viewport.bind("touchend", V) } }, Y = function (t) { var e = t.originalEvent, i = Math.abs(e.changedTouches[0].pageX - o.touch.start.x), s = Math.abs(e.changedTouches[0].pageY - o.touch.start.y); if (3 * i > s && o.settings.preventDefaultSwipeX ? t.preventDefault() : 3 * s > i && o.settings.preventDefaultSwipeY && t.preventDefault(), "fade" != o.settings.mode && o.settings.oneToOneTouch) { var n = 0; if ("horizontal" == o.settings.mode) { var r = e.changedTouches[0].pageX - o.touch.start.x; n = o.touch.originalPos.left + r } else { var r = e.changedTouches[0].pageY - o.touch.start.y; n = o.touch.originalPos.top + r } b(n, "reset", 0) } }, V = function (t) { o.viewport.unbind("touchmove", Y); var e = t.originalEvent, i = 0; if (o.touch.end.x = e.changedTouches[0].pageX, o.touch.end.y = e.changedTouches[0].pageY, "fade" == o.settings.mode) { var s = Math.abs(o.touch.start.x - o.touch.end.x); s >= o.settings.swipeThreshold && (o.touch.start.x > o.touch.end.x ? r.goToNextSlide() : r.goToPrevSlide(), r.stopAuto()) } else { var s = 0; "horizontal" == o.settings.mode ? (s = o.touch.end.x - o.touch.start.x, i = o.touch.originalPos.left) : (s = o.touch.end.y - o.touch.start.y, i = o.touch.originalPos.top), !o.settings.infiniteLoop && (0 == o.active.index && s > 0 || o.active.last && 0 > s) ? b(i, "reset", 200) : Math.abs(s) >= o.settings.swipeThreshold ? (0 > s ? r.goToNextSlide() : r.goToPrevSlide(), r.stopAuto()) : b(i, "reset", 200) } o.viewport.unbind("touchend", V) }, B = function () { var e = t(window).width(), i = t(window).height(); (a != e || l != i) && (a = e, l = i, r.redrawSlider()) }; return r.goToSlide = function (e, i) { if (!o.working && o.active.index != e) if (o.working = !0, o.oldIndex = o.active.index, o.active.index = 0 > e ? x() - 1 : e >= x() ? 0 : e, o.settings.onSlideBefore(o.children.eq(o.active.index), o.oldIndex, o.active.index), "next" == i ? o.settings.onSlideNext(o.children.eq(o.active.index), o.oldIndex, o.active.index) : "prev" == i && o.settings.onSlidePrev(o.children.eq(o.active.index), o.oldIndex, o.active.index), o.active.last = o.active.index >= x() - 1, o.settings.pager && I(o.active.index), o.settings.controls && W(), "fade" == o.settings.mode) o.settings.adaptiveHeight && o.viewport.height() != p() && o.viewport.animate({ height: p() }, o.settings.adaptiveHeightSpeed), o.children.filter(":visible").fadeOut(o.settings.speed).css({ zIndex: 0 }), o.children.eq(o.active.index).css("zIndex", 51).fadeIn(o.settings.speed, function () { t(this).css("zIndex", 50), D() }); else { o.settings.adaptiveHeight && o.viewport.height() != p() && o.viewport.animate({ height: p() }, o.settings.adaptiveHeightSpeed); var s = 0, n = { left: 0, top: 0 }; if (!o.settings.infiniteLoop && o.carousel && o.active.last) if ("horizontal" == o.settings.mode) { var a = o.children.eq(o.children.length - 1); n = a.position(), s = o.viewport.width() - a.outerWidth() } else { var l = o.children.length - o.settings.minSlides; n = o.children.eq(l).position() } else if (o.carousel && o.active.last && "prev" == i) { var d = 1 == o.settings.moveSlides ? o.settings.maxSlides - m() : (x() - 1) * m() - (o.children.length - o.settings.maxSlides), a = r.children(".bx-clone").eq(d); n = a.position() } else if ("next" == i && 0 == o.active.index) n = r.find("> .bx-clone").eq(o.settings.maxSlides).position(), o.active.last = !1; else if (e >= 0) { var c = e * m(); n = o.children.eq(c).position() } if ("undefined" != typeof n) { var g = "horizontal" == o.settings.mode ? -(n.left - s) : -n.top; b(g, "slide", o.settings.speed) } } }, r.goToNextSlide = function () { if (o.settings.infiniteLoop || !o.active.last) { var t = parseInt(o.active.index) + 1; r.goToSlide(t, "next") } }, r.goToPrevSlide = function () { if (o.settings.infiniteLoop || 0 != o.active.index) { var t = parseInt(o.active.index) - 1; r.goToSlide(t, "prev") } }, r.startAuto = function (t) { o.interval || (o.interval = setInterval(function () { "next" == o.settings.autoDirection ? r.goToNextSlide() : r.goToPrevSlide() }, o.settings.pause), o.settings.autoControls && 1 != t && A("stop")) }, r.stopAuto = function (t) { o.interval && (clearInterval(o.interval), o.interval = null, o.settings.autoControls && 1 != t && A("start")) }, r.getCurrentSlide = function () { return o.active.index }, r.getSlideCount = function () { return o.children.length }, r.redrawSlider = function () { o.children.add(r.find(".bx-clone")).outerWidth(u()), o.viewport.css("height", p()), o.settings.ticker || S(), o.active.last && (o.active.index = x() - 1), o.active.index >= x() && (o.active.last = !0), o.settings.pager && !o.settings.pagerCustom && (w(), I(o.active.index)) }, r.destroySlider = function () { o.initialized && (o.initialized = !1, t(".bx-clone", this).remove(), o.children.each(function () { void 0 != t(this).data("origStyle") ? t(this).attr("style", t(this).data("origStyle")) : t(this).removeAttr("style") }), void 0 != t(this).data("origStyle") ? this.attr("style", t(this).data("origStyle")) : t(this).removeAttr("style"), t(this).unwrap().unwrap(), o.controls.el && o.controls.el.remove(), o.controls.next && o.controls.next.remove(), o.controls.prev && o.controls.prev.remove(), o.pagerEl && o.pagerEl.remove(), t(".bx-caption", this).remove(), o.controls.autoEl && o.controls.autoEl.remove(), clearInterval(o.interval), o.settings.responsive && t(window).unbind("resize", B)) }, r.reloadSlider = function (t) { void 0 != t && (n = t), r.destroySlider(), d() }, d(), this } }(jQuery);//Initial setup of nav menu element. PAss through either the ajax url of the ul of the id of the node containing the ul. url must either be valid or null
function initializeMobileNav(url, navId) {
    $(".immi-mobile-icon-nav").click(function () {
        if (!$("#immi-mobile-nav").length) {
            loadMobileNav("#mobile-menu-container", url, navId);
            $(this).addClass("open");
        }
        else {
            $("#immi-mobile-nav").toggle();
        }
        $(this).toggleClass("open").toggleClass("closed");
        if ($(this).html() == mnText[0]) {
            $(this).html(mnText[1]);
        }
        else {
            $(this).html(mnText[0]);
        }
        $("body").toggleClass("mobile-nav-show");
        return false;
    });
}

function loadMobileNav(id, url, node) {
    $("#main").prepend("<div id='mobile-menu-container'></div>");
    //Load the menu from a url via ajax call
    if (url) {
        $(id).load(url, function (data) {
            processMobileNav(id);
        });
    }
    else if (node) {
        var ul = $(node).find("ul:first").clone(false);
        $(id).append("<div class=\"immi-mobile-menu\" id=\"immi-mobile-nav\"><div class=\"immi-mobile-main-menu\"</div></div>");
        $(id).find(".immi-mobile-main-menu").append(ul);
        processMobileNav(id);
    }
    
}
function processMobileNav(id) {
    var longFileName = "/" + window.location.pathname.split('/').pop();
    var shortFileName = longFileName.split(".aspx")[0];
    var pathName = window.location.pathname;
    var currentFound = false;
    $(id + " li").each(function () {
        //Check for current page     
        var href = $(this).find("a:first").attr("href");
        //console.log(longFileName + " : " + shortFileName + " : " + href);
        if (!currentFound) {
            if (href == longFileName || href == shortFileName || href == pathName) {
                $(this).find("a:first").addClass("current");
                currentFound = true;
            }
        }
        if ($(this).find("ul").length) {
            var node = $(this).children().first();
            var title = node.text();
            node.after("<a href=\"#\" class=\"closed sub\"><span class=\"screen-reader-text\">Open " + title + "</span></a>");
        }
    });
    $(id + " li .sub").click(function () {
        if ($(this).hasClass("open")) {
            $(this).next().slideUp();
        }
        else {
            $(this).next().slideDown();
        }

        $(this).toggleClass("open");
        $(this).toggleClass("closed");
        return false;

    });
    //Highlight current menu item
    $(".current").parentsUntil("ul.mobile-nav").show();
    $(".current").find("ul:first").show();
}/*
$(".cm-element-pdf").bind('click', function (event) {
    cmCreateElementTag(this.text,'PDF');
});
*/


/*
* SPImageFieldUpload - Extends SharePoint's RichImageFieldControl using jQuery
* Version 0.2
* @requires jQuery v1.4.2 or greater - jQuery 1.7+ recommended
*
* Copyright (c) 2012 Arnault Nouvel
* Examples and docs at:
* https://spimagefieldupload.codeplex.com/
* Licensed under the MIT license:
* http://www.opensource.org/licenses/mit-license.php
*/

//Language dictionary. Add a translation here if needed
var arUploadLinkText = {};
arUploadLinkText[1036] = "Cliquez ici pour ajouter une image  partir de votre ordinateur.";
arUploadLinkText[1033] = "Click here to insert a picture from your computer.";

jQuery(document).ready(function () {

    //For each RichImageFieldControl in the page (only in edit mode)
    jQuery('a[id$="AddAssetPromptLink"]').each(function () {

        var selectorId = jQuery(this).attr("SelectorID");

        //Gets the translated text from the array
        var lkText = arUploadLinkText[SP.Res.lcid] ? arUploadLinkText[SP.Res.lcid] : arUploadLinkText[1033];

        //Adds a new link that allows to insert an image from the computer 
        lkId = jQuery(this).attr("id") + "_FromComp";
        jQuery(this).after('<br /><a href="#" class="ms-toolbar ms-selectorlink" target="_self" id="' + lkId + '" >' + lkText + '</a>');

        $lk = jQuery("#" + lkId);
        $lk.click(function () {

            //If the link is clicked, show the existing RteUploadDialog.aspx page as a popup
            var dialog = {
                url: SP.Utilities.Utility.getLayoutsPageUrl("RteUploadDialog.aspx") + "?LCID=" + SP.Res.lcid + "&Dialog=UploadImage&UseDivDialog=true&Source=" + encodeURIComponent(window.location),
                allowMaximize: true,
                showClose: true,
                width: 500,
                height: 160,
                dialogReturnValueCallback: function (success, html) {
                    if (success) {
                        //Gets the picture's url from the popup, shows it and hides the links
                        var $emptyPanel = jQuery("#" + selectorId + "_EmptyPanel");
                        var $assetSelectedPanel = jQuery("#" + selectorId + "_AssetSelectedPanel");
                        var $imageFieldDisplay = jQuery("#" + selectorId + "_ImageFieldDisplay");

                        $imageFieldDisplay.html(html);
                        $emptyPanel.css("display", "none");
                        $assetSelectedPanel.css("display", "inline");
                    }
                }
            };

            thisDialog = SP.UI.ModalDialog.showModalDialog(dialog);

        });

    });
});/*
* @fileOverview TouchSwipe - jQuery Plugin
* @version 1.6.5
*
* @author Matt Bryson http://www.github.com/mattbryson
* @see https://github.com/mattbryson/TouchSwipe-Jquery-Plugin
* @see http://labs.skinkers.com/touchSwipe/
* @see http://plugins.jquery.com/project/touchSwipe
*
* Copyright (c) 2010 Matt Bryson
* Dual licensed under the MIT or GPL Version 2 licenses.
*
*
* Changelog
* $Date: 2010-12-12 (Wed, 12 Dec 2010) $
* $version: 1.0.0
* $version: 1.0.1 - removed multibyte comments
*
* $Date: 2011-21-02 (Mon, 21 Feb 2011) $
* $version: 1.1.0 	- added allowPageScroll property to allow swiping and scrolling of page
*					- changed handler signatures so one handler can be used for multiple events
* $Date: 2011-23-02 (Wed, 23 Feb 2011) $
* $version: 1.2.0 	- added click handler. This is fired if the user simply clicks and does not swipe. The event object and click target are passed to handler.
*					- If you use the http://code.google.com/p/jquery-ui-for-ipad-and-iphone/ plugin, you can also assign jQuery mouse events to children of a touchSwipe object.
* $version: 1.2.1 	- removed console log!
*
* $version: 1.2.2 	- Fixed bug where scope was not preserved in callback methods.
*
* $Date: 2011-28-04 (Thurs, 28 April 2011) $
* $version: 1.2.4 	- Changed licence terms to be MIT or GPL inline with jQuery. Added check for support of touch events to stop non compatible browsers erroring.
*
* $Date: 2011-27-09 (Tues, 27 September 2011) $
* $version: 1.2.5 	- Added support for testing swipes with mouse on desktop browser (thanks to https://github.com/joelhy)
*
* $Date: 2012-14-05 (Mon, 14 May 2012) $
* $version: 1.2.6 	- Added timeThreshold between start and end touch, so user can ignore slow swipes (thanks to Mark Chase). Default is null, all swipes are detected
*
* $Date: 2012-05-06 (Tues, 05 June 2012) $
* $version: 1.2.7 	- Changed time threshold to have null default for backwards compatibility. Added duration param passed back in events, and refactored how time is handled.
*
* $Date: 2012-05-06 (Tues, 05 June 2012) $
* $version: 1.2.8 	- Added the possibility to return a value like null or false in the trigger callback. In that way we can control when the touch start/move should take effect or not (simply by returning in some cases return null; or return false;) This effects the ontouchstart/ontouchmove event.
*
* $Date: 2012-06-06 (Wed, 06 June 2012) $
* $version: 1.3.0 	- Refactored whole plugin to allow for methods to be executed, as well as exposed defaults for user override. Added 'enable', 'disable', and 'destroy' methods
*
* $Date: 2012-05-06 (Fri, 05 June 2012) $
* $version: 1.3.1 	- Bug fixes  - bind() with false as last argument is no longer supported in jQuery 1.6, also, if you just click, the duration is now returned correctly.
*
* $Date: 2012-29-07 (Sun, 29 July 2012) $
* $version: 1.3.2	- Added fallbackToMouseEvents option to NOT capture mouse events on non touch devices.
* 			- Added "all" fingers value to the fingers property, so any combination of fingers triggers the swipe, allowing event handlers to check the finger count
*
* $Date: 2012-09-08 (Thurs, 9 Aug 2012) $
* $version: 1.3.3	- Code tidy prep for minefied version
*
* $Date: 2012-04-10 (wed, 4 Oct 2012) $
* $version: 1.4.0	- Added pinch support, pinchIn and pinchOut
*
* $Date: 2012-11-10 (Thurs, 11 Oct 2012) $
* $version: 1.5.0	- Added excludedElements, a jquery selector that specifies child elements that do NOT trigger swipes. By default, this is one select that removes all form, input select, button and anchor elements.
*
* $Date: 2012-22-10 (Mon, 22 Oct 2012) $
* $version: 1.5.1	- Fixed bug with jQuery 1.8 and trailing comma in excludedElements
*					- Fixed bug with IE and eventPreventDefault()
* $Date: 2013-01-12 (Fri, 12 Jan 2013) $
* $version: 1.6.0	- Fixed bugs with pinching, mainly when both pinch and swipe enabled, as well as adding time threshold for multifinger gestures, so releasing one finger beofre the other doesnt trigger as single finger gesture.
*					- made the demo site all static local HTML pages so they can be run locally by a developer
*					- added jsDoc comments and added documentation for the plugin	
*					- code tidy
*					- added triggerOnTouchLeave property that will end the event when the user swipes off the element.
* $Date: 2013-03-23 (Sat, 23 Mar 2013) $
* $version: 1.6.1	- Added support for ie8 touch events
* $version: 1.6.2	- Added support for events binding with on / off / bind in jQ for all callback names.
*                   - Deprecated the 'click' handler in favour of tap.
*                   - added cancelThreshold property
*                   - added option method to update init options at runtime
*
* $version 1.6.3    - added doubletap, longtap events and longTapThreshold, doubleTapThreshold property
* $Date: 2013-04-04 (Thurs, 04 April 2013) $
* $version 1.6.4    - Fixed bug with cancelThreshold introduced in 1.6.3, where swipe status no longer fired start event, and stopped once swiping back.
*
* $Date: 2013-08-24 (Sat, 24 Aug 2013) $
* $version 1.6.5    - Merged a few pull requests fixing various bugs, added AMD support.

*/

/**
 * See (http://jquery.com/).
 * @name $
 * @class 
 * See the jQuery Library  (http://jquery.com/) for full details.  This just
 * documents the function and classes that are added to jQuery by this plug-in.
 */

/**
 * See (http://jquery.com/)
 * @name fn
 * @class 
 * See the jQuery Library  (http://jquery.com/) for full details.  This just
 * documents the function and classes that are added to jQuery by this plug-in.
 * @memberOf $
 */



(function (factory) {
    if (typeof define === 'function' && define.amd && define.amd.jQuery) {
        // AMD. Register as anonymous module.
        define(['jquery'], factory);
    } else {
        // Browser globals.
        factory(jQuery);
    }
}(function ($) {
    "use strict";

    //Constants
    var LEFT = "left",
		RIGHT = "right",
		UP = "up",
		DOWN = "down",
		IN = "in",
		OUT = "out",

		NONE = "none",
		AUTO = "auto",

		SWIPE = "swipe",
		PINCH = "pinch",
		TAP = "tap",
		DOUBLE_TAP = "doubletap",
		LONG_TAP = "longtap",

		HORIZONTAL = "horizontal",
		VERTICAL = "vertical",

		ALL_FINGERS = "all",

		DOUBLE_TAP_THRESHOLD = 10,

		PHASE_START = "start",
		PHASE_MOVE = "move",
		PHASE_END = "end",
		PHASE_CANCEL = "cancel",

		SUPPORTS_TOUCH = 'ontouchstart' in window,

		PLUGIN_NS = 'TouchSwipe';



    /**
	* The default configuration, and available options to configure touch swipe with.
	* You can set the default values by updating any of the properties prior to instantiation.
	* @name $.fn.swipe.defaults
	* @namespace
	* @property {int} [fingers=1] The number of fingers to detect in a swipe. Any swipes that do not meet this requirement will NOT trigger swipe handlers.
	* @property {int} [threshold=75] The number of pixels that the user must move their finger by before it is considered a swipe. 
	* @property {int} [cancelThreshold=null] The number of pixels that the user must move their finger back from the original swipe direction to cancel the gesture.
	* @property {int} [pinchThreshold=20] The number of pixels that the user must pinch their finger by before it is considered a pinch. 
	* @property {int} [maxTimeThreshold=null] Time, in milliseconds, between touchStart and touchEnd must NOT exceed in order to be considered a swipe. 
	* @property {int} [fingerReleaseThreshold=250] Time in milliseconds between releasing multiple fingers.  If 2 fingers are down, and are released one after the other, if they are within this threshold, it counts as a simultaneous release. 
	* @property {int} [longTapThreshold=500] Time in milliseconds between tap and release for a long tap
    * @property {int} [doubleTapThreshold=200] Time in milliseconds between 2 taps to count as a double tap
	* @property {function} [swipe=null] A handler to catch all swipes. See {@link $.fn.swipe#event:swipe}
	* @property {function} [swipeLeft=null] A handler that is triggered for "left" swipes. See {@link $.fn.swipe#event:swipeLeft}
	* @property {function} [swipeRight=null] A handler that is triggered for "right" swipes. See {@link $.fn.swipe#event:swipeRight}
	* @property {function} [swipeUp=null] A handler that is triggered for "up" swipes. See {@link $.fn.swipe#event:swipeUp}
	* @property {function} [swipeDown=null] A handler that is triggered for "down" swipes. See {@link $.fn.swipe#event:swipeDown}
	* @property {function} [swipeStatus=null] A handler triggered for every phase of the swipe. See {@link $.fn.swipe#event:swipeStatus}
	* @property {function} [pinchIn=null] A handler triggered for pinch in events. See {@link $.fn.swipe#event:pinchIn}
	* @property {function} [pinchOut=null] A handler triggered for pinch out events. See {@link $.fn.swipe#event:pinchOut}
	* @property {function} [pinchStatus=null] A handler triggered for every phase of a pinch. See {@link $.fn.swipe#event:pinchStatus}
	* @property {function} [tap=null] A handler triggered when a user just taps on the item, rather than swipes it. If they do not move, tap is triggered, if they do move, it is not. 
	* @property {function} [doubleTap=null] A handler triggered when a user double taps on the item. The delay between taps can be set with the doubleTapThreshold property. See {@link $.fn.swipe.defaults#doubleTapThreshold}
	* @property {function} [longTap=null] A handler triggered when a user long taps on the item. The delay between start and end can be set with the longTapThreshold property. See {@link $.fn.swipe.defaults#doubleTapThreshold}
	* @property {boolean} [triggerOnTouchEnd=true] If true, the swipe events are triggered when the touch end event is received (user releases finger).  If false, it will be triggered on reaching the threshold, and then cancel the touch event automatically. 
	* @property {boolean} [triggerOnTouchLeave=false] If true, then when the user leaves the swipe object, the swipe will end and trigger appropriate handlers. 
	* @property {string|undefined} [allowPageScroll='auto'] How the browser handles page scrolls when the user is swiping on a touchSwipe object. See {@link $.fn.swipe.pageScroll}.  <br/><br/>
										<code>"auto"</code> : all undefined swipes will cause the page to scroll in that direction. <br/>
										<code>"none"</code> : the page will not scroll when user swipes. <br/>
										<code>"horizontal"</code> : will force page to scroll on horizontal swipes. <br/>
										<code>"vertical"</code> : will force page to scroll on vertical swipes. <br/>
	* @property {boolean} [fallbackToMouseEvents=true] If true mouse events are used when run on a non touch device, false will stop swipes being triggered by mouse events on non tocuh devices. 
	* @property {string} [excludedElements="button, input, select, textarea, a, .noSwipe"] A jquery selector that specifies child elements that do NOT trigger swipes. By default this excludes all form, input, select, button, anchor and .noSwipe elements. 
	
	*/
    var defaults = {
        fingers: 1,
        threshold: 75,
        cancelThreshold: null,
        pinchThreshold: 20,
        maxTimeThreshold: null,
        fingerReleaseThreshold: 250,
        longTapThreshold: 500,
        doubleTapThreshold: 200,
        swipe: null,
        swipeLeft: null,
        swipeRight: null,
        swipeUp: null,
        swipeDown: null,
        swipeStatus: null,
        pinchIn: null,
        pinchOut: null,
        pinchStatus: null,
        click: null, //Deprecated since 1.6.2
        tap: null,
        doubleTap: null,
        longTap: null,
        triggerOnTouchEnd: true,
        triggerOnTouchLeave: false,
        allowPageScroll: "auto",
        fallbackToMouseEvents: true,
        excludedElements: "label, button, input, select, textarea, a, .noSwipe"
    };



    /**
	* Applies TouchSwipe behaviour to one or more jQuery objects.
	* The TouchSwipe plugin can be instantiated via this method, or methods within 
	* TouchSwipe can be executed via this method as per jQuery plugin architecture.
	* @see TouchSwipe
	* @class
	* @param {Mixed} method If the current DOMNode is a TouchSwipe object, and <code>method</code> is a TouchSwipe method, then
	* the <code>method</code> is executed, and any following arguments are passed to the TouchSwipe method.
	* If <code>method</code> is an object, then the TouchSwipe class is instantiated on the current DOMNode, passing the 
	* configuration properties defined in the object. See TouchSwipe
	*
	*/
    $.fn.swipe = function (method) {
        var $this = $(this),
			plugin = $this.data(PLUGIN_NS);

        //Check if we are already instantiated and trying to execute a method	
        if (plugin && typeof method === 'string') {
            if (plugin[method]) {
                return plugin[method].apply(this, Array.prototype.slice.call(arguments, 1));
            } else {
                $.error('Method ' + method + ' does not exist on jQuery.swipe');
            }
        }
            //Else not instantiated and trying to pass init object (or nothing)
        else if (!plugin && (typeof method === 'object' || !method)) {
            return init.apply(this, arguments);
        }

        return $this;
    };

    //Expose our defaults so a user could override the plugin defaults
    $.fn.swipe.defaults = defaults;

    /**
	* The phases that a touch event goes through.  The <code>phase</code> is passed to the event handlers. 
	* These properties are read only, attempting to change them will not alter the values passed to the event handlers.
	* @namespace
	* @readonly
	* @property {string} PHASE_START Constant indicating the start phase of the touch event. Value is <code>"start"</code>.
	* @property {string} PHASE_MOVE Constant indicating the move phase of the touch event. Value is <code>"move"</code>.
	* @property {string} PHASE_END Constant indicating the end phase of the touch event. Value is <code>"end"</code>.
	* @property {string} PHASE_CANCEL Constant indicating the cancel phase of the touch event. Value is <code>"cancel"</code>.
	*/
    $.fn.swipe.phases = {
        PHASE_START: PHASE_START,
        PHASE_MOVE: PHASE_MOVE,
        PHASE_END: PHASE_END,
        PHASE_CANCEL: PHASE_CANCEL
    };

    /**
	* The direction constants that are passed to the event handlers. 
	* These properties are read only, attempting to change them will not alter the values passed to the event handlers.
	* @namespace
	* @readonly
	* @property {string} LEFT Constant indicating the left direction. Value is <code>"left"</code>.
	* @property {string} RIGHT Constant indicating the right direction. Value is <code>"right"</code>.
	* @property {string} UP Constant indicating the up direction. Value is <code>"up"</code>.
	* @property {string} DOWN Constant indicating the down direction. Value is <code>"cancel"</code>.
	* @property {string} IN Constant indicating the in direction. Value is <code>"in"</code>.
	* @property {string} OUT Constant indicating the out direction. Value is <code>"out"</code>.
	*/
    $.fn.swipe.directions = {
        LEFT: LEFT,
        RIGHT: RIGHT,
        UP: UP,
        DOWN: DOWN,
        IN: IN,
        OUT: OUT
    };

    /**
	* The page scroll constants that can be used to set the value of <code>allowPageScroll</code> option
	* These properties are read only
	* @namespace
	* @readonly
	* @see $.fn.swipe.defaults#allowPageScroll
	* @property {string} NONE Constant indicating no page scrolling is allowed. Value is <code>"none"</code>.
	* @property {string} HORIZONTAL Constant indicating horizontal page scrolling is allowed. Value is <code>"horizontal"</code>.
	* @property {string} VERTICAL Constant indicating vertical page scrolling is allowed. Value is <code>"vertical"</code>.
	* @property {string} AUTO Constant indicating either horizontal or vertical will be allowed, depending on the swipe handlers registered. Value is <code>"auto"</code>.
	*/
    $.fn.swipe.pageScroll = {
        NONE: NONE,
        HORIZONTAL: HORIZONTAL,
        VERTICAL: VERTICAL,
        AUTO: AUTO
    };

    /**
	* Constants representing the number of fingers used in a swipe.  These are used to set both the value of <code>fingers</code> in the 
	* options object, as well as the value of the <code>fingers</code> event property.
	* These properties are read only, attempting to change them will not alter the values passed to the event handlers.
	* @namespace
	* @readonly
	* @see $.fn.swipe.defaults#fingers
	* @property {string} ONE Constant indicating 1 finger is to be detected / was detected. Value is <code>1</code>.
	* @property {string} TWO Constant indicating 2 fingers are to be detected / were detected. Value is <code>1</code>.
	* @property {string} THREE Constant indicating 3 finger are to be detected / were detected. Value is <code>1</code>.
	* @property {string} ALL Constant indicating any combination of finger are to be detected.  Value is <code>"all"</code>.
	*/
    $.fn.swipe.fingers = {
        ONE: 1,
        TWO: 2,
        THREE: 3,
        ALL: ALL_FINGERS
    };

    /**
	* Initialise the plugin for each DOM element matched
	* This creates a new instance of the main TouchSwipe class for each DOM element, and then
	* saves a reference to that instance in the elements data property.
	* @internal
	*/
    function init(options) {
        //Prep and extend the options
        if (options && (options.allowPageScroll === undefined && (options.swipe !== undefined || options.swipeStatus !== undefined))) {
            options.allowPageScroll = NONE;
        }

        //Check for deprecated options
        //Ensure that any old click handlers are assigned to the new tap, unless we have a tap
        if (options.click !== undefined && options.tap === undefined) {
            options.tap = options.click;
        }

        if (!options) {
            options = {};
        }

        //pass empty object so we dont modify the defaults
        options = $.extend({}, $.fn.swipe.defaults, options);

        //For each element instantiate the plugin
        return this.each(function () {
            var $this = $(this);

            //Check we havent already initialised the plugin
            var plugin = $this.data(PLUGIN_NS);

            if (!plugin) {
                plugin = new TouchSwipe(this, options);
                $this.data(PLUGIN_NS, plugin);
            }
        });
    }

    /**
	* Main TouchSwipe Plugin Class.
	* Do not use this to construct your TouchSwipe object, use the jQuery plugin method $.fn.swipe(); {@link $.fn.swipe}
	* @private
	* @name TouchSwipe
	* @param {DOMNode} element The HTML DOM object to apply to plugin to
	* @param {Object} options The options to configure the plugin with.  @link {$.fn.swipe.defaults}
	* @see $.fh.swipe.defaults
	* @see $.fh.swipe
    * @class
	*/
    function TouchSwipe(element, options) {
        var useTouchEvents = (SUPPORTS_TOUCH || !options.fallbackToMouseEvents),
			START_EV = useTouchEvents ? 'touchstart' : 'mousedown',
			MOVE_EV = useTouchEvents ? 'touchmove' : 'mousemove',
			END_EV = useTouchEvents ? 'touchend' : 'mouseup',
			LEAVE_EV = useTouchEvents ? null : 'mouseleave', //we manually detect leave on touch devices, so null event here
			CANCEL_EV = 'touchcancel';



        //touch properties
        var distance = 0,
			direction = null,
			duration = 0,
			startTouchesDistance = 0,
			endTouchesDistance = 0,
			pinchZoom = 1,
			pinchDistance = 0,
			pinchDirection = 0,
			maximumsMap = null;



        //jQuery wrapped element for this instance
        var $element = $(element);

        //Current phase of th touch cycle
        var phase = "start";

        // the current number of fingers being used.
        var fingerCount = 0;

        //track mouse points / delta
        var fingerData = null;

        //track times
        var startTime = 0,
			endTime = 0,
			previousTouchEndTime = 0,
			previousTouchFingerCount = 0,
			doubleTapStartTime = 0;

        //Timeouts
        var singleTapTimeout = null;

        // Add gestures to all swipable areas if supported
        try {
            $element.bind(START_EV, touchStart);
            $element.bind(CANCEL_EV, touchCancel);
        }
        catch (e) {
            $.error('events not supported ' + START_EV + ',' + CANCEL_EV + ' on jQuery.swipe');
        }

        //
        //Public methods
        //

        /**
		* re-enables the swipe plugin with the previous configuration
		* @function
		* @name $.fn.swipe#enable
		* @return {DOMNode} The Dom element that was registered with TouchSwipe 
		* @example $("#element").swipe("enable");
		*/
        this.enable = function () {
            $element.bind(START_EV, touchStart);
            $element.bind(CANCEL_EV, touchCancel);
            return $element;
        };

        /**
		* disables the swipe plugin
		* @function
		* @name $.fn.swipe#disable
		* @return {DOMNode} The Dom element that is now registered with TouchSwipe
	    * @example $("#element").swipe("disable");
		*/
        this.disable = function () {
            removeListeners();
            return $element;
        };

        /**
		* Destroy the swipe plugin completely. To use any swipe methods, you must re initialise the plugin.
		* @function
		* @name $.fn.swipe#destroy
		* @return {DOMNode} The Dom element that was registered with TouchSwipe 
		* @example $("#element").swipe("destroy");
		*/
        this.destroy = function () {
            removeListeners();
            $element.data(PLUGIN_NS, null);
            return $element;
        };


        /**
         * Allows run time updating of the swipe configuration options.
         * @function
    	 * @name $.fn.swipe#option
    	 * @param {String} property The option property to get or set
         * @param {Object} [value] The value to set the property to
		 * @return {Object} If only a property name is passed, then that property value is returned.
		 * @example $("#element").swipe("option", "threshold"); // return the threshold
         * @example $("#element").swipe("option", "threshold", 100); // set the threshold after init
         * @see $.fn.swipe.defaults
         *
         */
        this.option = function (property, value) {
            if (options[property] !== undefined) {
                if (value === undefined) {
                    return options[property];
                } else {
                    options[property] = value;
                }
            } else {
                $.error('Option ' + property + ' does not exist on jQuery.swipe.options');
            }

            return null;
        }

        //
        // Private methods
        //

        //
        // EVENTS
        //
        /**
		* Event handler for a touch start event.
		* Stops the default click event from triggering and stores where we touched
		* @inner
		* @param {object} jqEvent The normalised jQuery event object.
		*/
        function touchStart(jqEvent) {
            //If we already in a touch event (a finger already in use) then ignore subsequent ones..
            if (getTouchInProgress())
                return;

            //Check if this element matches any in the excluded elements selectors,  or its parent is excluded, if so, DON'T swipe
            if ($(jqEvent.target).closest(options.excludedElements, $element).length > 0)
                return;

            //As we use Jquery bind for events, we need to target the original event object
            //If these events are being programmatically triggered, we don't have an original event object, so use the Jq one.
            var event = jqEvent.originalEvent ? jqEvent.originalEvent : jqEvent;

            var ret,
				evt = SUPPORTS_TOUCH ? event.touches[0] : event;

            phase = PHASE_START;

            //If we support touches, get the finger count
            if (SUPPORTS_TOUCH) {
                // get the total number of fingers touching the screen
                fingerCount = event.touches.length;
            }
                //Else this is the desktop, so stop the browser from dragging the image
            else {
                jqEvent.preventDefault(); //call this on jq event so we are cross browser
            }

            //clear vars..
            distance = 0;
            direction = null;
            pinchDirection = null;
            duration = 0;
            startTouchesDistance = 0;
            endTouchesDistance = 0;
            pinchZoom = 1;
            pinchDistance = 0;
            fingerData = createAllFingerData();
            maximumsMap = createMaximumsData();
            cancelMultiFingerRelease();


            // check the number of fingers is what we are looking for, or we are capturing pinches
            if (!SUPPORTS_TOUCH || (fingerCount === options.fingers || options.fingers === ALL_FINGERS) || hasPinches()) {
                // get the coordinates of the touch
                createFingerData(0, evt);
                startTime = getTimeStamp();

                if (fingerCount == 2) {
                    //Keep track of the initial pinch distance, so we can calculate the diff later
                    //Store second finger data as start
                    createFingerData(1, event.touches[1]);
                    startTouchesDistance = endTouchesDistance = calculateTouchesDistance(fingerData[0].start, fingerData[1].start);
                }

                if (options.swipeStatus || options.pinchStatus) {
                    ret = triggerHandler(event, phase);
                }
            }
            else {
                //A touch with more or less than the fingers we are looking for, so cancel
                ret = false;
            }

            //If we have a return value from the users handler, then return and cancel
            if (ret === false) {
                phase = PHASE_CANCEL;
                triggerHandler(event, phase);
                return ret;
            }
            else {
                setTouchInProgress(true);
            }

            return null;
        };



        /**
		* Event handler for a touch move event. 
		* If we change fingers during move, then cancel the event
		* @inner
		* @param {object} jqEvent The normalised jQuery event object.
		*/
        function touchMove(jqEvent) {

            //As we use Jquery bind for events, we need to target the original event object
            //If these events are being programmatically triggered, we don't have an original event object, so use the Jq one.
            var event = jqEvent.originalEvent ? jqEvent.originalEvent : jqEvent;

            //If we are ending, cancelling, or within the threshold of 2 fingers being released, don't track anything..
            if (phase === PHASE_END || phase === PHASE_CANCEL || inMultiFingerRelease())
                return;

            var ret,
				evt = SUPPORTS_TOUCH ? event.touches[0] : event;


            //Update the  finger data 
            var currentFinger = updateFingerData(evt);
            endTime = getTimeStamp();

            if (SUPPORTS_TOUCH) {
                fingerCount = event.touches.length;
            }

            phase = PHASE_MOVE;

            //If we have 2 fingers get Touches distance as well
            if (fingerCount == 2) {

                //Keep track of the initial pinch distance, so we can calculate the diff later
                //We do this here as well as the start event, in case they start with 1 finger, and the press 2 fingers
                if (startTouchesDistance == 0) {
                    //Create second finger if this is the first time...
                    createFingerData(1, event.touches[1]);

                    startTouchesDistance = endTouchesDistance = calculateTouchesDistance(fingerData[0].start, fingerData[1].start);
                } else {
                    //Else just update the second finger
                    updateFingerData(event.touches[1]);

                    endTouchesDistance = calculateTouchesDistance(fingerData[0].end, fingerData[1].end);
                    pinchDirection = calculatePinchDirection(fingerData[0].end, fingerData[1].end);
                }


                pinchZoom = calculatePinchZoom(startTouchesDistance, endTouchesDistance);
                pinchDistance = Math.abs(startTouchesDistance - endTouchesDistance);
            }


            if ((fingerCount === options.fingers || options.fingers === ALL_FINGERS) || !SUPPORTS_TOUCH || hasPinches()) {

                direction = calculateDirection(currentFinger.start, currentFinger.end);

                //Check if we need to prevent default event (page scroll / pinch zoom) or not
                validateDefaultEvent(jqEvent, direction);

                //Distance and duration are all off the main finger
                distance = calculateDistance(currentFinger.start, currentFinger.end);
                duration = calculateDuration();

                //Cache the maximum distance we made in this direction
                setMaxDistance(direction, distance);


                if (options.swipeStatus || options.pinchStatus) {
                    ret = triggerHandler(event, phase);
                }


                //If we trigger end events when threshold are met, or trigger events when touch leaves element
                if (!options.triggerOnTouchEnd || options.triggerOnTouchLeave) {

                    var inBounds = true;

                    //If checking if we leave the element, run the bounds check (we can use touchleave as its not supported on webkit)
                    if (options.triggerOnTouchLeave) {
                        var bounds = getbounds(this);
                        inBounds = isInBounds(currentFinger.end, bounds);
                    }

                    //Trigger end handles as we swipe if thresholds met or if we have left the element if the user has asked to check these..
                    if (!options.triggerOnTouchEnd && inBounds) {
                        phase = getNextPhase(PHASE_MOVE);
                    }
                        //We end if out of bounds here, so set current phase to END, and check if its modified 
                    else if (options.triggerOnTouchLeave && !inBounds) {
                        phase = getNextPhase(PHASE_END);
                    }

                    if (phase == PHASE_CANCEL || phase == PHASE_END) {
                        triggerHandler(event, phase);
                    }
                }
            }
            else {
                phase = PHASE_CANCEL;
                triggerHandler(event, phase);
            }

            if (ret === false) {
                phase = PHASE_CANCEL;
                triggerHandler(event, phase);
            }
        }



        /**
		* Event handler for a touch end event. 
		* Calculate the direction and trigger events
		* @inner
		* @param {object} jqEvent The normalised jQuery event object.
		*/
        function touchEnd(jqEvent) {
            //As we use Jquery bind for events, we need to target the original event object
            var event = jqEvent.originalEvent;


            //If we are still in a touch with another finger return
            //This allows us to wait a fraction and see if the other finger comes up, if it does within the threshold, then we treat it as a multi release, not a single release.
            if (SUPPORTS_TOUCH) {
                if (event.touches.length > 0) {
                    startMultiFingerRelease();
                    return true;
                }
            }

            //If a previous finger has been released, check how long ago, if within the threshold, then assume it was a multifinger release.
            //This is used to allow 2 fingers to release fractionally after each other, whilst maintainig the event as containg 2 fingers, not 1
            if (inMultiFingerRelease()) {
                fingerCount = previousTouchFingerCount;
            }

            //call this on jq event so we are cross browser 
            jqEvent.preventDefault();

            //Set end of swipe
            endTime = getTimeStamp();

            //Get duration incase move was never fired
            duration = calculateDuration();

            //If we trigger handlers at end of swipe OR, we trigger during, but they didnt trigger and we are still in the move phase
            if (didSwipeBackToCancel()) {
                phase = PHASE_CANCEL;
                triggerHandler(event, phase);
            } else if (options.triggerOnTouchEnd || (options.triggerOnTouchEnd == false && phase === PHASE_MOVE)) {
                phase = PHASE_END;
                triggerHandler(event, phase);
            }
                //Special cases - A tap should always fire on touch end regardless,
                //So here we manually trigger the tap end handler by itself
                //We dont run trigger handler as it will re-trigger events that may have fired already
            else if (!options.triggerOnTouchEnd && hasTap()) {
                //Trigger the pinch events...
                phase = PHASE_END;
                triggerHandlerForGesture(event, phase, TAP);
            }
            else if (phase === PHASE_MOVE) {
                phase = PHASE_CANCEL;
                triggerHandler(event, phase);
            }

            setTouchInProgress(false);

            return null;
        }



        /**
		* Event handler for a touch cancel event. 
		* Clears current vars
		* @inner
		*/
        function touchCancel() {
            // reset the variables back to default values
            fingerCount = 0;
            endTime = 0;
            startTime = 0;
            startTouchesDistance = 0;
            endTouchesDistance = 0;
            pinchZoom = 1;

            //If we were in progress of tracking a possible multi touch end, then re set it.
            cancelMultiFingerRelease();

            setTouchInProgress(false);
        }


        /**
		* Event handler for a touch leave event. 
		* This is only triggered on desktops, in touch we work this out manually
		* as the touchleave event is not supported in webkit
		* @inner
		*/
        function touchLeave(jqEvent) {
            var event = jqEvent.originalEvent;

            //If we have the trigger on leave property set....
            if (options.triggerOnTouchLeave) {
                phase = getNextPhase(PHASE_END);
                triggerHandler(event, phase);
            }
        }

        /**
		* Removes all listeners that were associated with the plugin
		* @inner
		*/
        function removeListeners() {
            $element.unbind(START_EV, touchStart);
            $element.unbind(CANCEL_EV, touchCancel);
            $element.unbind(MOVE_EV, touchMove);
            $element.unbind(END_EV, touchEnd);

            //we only have leave events on desktop, we manually calculate leave on touch as its not supported in webkit
            if (LEAVE_EV) {
                $element.unbind(LEAVE_EV, touchLeave);
            }

            setTouchInProgress(false);
        }


        /**
		 * Checks if the time and distance thresholds have been met, and if so then the appropriate handlers are fired.
		 */
        function getNextPhase(currentPhase) {

            var nextPhase = currentPhase;

            // Ensure we have valid swipe (under time and over distance  and check if we are out of bound...)
            var validTime = validateSwipeTime();
            var validDistance = validateSwipeDistance();
            var didCancel = didSwipeBackToCancel();

            //If we have exceeded our time, then cancel	
            if (!validTime || didCancel) {
                nextPhase = PHASE_CANCEL;
            }
                //Else if we are moving, and have reached distance then end
            else if (validDistance && currentPhase == PHASE_MOVE && (!options.triggerOnTouchEnd || options.triggerOnTouchLeave)) {
                nextPhase = PHASE_END;
            }
                //Else if we have ended by leaving and didn't reach distance, then cancel
            else if (!validDistance && currentPhase == PHASE_END && options.triggerOnTouchLeave) {
                nextPhase = PHASE_CANCEL;
            }

            return nextPhase;
        }


        /**
		* Trigger the relevant event handler
		* The handlers are passed the original event, the element that was swiped, and in the case of the catch all handler, the direction that was swiped, "left", "right", "up", or "down"
		* @param {object} event the original event object
		* @param {string} phase the phase of the swipe (start, end cancel etc) {@link $.fn.swipe.phases}
		* @inner
		*/
        function triggerHandler(event, phase) {

            var ret = undefined;

            // SWIPE GESTURES
            if (didSwipe() || hasSwipes()) { //hasSwipes as status needs to fire even if swipe is invalid
                //Trigger the swipe events...
                ret = triggerHandlerForGesture(event, phase, SWIPE);
            }

                // PINCH GESTURES (if the above didn't cancel)
            else if ((didPinch() || hasPinches()) && ret !== false) {
                //Trigger the pinch events...
                ret = triggerHandlerForGesture(event, phase, PINCH);
            }

            // CLICK / TAP (if the above didn't cancel)
            if (didDoubleTap() && ret !== false) {
                //Trigger the tap events...
                ret = triggerHandlerForGesture(event, phase, DOUBLE_TAP);
            }

                // CLICK / TAP (if the above didn't cancel)
            else if (didLongTap() && ret !== false) {
                //Trigger the tap events...
                ret = triggerHandlerForGesture(event, phase, LONG_TAP);
            }

                // CLICK / TAP (if the above didn't cancel)
            else if (didTap() && ret !== false) {
                //Trigger the tap event..
                ret = triggerHandlerForGesture(event, phase, TAP);
            }



            // If we are cancelling the gesture, then manually trigger the reset handler
            if (phase === PHASE_CANCEL) {
                touchCancel(event);
            }

            // If we are ending the gesture, then manually trigger the reset handler IF all fingers are off
            if (phase === PHASE_END) {
                //If we support touch, then check that all fingers are off before we cancel
                if (SUPPORTS_TOUCH) {
                    if (event.touches.length == 0) {
                        touchCancel(event);
                    }
                }
                else {
                    touchCancel(event);
                }
            }

            return ret;
        }



        /**
		* Trigger the relevant event handler
		* The handlers are passed the original event, the element that was swiped, and in the case of the catch all handler, the direction that was swiped, "left", "right", "up", or "down"
		* @param {object} event the original event object
		* @param {string} phase the phase of the swipe (start, end cancel etc) {@link $.fn.swipe.phases}
		* @param {string} gesture the gesture to trigger a handler for : PINCH or SWIPE {@link $.fn.swipe.gestures}
		* @return Boolean False, to indicate that the event should stop propagation, or void.
		* @inner
		*/
        function triggerHandlerForGesture(event, phase, gesture) {

            var ret = undefined;

            //SWIPES....
            if (gesture == SWIPE) {
                //Trigger status every time..

                //Trigger the event...
                $element.trigger('swipeStatus', [phase, direction || null, distance || 0, duration || 0, fingerCount]);

                //Fire the callback
                if (options.swipeStatus) {
                    ret = options.swipeStatus.call($element, event, phase, direction || null, distance || 0, duration || 0, fingerCount);
                    //If the status cancels, then dont run the subsequent event handlers..
                    if (ret === false) return false;
                }




                if (phase == PHASE_END && validateSwipe()) {
                    //Fire the catch all event
                    $element.trigger('swipe', [direction, distance, duration, fingerCount]);

                    //Fire catch all callback
                    if (options.swipe) {
                        ret = options.swipe.call($element, event, direction, distance, duration, fingerCount);
                        //If the status cancels, then dont run the subsequent event handlers..
                        if (ret === false) return false;
                    }

                    //trigger direction specific event handlers	
                    switch (direction) {
                        case LEFT:
                            //Trigger the event
                            $element.trigger('swipeLeft', [direction, distance, duration, fingerCount]);

                            //Fire the callback
                            if (options.swipeLeft) {
                                ret = options.swipeLeft.call($element, event, direction, distance, duration, fingerCount);
                            }
                            break;

                        case RIGHT:
                            //Trigger the event
                            $element.trigger('swipeRight', [direction, distance, duration, fingerCount]);

                            //Fire the callback
                            if (options.swipeRight) {
                                ret = options.swipeRight.call($element, event, direction, distance, duration, fingerCount);
                            }
                            break;

                        case UP:
                            //Trigger the event
                            $element.trigger('swipeUp', [direction, distance, duration, fingerCount]);

                            //Fire the callback
                            if (options.swipeUp) {
                                ret = options.swipeUp.call($element, event, direction, distance, duration, fingerCount);
                            }
                            break;

                        case DOWN:
                            //Trigger the event
                            $element.trigger('swipeDown', [direction, distance, duration, fingerCount]);

                            //Fire the callback
                            if (options.swipeDown) {
                                ret = options.swipeDown.call($element, event, direction, distance, duration, fingerCount);
                            }
                            break;
                    }
                }
            }


            //PINCHES....
            if (gesture == PINCH) {
                //Trigger the event
                $element.trigger('pinchStatus', [phase, pinchDirection || null, pinchDistance || 0, duration || 0, fingerCount, pinchZoom]);

                //Fire the callback
                if (options.pinchStatus) {
                    ret = options.pinchStatus.call($element, event, phase, pinchDirection || null, pinchDistance || 0, duration || 0, fingerCount, pinchZoom);
                    //If the status cancels, then dont run the subsequent event handlers..
                    if (ret === false) return false;
                }

                if (phase == PHASE_END && validatePinch()) {

                    switch (pinchDirection) {
                        case IN:
                            //Trigger the event
                            $element.trigger('pinchIn', [pinchDirection || null, pinchDistance || 0, duration || 0, fingerCount, pinchZoom]);

                            //Fire the callback
                            if (options.pinchIn) {
                                ret = options.pinchIn.call($element, event, pinchDirection || null, pinchDistance || 0, duration || 0, fingerCount, pinchZoom);
                            }
                            break;

                        case OUT:
                            //Trigger the event
                            $element.trigger('pinchOut', [pinchDirection || null, pinchDistance || 0, duration || 0, fingerCount, pinchZoom]);

                            //Fire the callback
                            if (options.pinchOut) {
                                ret = options.pinchOut.call($element, event, pinchDirection || null, pinchDistance || 0, duration || 0, fingerCount, pinchZoom);
                            }
                            break;
                    }
                }
            }





            if (gesture == TAP) {
                if (phase === PHASE_CANCEL || phase === PHASE_END) {


                    //Cancel any existing double tap
                    clearTimeout(singleTapTimeout);

                    //If we are also looking for doubelTaps, wait incase this is one...
                    if (hasDoubleTap() && !inDoubleTap()) {
                        //Cache the time of this tap
                        doubleTapStartTime = getTimeStamp();

                        //Now wait for the double tap timeout, and trigger this single tap
                        //if its not cancelled by a double tap
                        singleTapTimeout = setTimeout($.proxy(function () {
                            doubleTapStartTime = null;
                            //Trigger the event
                            $element.trigger('tap', [event.target]);


                            //Fire the callback
                            if (options.tap) {
                                ret = options.tap.call($element, event, event.target);
                            }
                        }, this), options.doubleTapThreshold);

                    } else {
                        doubleTapStartTime = null;

                        //Trigger the event
                        $element.trigger('tap', [event.target]);


                        //Fire the callback
                        if (options.tap) {
                            ret = options.tap.call($element, event, event.target);
                        }
                    }
                }
            }

            else if (gesture == DOUBLE_TAP) {
                if (phase === PHASE_CANCEL || phase === PHASE_END) {
                    //Cancel any pending singletap 
                    clearTimeout(singleTapTimeout);
                    doubleTapStartTime = null;

                    //Trigger the event
                    $element.trigger('doubletap', [event.target]);

                    //Fire the callback
                    if (options.doubleTap) {
                        ret = options.doubleTap.call($element, event, event.target);
                    }
                }
            }

            else if (gesture == LONG_TAP) {
                if (phase === PHASE_CANCEL || phase === PHASE_END) {
                    //Cancel any pending singletap (shouldnt be one)
                    clearTimeout(singleTapTimeout);
                    doubleTapStartTime = null;

                    //Trigger the event
                    $element.trigger('longtap', [event.target]);

                    //Fire the callback
                    if (options.longTap) {
                        ret = options.longTap.call($element, event, event.target);
                    }
                }
            }

            return ret;
        }




        //
        // GESTURE VALIDATION
        //

        /**
		* Checks the user has swipe far enough
		* @return Boolean if <code>threshold</code> has been set, return true if the threshold was met, else false.
		* If no threshold was set, then we return true.
		* @inner
		*/
        function validateSwipeDistance() {
            var valid = true;
            //If we made it past the min swipe distance..
            if (options.threshold !== null) {
                valid = distance >= options.threshold;
            }

            return valid;
        }

        /**
		* Checks the user has swiped back to cancel.
		* @return Boolean if <code>cancelThreshold</code> has been set, return true if the cancelThreshold was met, else false.
		* If no cancelThreshold was set, then we return true.
		* @inner
		*/
        function didSwipeBackToCancel() {
            var cancelled = false;
            if (options.cancelThreshold !== null && direction !== null) {
                cancelled = (getMaxDistance(direction) - distance) >= options.cancelThreshold;
            }

            return cancelled;
        }

        /**
		* Checks the user has pinched far enough
		* @return Boolean if <code>pinchThreshold</code> has been set, return true if the threshold was met, else false.
		* If no threshold was set, then we return true.
		* @inner
		*/
        function validatePinchDistance() {
            if (options.pinchThreshold !== null) {
                return pinchDistance >= options.pinchThreshold;
            }
            return true;
        }

        /**
		* Checks that the time taken to swipe meets the minimum / maximum requirements
		* @return Boolean
		* @inner
		*/
        function validateSwipeTime() {
            var result;
            //If no time set, then return true

            if (options.maxTimeThreshold) {
                if (duration >= options.maxTimeThreshold) {
                    result = false;
                } else {
                    result = true;
                }
            }
            else {
                result = true;
            }

            return result;
        }


        /**
		* Checks direction of the swipe and the value allowPageScroll to see if we should allow or prevent the default behaviour from occurring.
		* This will essentially allow page scrolling or not when the user is swiping on a touchSwipe object.
		* @param {object} jqEvent The normalised jQuery representation of the event object.
		* @param {string} direction The direction of the event. See {@link $.fn.swipe.directions}
		* @see $.fn.swipe.directions
		* @inner
		*/
        function validateDefaultEvent(jqEvent, direction) {
            if (options.allowPageScroll === NONE || hasPinches()) {
                jqEvent.preventDefault();
            } else {
                var auto = options.allowPageScroll === AUTO;

                switch (direction) {
                    case LEFT:
                        if ((options.swipeLeft && auto) || (!auto && options.allowPageScroll != HORIZONTAL)) {
                            jqEvent.preventDefault();
                        }
                        break;

                    case RIGHT:
                        if ((options.swipeRight && auto) || (!auto && options.allowPageScroll != HORIZONTAL)) {
                            jqEvent.preventDefault();
                        }
                        break;

                    case UP:
                        if ((options.swipeUp && auto) || (!auto && options.allowPageScroll != VERTICAL)) {
                            jqEvent.preventDefault();
                        }
                        break;

                    case DOWN:
                        if ((options.swipeDown && auto) || (!auto && options.allowPageScroll != VERTICAL)) {
                            jqEvent.preventDefault();
                        }
                        break;
                }
            }

        }


        // PINCHES
        /**
		 * Returns true of the current pinch meets the thresholds
		 * @return Boolean
		 * @inner
		*/
        function validatePinch() {
            var hasCorrectFingerCount = validateFingers();
            var hasEndPoint = validateEndPoint();
            var hasCorrectDistance = validatePinchDistance();
            return hasCorrectFingerCount && hasEndPoint && hasCorrectDistance;

        }

        /**
		 * Returns true if any Pinch events have been registered
		 * @return Boolean
		 * @inner
		*/
        function hasPinches() {
            //Enure we dont return 0 or null for false values
            return !!(options.pinchStatus || options.pinchIn || options.pinchOut);
        }

        /**
		 * Returns true if we are detecting pinches, and have one
		 * @return Boolean
		 * @inner
		 */
        function didPinch() {
            //Enure we dont return 0 or null for false values
            return !!(validatePinch() && hasPinches());
        }




        // SWIPES
        /**
		 * Returns true if the current swipe meets the thresholds
		 * @return Boolean
		 * @inner
		*/
        function validateSwipe() {
            //Check validity of swipe
            var hasValidTime = validateSwipeTime();
            var hasValidDistance = validateSwipeDistance();
            var hasCorrectFingerCount = validateFingers();
            var hasEndPoint = validateEndPoint();
            var didCancel = didSwipeBackToCancel();

            // if the user swiped more than the minimum length, perform the appropriate action
            // hasValidDistance is null when no distance is set 
            var valid = !didCancel && hasEndPoint && hasCorrectFingerCount && hasValidDistance && hasValidTime;

            return valid;
        }

        /**
		 * Returns true if any Swipe events have been registered
		 * @return Boolean
		 * @inner
		*/
        function hasSwipes() {
            //Enure we dont return 0 or null for false values
            return !!(options.swipe || options.swipeStatus || options.swipeLeft || options.swipeRight || options.swipeUp || options.swipeDown);
        }


        /**
		 * Returns true if we are detecting swipes and have one
		 * @return Boolean
		 * @inner
		*/
        function didSwipe() {
            //Enure we dont return 0 or null for false values
            return !!(validateSwipe() && hasSwipes());
        }

        /**
		 * Returns true if we have matched the number of fingers we are looking for
		 * @return Boolean
		 * @inner
		*/
        function validateFingers() {
            //The number of fingers we want were matched, or on desktop we ignore
            return ((fingerCount === options.fingers || options.fingers === ALL_FINGERS) || !SUPPORTS_TOUCH);
        }

        /**
		 * Returns true if we have an end point for the swipe
		 * @return Boolean
		 * @inner
		*/
        function validateEndPoint() {
            //We have an end value for the finger
            return fingerData[0].end.x !== 0;
        }

        // TAP / CLICK
        /**
		 * Returns true if a click / tap events have been registered
		 * @return Boolean
		 * @inner
		*/
        function hasTap() {
            //Enure we dont return 0 or null for false values
            return !!(options.tap);
        }

        /**
		 * Returns true if a double tap events have been registered
		 * @return Boolean
		 * @inner
		*/
        function hasDoubleTap() {
            //Enure we dont return 0 or null for false values
            return !!(options.doubleTap);
        }

        /**
		 * Returns true if any long tap events have been registered
		 * @return Boolean
		 * @inner
		*/
        function hasLongTap() {
            //Enure we dont return 0 or null for false values
            return !!(options.longTap);
        }

        /**
		 * Returns true if we could be in the process of a double tap (one tap has occurred, we are listening for double taps, and the threshold hasn't past.
		 * @return Boolean
		 * @inner
		*/
        function validateDoubleTap() {
            if (doubleTapStartTime == null) {
                return false;
            }
            var now = getTimeStamp();
            return (hasDoubleTap() && ((now - doubleTapStartTime) <= options.doubleTapThreshold));
        }

        /**
		 * Returns true if we could be in the process of a double tap (one tap has occurred, we are listening for double taps, and the threshold hasn't past.
		 * @return Boolean
		 * @inner
		*/
        function inDoubleTap() {
            return validateDoubleTap();
        }


        /**
		 * Returns true if we have a valid tap
		 * @return Boolean
		 * @inner
		*/
        function validateTap() {
            return ((fingerCount === 1 || !SUPPORTS_TOUCH) && (isNaN(distance) || distance === 0));
        }

        /**
		 * Returns true if we have a valid long tap
		 * @return Boolean
		 * @inner
		*/
        function validateLongTap() {
            //slight threshold on moving finger
            return ((duration > options.longTapThreshold) && (distance < DOUBLE_TAP_THRESHOLD));
        }

        /**
		 * Returns true if we are detecting taps and have one
		 * @return Boolean
		 * @inner
		*/
        function didTap() {
            //Enure we dont return 0 or null for false values
            return !!(validateTap() && hasTap());
        }


        /**
		 * Returns true if we are detecting double taps and have one
		 * @return Boolean
		 * @inner
		*/
        function didDoubleTap() {
            //Enure we dont return 0 or null for false values
            return !!(validateDoubleTap() && hasDoubleTap());
        }

        /**
		 * Returns true if we are detecting long taps and have one
		 * @return Boolean
		 * @inner
		*/
        function didLongTap() {
            //Enure we dont return 0 or null for false values
            return !!(validateLongTap() && hasLongTap());
        }




        // MULTI FINGER TOUCH
        /**
		 * Starts tracking the time between 2 finger releases, and keeps track of how many fingers we initially had up
		 * @inner
		*/
        function startMultiFingerRelease() {
            previousTouchEndTime = getTimeStamp();
            previousTouchFingerCount = event.touches.length + 1;
        }

        /**
		 * Cancels the tracking of time between 2 finger releases, and resets counters
		 * @inner
		*/
        function cancelMultiFingerRelease() {
            previousTouchEndTime = 0;
            previousTouchFingerCount = 0;
        }

        /**
		 * Checks if we are in the threshold between 2 fingers being released 
		 * @return Boolean
		 * @inner
		*/
        function inMultiFingerRelease() {

            var withinThreshold = false;

            if (previousTouchEndTime) {
                var diff = getTimeStamp() - previousTouchEndTime
                if (diff <= options.fingerReleaseThreshold) {
                    withinThreshold = true;
                }
            }

            return withinThreshold;
        }


        /**
		* gets a data flag to indicate that a touch is in progress
		* @return Boolean
		* @inner
		*/
        function getTouchInProgress() {
            //strict equality to ensure only true and false are returned
            return !!($element.data(PLUGIN_NS + '_intouch') === true);
        }

        /**
		* Sets a data flag to indicate that a touch is in progress
		* @param {boolean} val The value to set the property to
		* @inner
		*/
        function setTouchInProgress(val) {

            //Add or remove event listeners depending on touch status
            if (val === true) {
                $element.bind(MOVE_EV, touchMove);
                $element.bind(END_EV, touchEnd);

                //we only have leave events on desktop, we manually calcuate leave on touch as its not supported in webkit
                if (LEAVE_EV) {
                    $element.bind(LEAVE_EV, touchLeave);
                }
            } else {
                $element.unbind(MOVE_EV, touchMove, false);
                $element.unbind(END_EV, touchEnd, false);

                //we only have leave events on desktop, we manually calcuate leave on touch as its not supported in webkit
                if (LEAVE_EV) {
                    $element.unbind(LEAVE_EV, touchLeave, false);
                }
            }


            //strict equality to ensure only true and false can update the value
            $element.data(PLUGIN_NS + '_intouch', val === true);
        }


        /**
		 * Creates the finger data for the touch/finger in the event object.
		 * @param {int} index The index in the array to store the finger data (usually the order the fingers were pressed)
		 * @param {object} evt The event object containing finger data
		 * @return finger data object
		 * @inner
		*/
        function createFingerData(index, evt) {
            var id = evt.identifier !== undefined ? evt.identifier : 0;

            fingerData[index].identifier = id;
            fingerData[index].start.x = fingerData[index].end.x = evt.pageX || evt.clientX;
            fingerData[index].start.y = fingerData[index].end.y = evt.pageY || evt.clientY;

            return fingerData[index];
        }

        /**
		 * Updates the finger data for a particular event object
		 * @param {object} evt The event object containing the touch/finger data to upadte
		 * @return a finger data object.
		 * @inner
		*/
        function updateFingerData(evt) {

            var id = evt.identifier !== undefined ? evt.identifier : 0;
            var f = getFingerData(id);

            f.end.x = evt.pageX || evt.clientX;
            f.end.y = evt.pageY || evt.clientY;

            return f;
        }

        /**
		 * Returns a finger data object by its event ID.
		 * Each touch event has an identifier property, which is used 
		 * to track repeat touches
		 * @param {int} id The unique id of the finger in the sequence of touch events.
		 * @return a finger data object.
		 * @inner
		*/
        function getFingerData(id) {
            for (var i = 0; i < fingerData.length; i++) {
                if (fingerData[i].identifier == id) {
                    return fingerData[i];
                }
            }
        }

        /**
		 * Creats all the finger onjects and returns an array of finger data
		 * @return Array of finger objects
		 * @inner
		*/
        function createAllFingerData() {
            var fingerData = [];
            for (var i = 0; i <= 5; i++) {
                fingerData.push({
                    start: { x: 0, y: 0 },
                    end: { x: 0, y: 0 },
                    identifier: 0
                });
            }

            return fingerData;
        }

        /**
		 * Sets the maximum distance swiped in the given direction. 
		 * If the new value is lower than the current value, the max value is not changed.
		 * @param {string}  direction The direction of the swipe
		 * @param {int}  distance The distance of the swipe
		 * @inner
		*/
        function setMaxDistance(direction, distance) {
            distance = Math.max(distance, getMaxDistance(direction));
            maximumsMap[direction].distance = distance;
        }

        /**
		 * gets the maximum distance swiped in the given direction. 
		 * @param {string}  direction The direction of the swipe
		 * @return int  The distance of the swipe
		 * @inner
		*/
        function getMaxDistance(direction) {
            if (maximumsMap[direction]) return maximumsMap[direction].distance;
            return undefined;
        }

        /**
		 * Creats a map of directions to maximum swiped values.
		 * @return Object A dictionary of maximum values, indexed by direction.
		 * @inner
		*/
        function createMaximumsData() {
            var maxData = {};
            maxData[LEFT] = createMaximumVO(LEFT);
            maxData[RIGHT] = createMaximumVO(RIGHT);
            maxData[UP] = createMaximumVO(UP);
            maxData[DOWN] = createMaximumVO(DOWN);

            return maxData;
        }

        /**
		 * Creates a map maximum swiped values for a given swipe direction
		 * @param {string} The direction that these values will be associated with
		 * @return Object Maximum values
		 * @inner
		*/
        function createMaximumVO(dir) {
            return {
                direction: dir,
                distance: 0
            }
        }


        //
        // MATHS / UTILS
        //

        /**
		* Calculate the duration of the swipe
		* @return int
		* @inner
		*/
        function calculateDuration() {
            return endTime - startTime;
        }

        /**
		* Calculate the distance between 2 touches (pinch)
		* @param {point} startPoint A point object containing x and y co-ordinates
	    * @param {point} endPoint A point object containing x and y co-ordinates
	    * @return int;
		* @inner
		*/
        function calculateTouchesDistance(startPoint, endPoint) {
            var diffX = Math.abs(startPoint.x - endPoint.x);
            var diffY = Math.abs(startPoint.y - endPoint.y);

            return Math.round(Math.sqrt(diffX * diffX + diffY * diffY));
        }

        /**
		* Calculate the zoom factor between the start and end distances
		* @param {int} startDistance Distance (between 2 fingers) the user started pinching at
	    * @param {int} endDistance Distance (between 2 fingers) the user ended pinching at
	    * @return float The zoom value from 0 to 1.
		* @inner
		*/
        function calculatePinchZoom(startDistance, endDistance) {
            var percent = (endDistance / startDistance) * 1;
            return percent.toFixed(2);
        }


        /**
		* Returns the pinch direction, either IN or OUT for the given points
		* @return string Either {@link $.fn.swipe.directions.IN} or {@link $.fn.swipe.directions.OUT}
		* @see $.fn.swipe.directions
		* @inner
		*/
        function calculatePinchDirection() {
            if (pinchZoom < 1) {
                return OUT;
            }
            else {
                return IN;
            }
        }


        /**
		* Calculate the length / distance of the swipe
		* @param {point} startPoint A point object containing x and y co-ordinates
	    * @param {point} endPoint A point object containing x and y co-ordinates
	    * @return int
		* @inner
		*/
        function calculateDistance(startPoint, endPoint) {
            return Math.round(Math.sqrt(Math.pow(endPoint.x - startPoint.x, 2) + Math.pow(endPoint.y - startPoint.y, 2)));
        }

        /**
		* Calculate the angle of the swipe
		* @param {point} startPoint A point object containing x and y co-ordinates
	    * @param {point} endPoint A point object containing x and y co-ordinates
	    * @return int
		* @inner
		*/
        function calculateAngle(startPoint, endPoint) {
            var x = startPoint.x - endPoint.x;
            var y = endPoint.y - startPoint.y;
            var r = Math.atan2(y, x); //radians
            var angle = Math.round(r * 180 / Math.PI); //degrees

            //ensure value is positive
            if (angle < 0) {
                angle = 360 - Math.abs(angle);
            }

            return angle;
        }

        /**
		* Calculate the direction of the swipe
		* This will also call calculateAngle to get the latest angle of swipe
		* @param {point} startPoint A point object containing x and y co-ordinates
	    * @param {point} endPoint A point object containing x and y co-ordinates
	    * @return string Either {@link $.fn.swipe.directions.LEFT} / {@link $.fn.swipe.directions.RIGHT} / {@link $.fn.swipe.directions.DOWN} / {@link $.fn.swipe.directions.UP}
		* @see $.fn.swipe.directions
		* @inner
		*/
        function calculateDirection(startPoint, endPoint) {
            var angle = calculateAngle(startPoint, endPoint);

            if ((angle <= 45) && (angle >= 0)) {
                return LEFT;
            } else if ((angle <= 360) && (angle >= 315)) {
                return LEFT;
            } else if ((angle >= 135) && (angle <= 225)) {
                return RIGHT;
            } else if ((angle > 45) && (angle < 135)) {
                return DOWN;
            } else {
                return UP;
            }
        }


        /**
		* Returns a MS time stamp of the current time
		* @return int
		* @inner
		*/
        function getTimeStamp() {
            var now = new Date();
            return now.getTime();
        }



        /**
		 * Returns a bounds object with left, right, top and bottom properties for the element specified.
		 * @param {DomNode} The DOM node to get the bounds for.
		 */
        function getbounds(el) {
            el = $(el);
            var offset = el.offset();

            var bounds = {
                left: offset.left,
                right: offset.left + el.outerWidth(),
                top: offset.top,
                bottom: offset.top + el.outerHeight()
            }

            return bounds;
        }


        /**
		 * Checks if the point object is in the bounds object.
		 * @param {object} point A point object.
		 * @param {int} point.x The x value of the point.
		 * @param {int} point.y The x value of the point.
		 * @param {object} bounds The bounds object to test
		 * @param {int} bounds.left The leftmost value
		 * @param {int} bounds.right The righttmost value
		 * @param {int} bounds.top The topmost value
		* @param {int} bounds.bottom The bottommost value
		 */
        function isInBounds(point, bounds) {
            return (point.x > bounds.left && point.x < bounds.right && point.y > bounds.top && point.y < bounds.bottom);
        };


    }




    /**
     * A catch all handler that is triggered for all swipe directions. 
     * @name $.fn.swipe#swipe
     * @event
     * @default null
     * @param {EventObject} event The original event object
     * @param {int} direction The direction the user swiped in. See {@link $.fn.swipe.directions}
     * @param {int} distance The distance the user swiped
     * @param {int} duration The duration of the swipe in milliseconds
     * @param {int} fingerCount The number of fingers used. See {@link $.fn.swipe.fingers}
     */




    /**
     * A handler that is triggered for "left" swipes.
     * @name $.fn.swipe#swipeLeft
     * @event
     * @default null
     * @param {EventObject} event The original event object
     * @param {int} direction The direction the user swiped in. See {@link $.fn.swipe.directions}
     * @param {int} distance The distance the user swiped
     * @param {int} duration The duration of the swipe in milliseconds
     * @param {int} fingerCount The number of fingers used. See {@link $.fn.swipe.fingers}
     */

    /**
     * A handler that is triggered for "right" swipes.
     * @name $.fn.swipe#swipeRight
     * @event
     * @default null
     * @param {EventObject} event The original event object
     * @param {int} direction The direction the user swiped in. See {@link $.fn.swipe.directions}
     * @param {int} distance The distance the user swiped
     * @param {int} duration The duration of the swipe in milliseconds
     * @param {int} fingerCount The number of fingers used. See {@link $.fn.swipe.fingers}
     */

    /**
     * A handler that is triggered for "up" swipes.
     * @name $.fn.swipe#swipeUp
     * @event
     * @default null
     * @param {EventObject} event The original event object
     * @param {int} direction The direction the user swiped in. See {@link $.fn.swipe.directions}
     * @param {int} distance The distance the user swiped
     * @param {int} duration The duration of the swipe in milliseconds
     * @param {int} fingerCount The number of fingers used. See {@link $.fn.swipe.fingers}
     */

    /**
     * A handler that is triggered for "down" swipes.
     * @name $.fn.swipe#swipeDown
     * @event
     * @default null
     * @param {EventObject} event The original event object
     * @param {int} direction The direction the user swiped in. See {@link $.fn.swipe.directions}
     * @param {int} distance The distance the user swiped
     * @param {int} duration The duration of the swipe in milliseconds
     * @param {int} fingerCount The number of fingers used. See {@link $.fn.swipe.fingers}
     */

    /**
     * A handler triggered for every phase of the swipe. This handler is constantly fired for the duration of the pinch.
     * This is triggered regardless of swipe thresholds.
     * @name $.fn.swipe#swipeStatus
     * @event
     * @default null
     * @param {EventObject} event The original event object
     * @param {string} phase The phase of the swipe event. See {@link $.fn.swipe.phases}
     * @param {string} direction The direction the user swiped in. This is null if the user has yet to move. See {@link $.fn.swipe.directions}
     * @param {int} distance The distance the user swiped. This is 0 if the user has yet to move.
     * @param {int} duration The duration of the swipe in milliseconds
     * @param {int} fingerCount The number of fingers used. See {@link $.fn.swipe.fingers}
     */

    /**
     * A handler triggered for pinch in events.
     * @name $.fn.swipe#pinchIn
     * @event
     * @default null
     * @param {EventObject} event The original event object
     * @param {int} direction The direction the user pinched in. See {@link $.fn.swipe.directions}
     * @param {int} distance The distance the user pinched
     * @param {int} duration The duration of the swipe in milliseconds
     * @param {int} fingerCount The number of fingers used. See {@link $.fn.swipe.fingers}
     * @param {int} zoom The zoom/scale level the user pinched too, 0-1.
     */

    /**
     * A handler triggered for pinch out events.
     * @name $.fn.swipe#pinchOut
     * @event
     * @default null
     * @param {EventObject} event The original event object
     * @param {int} direction The direction the user pinched in. See {@link $.fn.swipe.directions}
     * @param {int} distance The distance the user pinched
     * @param {int} duration The duration of the swipe in milliseconds
     * @param {int} fingerCount The number of fingers used. See {@link $.fn.swipe.fingers}
     * @param {int} zoom The zoom/scale level the user pinched too, 0-1.
     */

    /**
     * A handler triggered for all pinch events. This handler is constantly fired for the duration of the pinch. This is triggered regardless of thresholds.
     * @name $.fn.swipe#pinchStatus
     * @event
     * @default null
     * @param {EventObject} event The original event object
     * @param {int} direction The direction the user pinched in. See {@link $.fn.swipe.directions}
     * @param {int} distance The distance the user pinched
     * @param {int} duration The duration of the swipe in milliseconds
     * @param {int} fingerCount The number of fingers used. See {@link $.fn.swipe.fingers}
     * @param {int} zoom The zoom/scale level the user pinched too, 0-1.
     */

    /**
     * A click handler triggered when a user simply clicks, rather than swipes on an element.
     * This is deprecated since version 1.6.2, any assignment to click will be assigned to the tap handler.
     * You cannot use <code>on</code> to bind to this event as the default jQ <code>click</code> event will be triggered.
     * Use the <code>tap</code> event instead.
     * @name $.fn.swipe#click
     * @event
     * @deprecated since version 1.6.2, please use {@link $.fn.swipe#tap} instead 
     * @default null
     * @param {EventObject} event The original event object
     * @param {DomObject} target The element clicked on.
     */

    /**
    * A click / tap handler triggered when a user simply clicks or taps, rather than swipes on an element.
    * @name $.fn.swipe#tap
    * @event
    * @default null
    * @param {EventObject} event The original event object
    * @param {DomObject} target The element clicked on.
    */

    /**
     * A double tap handler triggered when a user double clicks or taps on an element.
     * You can set the time delay for a double tap with the {@link $.fn.swipe.defaults#doubleTapThreshold} property. 
     * Note: If you set both <code>doubleTap</code> and <code>tap</code> handlers, the <code>tap</code> event will be delayed by the <code>doubleTapThreshold</code>
     * as the script needs to check if its a double tap.
     * @name $.fn.swipe#doubleTap
     * @see  $.fn.swipe.defaults#doubleTapThreshold
     * @event
     * @default null
     * @param {EventObject} event The original event object
     * @param {DomObject} target The element clicked on.
     */

    /**
    * A long tap handler triggered when a user long clicks or taps on an element.
    * You can set the time delay for a long tap with the {@link $.fn.swipe.defaults#longTapThreshold} property. 
    * @name $.fn.swipe#longTap
    * @see  $.fn.swipe.defaults#longTapThreshold
    * @event
    * @default null
    * @param {EventObject} event The original event object
    * @param {DomObject} target The element clicked on.
    */

}));
// A better SharePoint ribbon
//set top padding of the workspace to the height of the ribbon
function setTopPadding() {
    if ($("#s4-ribbonrow")[0]) {
        var wrkElem = document.getElementById('s4-workspace');
        var ribHeight = document.getElementById('s4-ribbonrow').offsetHeight;
        if (window.location.search.match("[?&]IsDlg=1")) {
            //margin works better for dialogs b/c of scrollbars
            wrkElem.style.marginTop = ribHeight + 'px';
            wrkElem.style.paddingTop = '0px';
        }
        else {
            //padding works better for the main window
            wrkElem.style.paddingTop = ribHeight + 'px';
        }
    }
}

function topNavKeyBoardFix() {
    $(".sp-top-nav").focusin(function () {
        if (event.which == 9) {
            event.preventDefault();
        }
        $(this).find(" > li.dynamic-children").each(function () {
            $(this).focusin(function () {
                //Move to next menu item
                if (event.which == 39) {
                    event.preventDefault();
                    $(this).next();
                    //console.log(event.which);
                }
                //Move to previous menu item
                if (event.which == 37) {
                    event.preventDefault();
                    $(this).previous();
                    //console.log(event.which);
                }
            });
        });

        //});
        //$("li.dynamic-children").keydown(function (event) {
        //    if (event.which == 13) {
        //        event.preventDefault();
        //    }

        //    console.log($(this));
        //    console.log(event.which);

        //    if (!$(this).hasClass("show-subs")) {
        //        $(this).addClass("show-subs hover");
        //    }
        //    else {
        //        $(this).next();
        //    }

        //});
        //$("li.dynamic-children").focusin(function () {
        //    $(this).addClass("show-subs hover");
        //});
        //$("li.dynamic-children").focusout(function () {
        //    $(this).removeClass("show-subs hover");
        //});
    });
}


//Quick links plugin
(function ($) {
    $.fn.extend({
        //plugin name
        menuBarKeyboardSupport: function (options) {

            //Public methods, init is called by default
            var methods = {
                init: function (options) {
                    return this.each(function () {
                        var $this = $(this);
                        if (typeof (settings) == 'undefined') {

                            //Settings list and the default values
                            var defaults = {
                                mode: "",
                                level: "",
                                topLevelClass: "menu-bar-level-1",
                                subNavClass: "menu-bar-sub-nav",
                                subNavOpenClass: "sub-nav-open",
                                hoverClass: "hover"
                            }

                            settings = $.extend({}, defaults, options);

                            $this.data('menuBarKeyboardSupport', settings);
                        } else {
                            settings = $.extend({}, settings, options);
                        }
                        // run code here
                        //First step remove all tab indexes
                        methods.prepClasses($this);
                        methods.removaAllTabIndexes($this);
                        //second step setup each anchor as it recieves focus
                        methods.keyboardEvents($this);
                        methods.setTabIndex($this.find("a:first"));
                        

                    });
                },
                closeSubNav: function (el) {
                    var el = $(el);
                    //Find parent li's parent ul and hide it
                    el.parent().parent().css("left", "-9999em");
                    //remove hover class form great grand parent li
                    el.parent().parent().parent().removeClass("hover");
                    methods.removaAllTabIndexes(el.parent().parent());
                    methods.focus(el.parent().parent().parent().find("a:first"));

                },
                prepClasses: function (el) {
                    var $this = $(el);
                    $this.children().find("a:first").each(function () {
                        $(this).addClass(settings.topLevelClass);
                        //$(this).parent().find("ul:first > li a").each(function () {
                        //    $(this).addClass(settings.secondLevelClass);
                        //})
                    });
                    $this.children().find("li a").each(function () {
                        $(this).addClass(settings.subNavClass);
                    });
                },
                focusNextElement: function(el){
                    var el = $(el)
                    ;       var next = methods.getNextAnchor(el);
                    //console.log(next);
                    methods.removeTabIndex(el);
                    methods.setTabIndex(next);
                    methods.focus(next);
           
                },
                focusPreviousElement: function (el) {
                    var el = $(el);
                    var prev = methods.getPrevAnchor(el);
                    methods.removeTabIndex(el);
                    methods.setTabIndex(prev);
                    methods.focus(prev);
                },
                focusInSub: function (el) {
                    var el = $(el);
                    //console.log(el);
                    //Find parent li's next sibling and focus on the first anchor
                    var li = el.parent();
                    var ul = li.find("ul:first");
                    if ($(ul).length) {
                        var a = $(ul).find("a:first");
                        methods.setTabIndex(a);
                        methods.focus(a);
                    }
                },
                getNextAnchor: function (el) {
                    //return the next anchor in the list, or the first
                    var nextEl;
                    if ($(el).parent().next().find("a:first").length) {
                        nextEl = $(el).parent().next().find("a:first")
                    }
                    else {
                        nextEl = $(el).parent().parent().children().first().find("a:first")
                    }
                    return  nextEl;
                },
                getPrevAnchor: function (el) {
                    //return the previous anchor in the list, or the last
                    var prevEl;
                    if ($(el).parent().prev().find("a:first").length) {
                        prevEl = $(el).parent().prev().find("a:first")
                    }
                    else {
                        prevEl = $(el).parent().parent().children().last().find("a:first")
                    }
                    return prevEl;
                },
                setTabIndex: function(el){
                    $(el).attr("tabindex", "0");
                },
                removaAllTabIndexes: function (el) {
                    var $this = $(el);
                    $this.find("a").each(function () {
                        methods.removeTabIndex($(this));
                    });
                },
                removeTabIndex: function(el){
                    $(el).attr("tabindex", "-1");
                },
                focus: function(el){
                    $(el).focus();
                    methods.setTabIndex(el);
                },
                openSubNav: function (el) {
                    var el = $(el);
                    //Find parent li's next sibling and focus on the first anchor
                    el.parent().addClass("hover").find("ul:first").css("left", "-1px").css("top", "37px");
                },
                
                getParentUl: function (el) {
                    return $(el).parent().parent();
                },
                getParentLi: function (el) {
                    return $(el).parent();
                },
                currentLevel: function(level){
                    settings.level = level;
                },
                currentMode: function (mode) {
                    settings.mode = mode;
                },
                keyboardEvents: function (el) {
                    var $this = $(el);
                    $this.find("a").keydown(function (event) {
                        //console.log(event.which);
                        //Element variables
                        var activeAnchor = $(this);
                        var activeAnchorParentLi = $(this).parent();
                        var activeAnchorParentUl = $(this).parent().parent();

                        //Element heirarchy variables
                        var isSubNavItem = activeAnchor.hasClass(settings.subNavClass);
                        var isToplevelNavItem = activeAnchor.hasClass(settings.topLevelClass);
                        var parentIsTopLevelNavItem = activeAnchor.parent().hasClass(settings.topLevelClass);
                        //Tab key
                        if (event.which == 9) {
                            //event.preventDefault();
                            //var ul = methods.getParentUl(activeAnchor);
                            //var li = activeAnchor.parent();
                            //while (!$(ul).hasClass("root")) {
                            //    if ($(ul).hasClass("root")) {

                            //    }
                            //    else {
                            //        // console.log("root");
                            //        ul = methods.getParentUl(ul);
                            //        li = $(ul).parent();
                            //        //console.log(ul);
                            //        //console.log(li);
                            //    }
                                    
                            //}
                                
                            //methods.closeSubNav(ul);
                            //activeAnchor.attr("tabindex", "-1");
                            //$(li).find("a:first").attr("tabindex", "0");


  
                        }
                        //Enter key
                        if (event.which == 13) {
                            // event.preventDefault();
                        }
                        //Down arrow
                        if (event.which == 40) {
                            event.preventDefault(); 
                            //check if its a first level li
                            if (isToplevelNavItem) {
                                //Show sub nav
                                methods.openSubNav(activeAnchor);
                                   
                                //move focus into sub nav
                                methods.focusInSub(activeAnchor);
                            }
                            else {
                                //move focus to next element
                                methods.focusNextElement(activeAnchor);
                            }
                        }
                        //Esc arrow
                        if (event.which == 27) {
                            event.preventDefault();
                            methods.closeSubNav(activeAnchor);
                        }
                        //Up arrow
                        if (event.which == 38) {
                            event.preventDefault();
                            if (!parentIsTopLevelNavItem) {
                                methods.focusPreviousElement(activeAnchor);
                            }
                        }
                        //Left arrow
                        if (event.which == 37) {
                            event.preventDefault();
                            //check if li has a sub nav and if it aslready being displayed
                            console.log(activeAnchorParentLi.hasClass(settings.hoverClass));
                            if (isSubNavItem) {
                                methods.closeSubNav(activeAnchor);
                                //methods.focusPreviousElement(activeAnchor);
                                console.log("left arrow in sub nav");
                            }
                            else {
                                methods.focusPreviousElement(activeAnchor);
                                console.log("left arrow in top nav");
                            }

                        }
                        //Right arrow
                        if (event.which == 39) {
                            event.preventDefault();
                            if (isSubNavItem) {

                            }
                            else {
                                methods.focusNextElement(activeAnchor);
                            }
                                
                        }                     
                    });
                }
            }

            //Check if a method is specified
            var method = arguments[0];
            if (methods[method]) {
                method = methods[method];
                arguments = Array.prototype.slice.call(arguments, 1);
            } else if (typeof (method) == 'object' || !method) {
                method = methods.init;
            } else {
                $.error('Method ' + method + ' does not exist on jQuery.menuBarKeyboardSupport');
                return this;
            }

            //Call init method, unless another method is specified
            return method.apply(this, arguments);
        }
    });
})(jQuery);function stickyElement(id) {
    // Stick the #nav to the top of the window
    //todo: make this more generic
    if (id.indexOf("#") != -1) {
        var el = $(id);
    }
    else {
        var el = $("." + id + ":first");
    }
    var elHomeY = el.offset().top;
    var isFixed = false;
    var $w = $(window);
    $w.scroll(function () {
        var scrollTop = $w.scrollTop();
        var shouldBeFixed = scrollTop > elHomeY;
        if (shouldBeFixed && !isFixed) {
            el.css({
                top: $("#s4-ribbonrow").height() + "px",
            });
            $("body").addClass("sticky");
            isFixed = true;
        }
        else if (!shouldBeFixed && isFixed) {
            el.css({
                top: "auto",
            });
            $("body").removeClass("sticky");
            isFixed = false;
        }
    });
}

function CreateQuickLinks(headings) {
    try {
        var $applyToPage = $(".breadcrumbs");

        // Apply to ACTs only		
        // if ($applyToPage.text().toString().indexOf("A.") >= 0) {

        var divQlinks = $("<div class='onthispage closed'><a class='toggle-down'><i></i>On this page:</a></div>");
        var ulQlinks = $("<ul>");
        var $this, $a, aName, $h4s;

        var counter = 1;
        var headingArray = $(headings);
        console.log(headingArray);
        $(headings).each(function (key, value) {
            var text = $(this).html();
            var id = "heading-" + key;
            var className = this.nodeName.toLowerCase();
            $(this).prepend("<a id=" + id + "/>");
            var li = $("<li class=" + className +"><a href=#" + id + ">" + text + "</a></li>");
            $(ulQlinks).append(li);
        });
        $(ulQlinks).hide();
        $(divQlinks).append(ulQlinks);
        $(".on-this-page:first").prepend(divQlinks);
        $(".onthispage a:first").click(function () {
            $(this).toggleClass("toggle-down");
            $(this).toggleClass("toggle-up");
            $(".onthispage").toggleClass("closed");
            $(".onthispage").toggleClass("open");
            $(".onthispage ul:first").slideToggle("fast");
        })
        $(".on-this-page").focusout(function () {
            $(".onthispage").toggleClass("closed");
            $(".onthispage").toggleClass("open");
            $(".onthispage ul:first").slideToggle("fast");
        });
    }
    catch (e) { }
}

//Quick links plugin
(function ($) {
    $.fn.extend({
        //plugin name
        quickLinksMenu: function (options) {

            //Public methods, init is called by default
            var methods = {
                init: function (options) {
                    return this.each(function () {
                        var $this = $(this);
                        if (typeof (settings) == 'undefined') {

                            //Settings list and the default values
                            var defaults = {
                                container: "",
                                headings: "h3,h4",
                                menuClass: "quick-links-menu",
                                menuLinkDownClass: "toggle-down",
                                menuLinkUpClass: "toggle-up",
                                menuText: "On this page:",
                                maxHeight:0.8
                            }

                            settings = $.extend({}, defaults, options);

                            $this.data('quickLinksMenu', settings);
                        } else {
                            settings = $.extend({}, settings, options);
                        }

                        // run code here
                        //Setup container div
                        $this.append("<div class='" + settings.menuClass + " closed'><a class='" + settings.menuLinkDownClass + " toggle'><i></i>" + settings.menuText + "</a></div>");
                        
                        methods.createUl();
                        $this.bind("clickoutside", function (event) {
                            if (methods.menuVisible()) {
                                methods.showHideMenu();
                            }
                        });
                        
                    });
                },

                createUl: function (options) {
                    return $(this).each(function () {
                        var $this = $(this);
                        var headingsArray = $(settings.container + " " + settings.headings);
                        var ul = $("<ul>");
                        $(ul).css("max-height", $(window).height() * settings.maxHeight + "px");
                        headingsArray.each(function (key, value) {
                            var textNodes = methods.getTextNodes($(this));
                            var text = methods.getText(textNodes);                        
                            var id = "heading-" + key;
                            var className = this.nodeName.toLowerCase();
                            $(this).prepend("<a id=" + id + "/>");
                            ul.append(methods.createLi(className,id,text));
                            ul.hide();
                        });        
                        $("." + settings.menuClass).append(ul);

                        $("." + settings.menuClass + " a").click(function () {
                            methods.showHideMenu();
                        });
                    });
                },
                //Toggle the visibility of the menu
                showHideMenu: function (options) {
                    $(".toggle").toggleClass("toggle-down").toggleClass("toggle-up");
                    $(".onthispage").toggleClass("closed");
                    $(".onthispage").toggleClass("open");
                    $(".onthispage ul:first").slideToggle("fast");
                },
                menuVisible:function(options){
                    return $("." + settings.menuClass).hasClass("open");
                },
                //Return an array of text nodes
                getTextNodes: function (el) {
                    return $(el).find(":not(iframe)").addBack().contents().filter(function () {
                        return this.nodeType == 3;
                    });
                },
                //Return the joined text from an array of text nodes
                getText: function (nodes) {
                    var text = "";
                    $(nodes).each(function () {
                        text += $(this).text();
                        
                    });
                    return text;
                },
                createLis: function(){
                    
                },
                createLi: function (className, id, text) {
                    return $("<li class=" + className + "><a href=#" + id + ">" + text + "</a></li>");
                }

            }

            //Check if a method is specified
            var method = arguments[0];
            if (methods[method]) {
                method = methods[method];
                arguments = Array.prototype.slice.call(arguments, 1);
            } else if (typeof (method) == 'object' || !method) {
                method = methods.init;
            } else {
                $.error('Method ' + method + ' does not exist on jQuery.quickLinksMenu');
                return this;
            }

            //Call init method, unless another method is specified
            return method.apply(this, arguments);      
        }
    });
})(jQuery);/*************************************************************************
	jquery.dynatree.js
	Dynamic tree view control, with support for lazy loading of branches.

	Copyright (c) 2006-2013, Martin Wendt (http://wwWendt.de)
	Dual licensed under the MIT or GPL Version 2 licenses.
	http://code.google.com/p/dynatree/wiki/LicenseInfo

	A current version and some documentation is available at
		http://dynatree.googlecode.com/

	$Version: 1.2.4$
	$Revision: 644, 2013-02-12 21:39:36$

	@depends: jquery.js
	@depends: jquery.ui.core.js
	@depends: jquery.cookie.js
*************************************************************************/

/* jsHint options*/
// Note: We currently allow eval() to parse the 'data' attribtes, when initializing from HTML.
// TODO: pass jsHint with the options given in grunt.js only.
//       The following should not be required:
/*global alert */
/*jshint nomen:false, smarttabs:true, eqeqeq:false, evil:true, regexp:false */

/*************************************************************************
 *	Debug functions
 */

var _canLog = true;

function _log(mode, msg) {
	/**
	 * Usage: logMsg("%o was toggled", this);
	 */
	if( !_canLog ){
		return;
	}
	// Remove first argument
	var args = Array.prototype.slice.apply(arguments, [1]);
	// Prepend timestamp
	var dt = new Date();
	var tag = dt.getHours()+":"+dt.getMinutes()+":"+dt.getSeconds()+"."+dt.getMilliseconds();
	args[0] = tag + " - " + args[0];

	try {
		switch( mode ) {
		case "info":
			window.console.info.apply(window.console, args);
			break;
		case "warn":
			window.console.warn.apply(window.console, args);
			break;
		default:
			window.console.log.apply(window.console, args);
			break;
		}
	} catch(e) {
		if( !window.console ){
			_canLog = false; // Permanently disable, when logging is not supported by the browser
		}else if(e.number === -2146827850){
			// fix for IE8, where window.console.log() exists, but does not support .apply()
			window.console.log(args.join(", "));
		}
	}
}

/* Check browser version, since $.browser was removed in jQuery 1.9 */
function _checkBrowser(){
	var matched, browser;
	function uaMatch( ua ) {
		ua = ua.toLowerCase();
		var match = /(chrome)[ \/]([\w.]+)/.exec( ua ) ||
			 /(webkit)[ \/]([\w.]+)/.exec( ua ) ||
			 /(opera)(?:.*version|)[ \/]([\w.]+)/.exec( ua ) ||
			 /(msie) ([\w.]+)/.exec( ua ) ||
			 ua.indexOf("compatible") < 0 && /(mozilla)(?:.*? rv:([\w.]+)|)/.exec( ua ) ||
			 [];
		return {
			browser: match[ 1 ] || "",
			version: match[ 2 ] || "0"
		};
	}
	matched = uaMatch( navigator.userAgent );
	browser = {};
	 if ( matched.browser ) {
		 browser[ matched.browser ] = true;
		 browser.version = matched.version;
	 }
	 if ( browser.chrome ) {
		 browser.webkit = true;
	 } else if ( browser.webkit ) {
		 browser.safari = true;
	 }
	 return browser;
}
var BROWSER = jQuery.browser || _checkBrowser();

function logMsg(msg) {
	Array.prototype.unshift.apply(arguments, ["debug"]);
	_log.apply(this, arguments);
}


// Forward declaration
var getDynaTreePersistData = null;



/*************************************************************************
 *	Constants
 */
var DTNodeStatus_Error   = -1;
var DTNodeStatus_Loading = 1;
var DTNodeStatus_Ok      = 0;


// Start of local namespace
(function($) {

/*************************************************************************
 *	Common tool functions.
 */

var Class = {
	create: function() {
		return function() {
			this.initialize.apply(this, arguments);
		};
	}
};

// Tool function to get dtnode from the event target:
function getDtNodeFromElement(el) {
	alert("getDtNodeFromElement is deprecated");
	return $.ui.dynatree.getNode(el);
/*
	var iMax = 5;
	while( el && iMax-- ) {
		if(el.dtnode) { return el.dtnode; }
		el = el.parentNode;
	}
	return null;
*/
}

function noop() {
}

/** Compare two dotted version strings (like '10.2.3').
 * @returns {Integer} 0: v1 == v2, -1: v1 < v2, 1: v1 > v2
 */
function versionCompare(v1, v2) {
	var v1parts = ("" + v1).split("."),
		v2parts = ("" + v2).split("."),
		minLength = Math.min(v1parts.length, v2parts.length),
		p1, p2, i;
	// Compare tuple pair-by-pair.
	for(i = 0; i < minLength; i++) {
		// Convert to integer if possible, because "8" > "10".
		p1 = parseInt(v1parts[i], 10);
		p2 = parseInt(v2parts[i], 10);
		if (isNaN(p1)){ p1 = v1parts[i]; }
		if (isNaN(p2)){ p2 = v2parts[i]; }
		if (p1 == p2) {
			continue;
		}else if (p1 > p2) {
			return 1;
		}else if (p1 < p2) {
			return -1;
		}
		// one operand is NaN
		return NaN;
	}
	// The longer tuple is always considered 'greater'
	if (v1parts.length === v2parts.length) {
		return 0;
	}
	return (v1parts.length < v2parts.length) ? -1 : 1;
}


/*************************************************************************
 *	Class DynaTreeNode
 */
var DynaTreeNode = Class.create();

DynaTreeNode.prototype = {
	initialize: function(parent, tree, data) {
		/**
		 * @constructor
		 */
		this.parent = parent;
		this.tree = tree;
		if ( typeof data === "string" ){
			data = { title: data };
		}
		if( !data.key ){
			data.key = "_" + tree._nodeCount++;
		}else{
			data.key = "" + data.key; // issue 371
		}
		this.data = $.extend({}, $.ui.dynatree.nodedatadefaults, data);
		this.li = null; // not yet created
		this.span = null; // not yet created
		this.ul = null; // not yet created
		this.childList = null; // no subnodes yet
		this._isLoading = false; // Lazy content is being loaded
		this.hasSubSel = false;
		this.bExpanded = false;
		this.bSelected = false;

	},

	toString: function() {
		return "DynaTreeNode<" + this.data.key + ">: '" + this.data.title + "'";
	},

	toDict: function(recursive, callback) {
		var dict = $.extend({}, this.data);
		dict.activate = ( this.tree.activeNode === this );
		dict.focus = ( this.tree.focusNode === this );
		dict.expand = this.bExpanded;
		dict.select = this.bSelected;
		if( callback ){
			callback(dict);
		}
		if( recursive && this.childList ) {
			dict.children = [];
			for(var i=0, l=this.childList.length; i<l; i++ ){
				dict.children.push(this.childList[i].toDict(true, callback));
			}
		} else {
			delete dict.children;
		}
		return dict;
	},

	fromDict: function(dict) {
		/**
		 * Update node data. If dict contains 'children', then also replace
		 * the hole sub tree.
		 */
		var children = dict.children;
		if(children === undefined){
			this.data = $.extend(this.data, dict);
			this.render();
			return;
		}
		dict = $.extend({}, dict);
		dict.children = undefined;
		this.data = $.extend(this.data, dict);
		this.removeChildren();
		this.addChild(children);
	},

	_getInnerHtml: function() {
		var tree = this.tree,
			opts = tree.options,
			cache = tree.cache,
			level = this.getLevel(),
			data = this.data,
			res = "",
			imageSrc;
		// connector (expanded, expandable or simple)
		if( level < opts.minExpandLevel ) {
			if(level > 1){
				res += cache.tagConnector;
			}
			// .. else (i.e. for root level) skip expander/connector altogether
		} else if( this.hasChildren() !== false ) {
			res += cache.tagExpander;
		} else {
			res += cache.tagConnector;
		}
		// Checkbox mode
		if( opts.checkbox && data.hideCheckbox !== true && !data.isStatusNode ) {
			res += cache.tagCheckbox;
		}
		// folder or doctype icon
		if ( data.icon ) {
			if (data.icon.charAt(0) === "/"){
				imageSrc = data.icon;
			}else{
				imageSrc = opts.imagePath + data.icon;
			}
			res += "<img src='" + imageSrc + "' alt='' />";
		} else if ( data.icon === false ) {
			// icon == false means 'no icon'
//			noop(); // keep JSLint happy
		} else if ( data.iconClass ) {
			res +=  "<span class='" + " " + data.iconClass +  "'></span>";
		} else {
			// icon == null means 'default icon'
			res += cache.tagNodeIcon;
		}
		// node title
		var nodeTitle = "";
		if ( opts.onCustomRender ){
			nodeTitle = opts.onCustomRender.call(tree, this) || "";
		}
		if(!nodeTitle){
			var tooltip = data.tooltip ? ' title="' + data.tooltip.replace(/\"/g, '&quot;') + '"' : '',
				href = data.href || "#";
			if( opts.noLink || data.noLink ) {
				nodeTitle = '<span style="display:inline-block;" class="' + opts.classNames.title + '"' + tooltip + '>' + data.title + '</span>';
//				this.tree.logDebug("nodeTitle: " + nodeTitle);
			} else {
				nodeTitle = '<a href="' + href + '" class="' + opts.classNames.title + '"' + tooltip + '>' + data.title + '</a>';
			}
		}
		res += nodeTitle;
		return res;
	},


	_fixOrder: function() {
		/**
		 * Make sure, that <li> order matches childList order.
		 */
		var cl = this.childList;
		if( !cl || !this.ul ){
			return;
		}
		var childLI = this.ul.firstChild;
		for(var i=0, l=cl.length-1; i<l; i++) {
			var childNode1 = cl[i];
			var childNode2 = childLI.dtnode;
			if( childNode1 !== childNode2 ) {
				this.tree.logDebug("_fixOrder: mismatch at index " + i + ": " + childNode1 + " != " + childNode2);
				this.ul.insertBefore(childNode1.li, childNode2.li);
			} else {
				childLI = childLI.nextSibling;
			}
		}
	},


	render: function(useEffects, includeInvisible) {
		/**
		 * Create <li><span>..</span> .. </li> tags for this node.
		 *
		 * <li id='KEY' dtnode=NODE> // This div contains the node's span and list of child div's.
		 *   <span class='title'>S S S A</span> // Span contains graphic spans and title <a> tag
		 *   <ul> // only present, when node has children
		 *       <li id='KEY' dtnode=NODE>child1</li>
		 *       <li id='KEY' dtnode=NODE>child2</li>
		 *   </ul>
		 * </li>
		 */
//		this.tree.logDebug("%s.render(%s)", this, useEffects);
		// ---
		var tree = this.tree,
			parent = this.parent,
			data = this.data,
			opts = tree.options,
			cn = opts.classNames,
			isLastSib = this.isLastSibling(),
			firstTime = false;

		if( !parent && !this.ul ) {
			// Root node has only a <ul>
			this.li = this.span = null;
			this.ul = document.createElement("ul");
			if( opts.minExpandLevel > 1 ){
				this.ul.className = cn.container + " " + cn.noConnector;
			}else{
				this.ul.className = cn.container;
			}
		} else if( parent ) {
			// Create <li><span /> </li>
			if( ! this.li ) {
				firstTime = true;
				this.li = document.createElement("li");
				this.li.dtnode = this;
				if( data.key && opts.generateIds ){
					this.li.id = opts.idPrefix + data.key;
				}
				this.span = document.createElement("span");
				this.span.className = cn.title;
				this.li.appendChild(this.span);

				if( !parent.ul ) {
					// This is the parent's first child: create UL tag
					// (Hidden, because it will be
					parent.ul = document.createElement("ul");
					parent.ul.style.display = "none";
					parent.li.appendChild(parent.ul);
//					if( opts.minExpandLevel > this.getLevel() ){
//						parent.ul.className = cn.noConnector;
//					}
				}
				// set node connector images, links and text
//				this.span.innerHTML = this._getInnerHtml();

				parent.ul.appendChild(this.li);
			}
			// set node connector images, links and text
			this.span.innerHTML = this._getInnerHtml();
			// Set classes for current status
			var cnList = [];
			cnList.push(cn.node);
			if( data.isFolder ){
				cnList.push(cn.folder);
			}
			if( this.bExpanded ){
				cnList.push(cn.expanded);
			}
			if( this.hasChildren() !== false ){
				cnList.push(cn.hasChildren);
			}
			if( data.isLazy && this.childList === null ){
				cnList.push(cn.lazy);
			}
			if( isLastSib ){
				cnList.push(cn.lastsib);
			}
			if( this.bSelected ){
				cnList.push(cn.selected);
			}
			if( this.hasSubSel ){
				cnList.push(cn.partsel);
			}
			if( tree.activeNode === this ){
				cnList.push(cn.active);
			}
			if( data.addClass ){
				cnList.push(data.addClass);
			}
			// IE6 doesn't correctly evaluate multiple class names,
			// so we create combined class names that can be used in the CSS
			cnList.push(cn.combinedExpanderPrefix
					+ (this.bExpanded ? "e" : "c")
					+ (data.isLazy && this.childList === null ? "d" : "")
					+ (isLastSib ? "l" : "")
					);
			cnList.push(cn.combinedIconPrefix
					+ (this.bExpanded ? "e" : "c")
					+ (data.isFolder ? "f" : "")
					);
			this.span.className = cnList.join(" ");

			// TODO: we should not set this in the <span> tag also, if we set it here:
			this.li.className = isLastSib ? cn.lastsib : "";

			// Allow tweaking, binding, after node was created for the first time
			if(firstTime && opts.onCreate){
				opts.onCreate.call(tree, this, this.span);
			}
			// Hide children, if node is collapsed
//			this.ul.style.display = ( this.bExpanded || !parent ) ? "" : "none";
			// Allow tweaking after node state was rendered
			if(opts.onRender){
				opts.onRender.call(tree, this, this.span);
			}
		}
		// Visit child nodes
		if( (this.bExpanded || includeInvisible === true) && this.childList ) {
			for(var i=0, l=this.childList.length; i<l; i++) {
				this.childList[i].render(false, includeInvisible);
			}
			// Make sure the tag order matches the child array
			this._fixOrder();
		}
		// Hide children, if node is collapsed
		if( this.ul ) {
			var isHidden = (this.ul.style.display === "none");
			var isExpanded = !!this.bExpanded;
//			logMsg("isHidden:%s", isHidden);
			if( useEffects && opts.fx && (isHidden === isExpanded) ) {
				var duration = opts.fx.duration || 200;
				$(this.ul).animate(opts.fx, duration);
			} else {
				this.ul.style.display = ( this.bExpanded || !parent ) ? "" : "none";
			}
		}
	},
	/** Return '/id1/id2/id3'. */
	getKeyPath: function(excludeSelf) {
		var path = [];
		this.visitParents(function(node){
			if(node.parent){
				path.unshift(node.data.key);
			}
		}, !excludeSelf);
		return "/" + path.join(this.tree.options.keyPathSeparator);
	},

	getParent: function() {
		return this.parent;
	},

	getChildren: function() {
		if(this.hasChildren() === undefined){
			return undefined; // Lazy node: unloaded, currently loading, or load error
		}
		return this.childList;
	},

	/** Check if node has children (returns undefined, if not sure). */
	hasChildren: function() {
		if(this.data.isLazy){
			if(this.childList === null || this.childList === undefined){
				// Not yet loaded
				return undefined;
			}else if(this.childList.length === 0){
				// Loaded, but response was empty
				return false;
			}else if(this.childList.length === 1 && this.childList[0].isStatusNode()){
				// Currently loading or load error
				return undefined;
			}
			return true;
		}
		return !!this.childList;
	},

	isFirstSibling: function() {
		var p = this.parent;
		return !p || p.childList[0] === this;
	},

	isLastSibling: function() {
		var p = this.parent;
		return !p || p.childList[p.childList.length-1] === this;
	},

	isLoading: function() {
		return !!this._isLoading;
	},

	getPrevSibling: function() {
		if( !this.parent ){
			return null;
		}
		var ac = this.parent.childList;
		for(var i=1, l=ac.length; i<l; i++){ // start with 1, so prev(first) = null
			if( ac[i] === this ){
				return ac[i-1];
			}
		}
		return null;
	},

	getNextSibling: function() {
		if( !this.parent ){
			return null;
		}
		var ac = this.parent.childList;
		for(var i=0, l=ac.length-1; i<l; i++){ // up to length-2, so next(last) = null
			if( ac[i] === this ){
				return ac[i+1];
			}
		}
		return null;
	},

	isStatusNode: function() {
		return (this.data.isStatusNode === true);
	},

	isChildOf: function(otherNode) {
		return (this.parent && this.parent === otherNode);
	},

	isDescendantOf: function(otherNode) {
		if(!otherNode){
			return false;
		}
		var p = this.parent;
		while( p ) {
			if( p === otherNode ){
				return true;
			}
			p = p.parent;
		}
		return false;
	},

	countChildren: function() {
		var cl = this.childList;
		if( !cl ){
			return 0;
		}
		var n = cl.length;
		for(var i=0, l=n; i<l; i++){
			var child = cl[i];
			n += child.countChildren();
		}
		return n;
	},

	/**Sort child list by title.
	 * cmd: optional compare function.
	 * deep: optional: pass true to sort all descendant nodes.
	 */
	sortChildren: function(cmp, deep) {
		var cl = this.childList;
		if( !cl ){
			return;
		}
		cmp = cmp || function(a, b) {
//			return a.data.title === b.data.title ? 0 : a.data.title > b.data.title ? 1 : -1;
			var x = a.data.title.toLowerCase(),
				y = b.data.title.toLowerCase();
			return x === y ? 0 : x > y ? 1 : -1;
			};
		cl.sort(cmp);
		if( deep ){
			for(var i=0, l=cl.length; i<l; i++){
				if( cl[i].childList ){
					cl[i].sortChildren(cmp, "$norender$");
				}
			}
		}
		if( deep !== "$norender$" ){
			this.render();
		}
	},

	_setStatusNode: function(data) {
		// Create, modify or remove the status child node (pass 'null', to remove it).
		var firstChild = ( this.childList ? this.childList[0] : null );
		if( !data ) {
			if ( firstChild && firstChild.isStatusNode()) {
				try{
					// I've seen exceptions here with loadKeyPath...
					if(this.ul){
						this.ul.removeChild(firstChild.li);
						firstChild.li = null; // avoid leaks (issue 215)
					}
				}catch(e){}
				if( this.childList.length === 1 ){
					this.childList = [];
				}else{
					this.childList.shift();
				}
			}
		} else if ( firstChild ) {
			data.isStatusNode = true;
			data.key = "_statusNode";
			firstChild.data = data;
			firstChild.render();
		} else {
			data.isStatusNode = true;
			data.key = "_statusNode";
			firstChild = this.addChild(data);
		}
	},

	setLazyNodeStatus: function(lts, opts) {
		var tooltip = (opts && opts.tooltip) ? opts.tooltip : null,
			info = (opts && opts.info) ? " (" + opts.info + ")" : "";
		switch( lts ) {
			case DTNodeStatus_Ok:
				this._setStatusNode(null);
				$(this.span).removeClass(this.tree.options.classNames.nodeLoading);
				this._isLoading = false;
//				this.render();
				if( this.tree.options.autoFocus ) {
					if( this === this.tree.tnRoot && this.childList && this.childList.length > 0) {
						// special case: using ajaxInit
						this.childList[0].focus();
					} else {
						this.focus();
					}
				}
				break;
			case DTNodeStatus_Loading:
				this._isLoading = true;
				$(this.span).addClass(this.tree.options.classNames.nodeLoading);
				// The root is hidden, so we set a temporary status child
				if(!this.parent){
					this._setStatusNode({
						title: this.tree.options.strings.loading + info,
						tooltip: tooltip,
						addClass: this.tree.options.classNames.nodeWait
					});
				}
				break;
			case DTNodeStatus_Error:
				this._isLoading = false;
//				$(this.span).addClass(this.tree.options.classNames.nodeError);
				this._setStatusNode({
					title: this.tree.options.strings.loadError + info,
					tooltip: tooltip,
					addClass: this.tree.options.classNames.nodeError
				});
				break;
			default:
				throw "Bad LazyNodeStatus: '" + lts + "'.";
		}
	},

	_parentList: function(includeRoot, includeSelf) {
		var l = [];
		var dtn = includeSelf ? this : this.parent;
		while( dtn ) {
			if( includeRoot || dtn.parent ){
				l.unshift(dtn);
			}
			dtn = dtn.parent;
		}
		return l;
	},
	getLevel: function() {
		/**
		 * Return node depth. 0: System root node, 1: visible top-level node.
		 */
		var level = 0;
		var dtn = this.parent;
		while( dtn ) {
			level++;
			dtn = dtn.parent;
		}
		return level;
	},

	_getTypeForOuterNodeEvent: function(event) {
		/** Return the inner node span (title, checkbox or expander) if
		 *  event.target points to the outer span.
		 *  This function should fix issue #93:
		 *  FF2 ignores empty spans, when generating events (returning the parent instead).
		 */
		var cns = this.tree.options.classNames;
		var target = event.target;
		// Only process clicks on an outer node span (probably due to a FF2 event handling bug)
		if( target.className.indexOf(cns.node) < 0 ) {
			return null;
		}
		// Event coordinates, relative to outer node span:
		var eventX = event.pageX - target.offsetLeft;
		var eventY = event.pageY - target.offsetTop;

		for(var i=0, l=target.childNodes.length; i<l; i++) {
			var cn = target.childNodes[i];
			var x = cn.offsetLeft - target.offsetLeft;
			var y = cn.offsetTop - target.offsetTop;
			var nx = cn.clientWidth, ny = cn.clientHeight;
//	        alert (cn.className + ": " + x + ", " + y + ", s:" + nx + ", " + ny);
			if( eventX >= x && eventX <= (x+nx) && eventY >= y && eventY <= (y+ny) ) {
//	            alert("HIT "+ cn.className);
				if( cn.className==cns.title ){
					return "title";
				}else if( cn.className==cns.expander ){
					return "expander";
				}else if( cn.className==cns.checkbox ){
					return "checkbox";
				}else if( cn.className==cns.nodeIcon ){
					return "icon";
				}
			}
		}
		return "prefix";
	},

	getEventTargetType: function(event) {
		// Return the part of a node, that a click event occured on.
		// Note: there is no check, if the event was fired on THIS node.
		var tcn = event && event.target ? event.target.className : "",
			cns = this.tree.options.classNames;

		if( tcn === cns.title ){
			return "title";
		}else if( tcn === cns.expander ){
			return "expander";
		}else if( tcn === cns.checkbox ){
			return "checkbox";
		}else if( tcn === cns.nodeIcon ){
			return "icon";
		}else if( tcn === cns.empty || tcn === cns.vline || tcn === cns.connector ){
			return "prefix";
		}else if( tcn.indexOf(cns.node) >= 0 ){
			// FIX issue #93
			return this._getTypeForOuterNodeEvent(event);
		}
		return null;
	},

	isVisible: function() {
		// Return true, if all parents are expanded.
		var parents = this._parentList(true, false);
		for(var i=0, l=parents.length; i<l; i++){
			if( ! parents[i].bExpanded ){ return false; }
		}
		return true;
	},

	makeVisible: function() {
		// Make sure, all parents are expanded
		var parents = this._parentList(true, false);
		for(var i=0, l=parents.length; i<l; i++){
			parents[i]._expand(true);
		}
	},

	focus: function() {
		// TODO: check, if we already have focus
//		this.tree.logDebug("dtnode.focus(): %o", this);
		this.makeVisible();
		try {
			$(this.span).find(">a").focus();
		} catch(e) { }
	},

	isFocused: function() {
		return (this.tree.tnFocused === this);
	},

	_activate: function(flag, fireEvents) {
		// (De)Activate - but not focus - this node.
		this.tree.logDebug("dtnode._activate(%o, fireEvents=%o) - %o", flag, fireEvents, this);
		var opts = this.tree.options;
		if( this.data.isStatusNode ){
			return;
		}
		if ( fireEvents && opts.onQueryActivate && opts.onQueryActivate.call(this.tree, flag, this) === false ){
			return; // Callback returned false
		}
		if( flag ) {
			// Activate
			if( this.tree.activeNode ) {
				if( this.tree.activeNode === this ){
					return;
				}
				this.tree.activeNode.deactivate();
			}
			if( opts.activeVisible ){
				this.makeVisible();
			}
			this.tree.activeNode = this;
			if( opts.persist ){
				$.cookie(opts.cookieId+"-active", this.data.key, opts.cookie);
			}
			this.tree.persistence.activeKey = this.data.key;
			$(this.span).addClass(opts.classNames.active);
			if ( fireEvents && opts.onActivate ){
				opts.onActivate.call(this.tree, this);
			}
		} else {
			// Deactivate
			if( this.tree.activeNode === this ) {
				if ( opts.onQueryActivate && opts.onQueryActivate.call(this.tree, false, this) === false ){
					return; // Callback returned false
				}
				$(this.span).removeClass(opts.classNames.active);
				if( opts.persist ) {
					// Note: we don't pass null, but ''. So the cookie is not deleted.
					// If we pass null, we also have to pass a COPY of opts, because $cookie will override opts.expires (issue 84)
					$.cookie(opts.cookieId+"-active", "", opts.cookie);
				}
				this.tree.persistence.activeKey = null;
				this.tree.activeNode = null;
				if ( fireEvents && opts.onDeactivate ){
					opts.onDeactivate.call(this.tree, this);
				}
			}
		}
	},

	activate: function() {
		// Select - but not focus - this node.
//		this.tree.logDebug("dtnode.activate(): %o", this);
		this._activate(true, true);
	},

	activateSilently: function() {
		this._activate(true, false);
	},

	deactivate: function() {
//		this.tree.logDebug("dtnode.deactivate(): %o", this);
		this._activate(false, true);
	},

	isActive: function() {
		return (this.tree.activeNode === this);
	},

	_userActivate: function() {
		// Handle user click / [space] / [enter], according to clickFolderMode.
		var activate = true;
		var expand = false;
		if ( this.data.isFolder ) {
			switch( this.tree.options.clickFolderMode ) {
			case 2:
				activate = false;
				expand = true;
				break;
			case 3:
				activate = expand = true;
				break;
			}
		}
		if( this.parent === null ) {
			expand = false;
		}
		if( expand ) {
			this.toggleExpand();
			this.focus();
		}
		if( activate ) {
			this.activate();
		}
	},

	_setSubSel: function(hasSubSel) {
		if( hasSubSel ) {
			this.hasSubSel = true;
			$(this.span).addClass(this.tree.options.classNames.partsel);
		} else {
			this.hasSubSel = false;
			$(this.span).removeClass(this.tree.options.classNames.partsel);
		}
	},
	/**
	 * Fix selection and partsel status, of parent nodes, according to current status of
	 * end nodes.
	 */
	_updatePartSelectionState: function() {
//		alert("_updatePartSelectionState " + this);
//		this.tree.logDebug("_updatePartSelectionState() - %o", this);
		var sel;
		// Return `true` or `false` for end nodes and remove part-sel flag
		if( ! this.hasChildren() ){
			sel = (this.bSelected && !this.data.unselectable && !this.data.isStatusNode);
			this._setSubSel(false);
			return sel;
		}
		// Return `true`, `false`, or `undefined` for parent nodes
		var i, l,
			cl = this.childList,
			allSelected = true,
			allDeselected = true;
		for(i=0, l=cl.length; i<l;  i++) {
			var n = cl[i],
				s = n._updatePartSelectionState();
			if( s !== false){
				allDeselected = false;
			}
			if( s !== true){
				allSelected = false;
			}
		}
		if( allSelected ){
			sel = true;
		} else if ( allDeselected ){
			sel = false;
		} else {
			sel = undefined;
		}
		this._setSubSel(sel === undefined);
		this.bSelected = (sel === true);
		return sel;
	},

	/**
	 * Fix selection status, after this node was (de)selected in multi-hier mode.
	 * This includes (de)selecting all children.
	 */
	_fixSelectionState: function() {
//		alert("_fixSelectionState " + this);
//		this.tree.logDebug("_fixSelectionState(%s) - %o", this.bSelected, this);
		var p, i, l;
		if( this.bSelected ) {
			// Select all children
			this.visit(function(node){
				node.parent._setSubSel(true);
				if(!node.data.unselectable){
					node._select(true, false, false);
				}
			});
			// Select parents, if all children are selected
			p = this.parent;
			while( p ) {
				p._setSubSel(true);
				var allChildsSelected = true;
				for(i=0, l=p.childList.length; i<l;  i++) {
					var n = p.childList[i];
					if( !n.bSelected && !n.data.isStatusNode && !n.data.unselectable) {
					// issue 305 proposes this:
//					if( !n.bSelected && !n.data.isStatusNode ) {
						allChildsSelected = false;
						break;
					}
				}
				if( allChildsSelected ){
					p._select(true, false, false);
				}
				p = p.parent;
			}
		} else {
			// Deselect all children
			this._setSubSel(false);
			this.visit(function(node){
				node._setSubSel(false);
				node._select(false, false, false);
			});
			// Deselect parents, and recalc hasSubSel
			p = this.parent;
			while( p ) {
				p._select(false, false, false);
				var isPartSel = false;
				for(i=0, l=p.childList.length; i<l;  i++) {
					if( p.childList[i].bSelected || p.childList[i].hasSubSel ) {
						isPartSel = true;
						break;
					}
				}
				p._setSubSel(isPartSel);
				p = p.parent;
			}
		}
	},

	_select: function(sel, fireEvents, deep) {
		// Select - but not focus - this node.
//		this.tree.logDebug("dtnode._select(%o) - %o", sel, this);
		var opts = this.tree.options;
		if( this.data.isStatusNode ){
			return;
		}
		//
		if( this.bSelected === sel ) {
//			this.tree.logDebug("dtnode._select(%o) IGNORED - %o", sel, this);
			return;
		}
		// Allow event listener to abort selection
		if ( fireEvents && opts.onQuerySelect && opts.onQuerySelect.call(this.tree, sel, this) === false ){
			return; // Callback returned false
		}
		// Force single-selection
		if( opts.selectMode==1 && sel ) {
			this.tree.visit(function(node){
				if( node.bSelected ) {
					// Deselect; assuming that in selectMode:1 there's max. one other selected node
					node._select(false, false, false);
					return false;
				}
			});
		}

		this.bSelected = sel;
//        this.tree._changeNodeList("select", this, sel);

		if( sel ) {
			if( opts.persist ){
				this.tree.persistence.addSelect(this.data.key);
			}
			$(this.span).addClass(opts.classNames.selected);

			if( deep && opts.selectMode === 3 ){
				this._fixSelectionState();
			}
			if ( fireEvents && opts.onSelect ){
				opts.onSelect.call(this.tree, true, this);
			}
		} else {
			if( opts.persist ){
				this.tree.persistence.clearSelect(this.data.key);
			}
			$(this.span).removeClass(opts.classNames.selected);

			if( deep && opts.selectMode === 3 ){
				this._fixSelectionState();
			}
			if ( fireEvents && opts.onSelect ){
				opts.onSelect.call(this.tree, false, this);
			}
		}
	},

	select: function(sel) {
		// Select - but not focus - this node.
//		this.tree.logDebug("dtnode.select(%o) - %o", sel, this);
		if( this.data.unselectable ){
			return this.bSelected;
		}
		return this._select(sel!==false, true, true);
	},

	toggleSelect: function() {
//		this.tree.logDebug("dtnode.toggleSelect() - %o", this);
		return this.select(!this.bSelected);
	},

	isSelected: function() {
		return this.bSelected;
	},

	isLazy: function() {
		return !!this.data.isLazy;
	},

	_loadContent: function() {
		try {
			var opts = this.tree.options;
			this.tree.logDebug("_loadContent: start - %o", this);
			this.setLazyNodeStatus(DTNodeStatus_Loading);
			if( true === opts.onLazyRead.call(this.tree, this) ) {
				// If function returns 'true', we assume that the loading is done:
				this.setLazyNodeStatus(DTNodeStatus_Ok);
				// Otherwise (i.e. if the loading was started as an asynchronous process)
				// the onLazyRead(dtnode) handler is expected to call dtnode.setLazyNodeStatus(DTNodeStatus_Ok/_Error) when done.
				this.tree.logDebug("_loadContent: succeeded - %o", this);
			}
		} catch(e) {
			this.tree.logWarning("_loadContent: failed - %o", e);
			this.setLazyNodeStatus(DTNodeStatus_Error, {tooltip: ""+e});
		}
	},

	_expand: function(bExpand, forceSync) {
		if( this.bExpanded === bExpand ) {
			this.tree.logDebug("dtnode._expand(%o) IGNORED - %o", bExpand, this);
			return;
		}
		this.tree.logDebug("dtnode._expand(%o) - %o", bExpand, this);
		var opts = this.tree.options;
		if( !bExpand && this.getLevel() < opts.minExpandLevel ) {
			this.tree.logDebug("dtnode._expand(%o) prevented collapse - %o", bExpand, this);
			return;
		}
		if ( opts.onQueryExpand && opts.onQueryExpand.call(this.tree, bExpand, this) === false ){
			return; // Callback returned false
		}
		this.bExpanded = bExpand;

		// Persist expand state
		if( opts.persist ) {
			if( bExpand ){
				this.tree.persistence.addExpand(this.data.key);
			}else{
				this.tree.persistence.clearExpand(this.data.key);
			}
		}
		// Do not apply animations in init phase, or before lazy-loading
		var allowEffects = !(this.data.isLazy && this.childList === null)
			&& !this._isLoading
			&& !forceSync;
		this.render(allowEffects);

		// Auto-collapse mode: collapse all siblings
		if( this.bExpanded && this.parent && opts.autoCollapse ) {
			var parents = this._parentList(false, true);
			for(var i=0, l=parents.length; i<l; i++){
				parents[i].collapseSiblings();
			}
		}
		// If the currently active node is now hidden, deactivate it
		if( opts.activeVisible && this.tree.activeNode && ! this.tree.activeNode.isVisible() ) {
			this.tree.activeNode.deactivate();
		}
		// Expanding a lazy node: set 'loading...' and call callback
		if( bExpand && this.data.isLazy && this.childList === null && !this._isLoading ) {
			this._loadContent();
			return;
		}
		if ( opts.onExpand ){
			opts.onExpand.call(this.tree, bExpand, this);
		}
	},

	isExpanded: function() {
		return this.bExpanded;
	},

	expand: function(flag) {
		flag = (flag !== false);
		if( !this.childList && !this.data.isLazy && flag ){
			return; // Prevent expanding empty nodes
		} else if( this.parent === null && !flag ){
			return; // Prevent collapsing the root
		}
		this._expand(flag);
	},

	scheduleAction: function(mode, ms) {
		/** Schedule activity for delayed execution (cancel any pending request).
		 *  scheduleAction('cancel') will cancel the request.
		 */
		if( this.tree.timer ) {
			clearTimeout(this.tree.timer);
			this.tree.logDebug("clearTimeout(%o)", this.tree.timer);
		}
		var self = this; // required for closures
		switch (mode) {
		case "cancel":
			// Simply made sure that timer was cleared
			break;
		case "expand":
			this.tree.timer = setTimeout(function(){
				self.tree.logDebug("setTimeout: trigger expand");
				self.expand(true);
			}, ms);
			break;
		case "activate":
			this.tree.timer = setTimeout(function(){
				self.tree.logDebug("setTimeout: trigger activate");
				self.activate();
			}, ms);
			break;
		default:
			throw "Invalid mode " + mode;
		}
		this.tree.logDebug("setTimeout(%s, %s): %s", mode, ms, this.tree.timer);
	},

	toggleExpand: function() {
		this.expand(!this.bExpanded);
	},

	collapseSiblings: function() {
		if( this.parent === null ){
			return;
		}
		var ac = this.parent.childList;
		for (var i=0, l=ac.length; i<l; i++) {
			if ( ac[i] !== this && ac[i].bExpanded ){
				ac[i]._expand(false);
			}
		}
	},

	_onClick: function(event) {
//		this.tree.logDebug("dtnode.onClick(" + event.type + "): dtnode:" + this + ", button:" + event.button + ", which: " + event.which);
		var targetType = this.getEventTargetType(event);
		if( targetType === "expander" ) {
			// Clicking the expander icon always expands/collapses
			this.toggleExpand();
			this.focus(); // issue 95
		} else if( targetType === "checkbox" ) {
			// Clicking the checkbox always (de)selects
			this.toggleSelect();
			this.focus(); // issue 95
		} else {
			this._userActivate();
			var aTag = this.span.getElementsByTagName("a");
			if(aTag[0]){
				// issue 154, 313
//                if(!($.browser.msie && parseInt($.browser.version, 10) < 9)){
				if(!(BROWSER.msie && parseInt(BROWSER.version, 10) < 9)){
					aTag[0].focus();
				}
			}else{
				// 'noLink' option was set
				return true;
			}
		}
		// Make sure that clicks stop, otherwise <a href='#'> jumps to the top
		event.preventDefault();
	},

	_onDblClick: function(event) {
//		this.tree.logDebug("dtnode.onDblClick(" + event.type + "): dtnode:" + this + ", button:" + event.button + ", which: " + event.which);
	},

	_onKeydown: function(event) {
//		this.tree.logDebug("dtnode.onKeydown(" + event.type + "): dtnode:" + this + ", charCode:" + event.charCode + ", keyCode: " + event.keyCode + ", which: " + event.which);
		var handled = true,
			sib;
//		alert("keyDown" + event.which);

		switch( event.which ) {
			// charCodes:
//			case 43: // '+'
			case 107: // '+'
			case 187: // '+' @ Chrome, Safari
				if( !this.bExpanded ){ this.toggleExpand(); }
				break;
//			case 45: // '-'
			case 109: // '-'
			case 189: // '+' @ Chrome, Safari
				if( this.bExpanded ){ this.toggleExpand(); }
				break;
			//~ case 42: // '*'
				//~ break;
			//~ case 47: // '/'
				//~ break;
			// case 13: // <enter>
				// <enter> on a focused <a> tag seems to generate a click-event.
				// this._userActivate();
				// break;
			case 32: // <space>
				this._userActivate();
				break;
			case 8: // <backspace>
				if( this.parent ){
					this.parent.focus();
				}
				break;
			case 37: // <left>
				if( this.bExpanded ) {
					this.toggleExpand();
					this.focus();
//				} else if( this.parent && (this.tree.options.rootVisible || this.parent.parent) ) {
				} else if( this.parent && this.parent.parent ) {
					this.parent.focus();
				}
				break;
			case 39: // <right>
				if( !this.bExpanded && (this.childList || this.data.isLazy) ) {
					this.toggleExpand();
					this.focus();
				} else if( this.childList ) {
					this.childList[0].focus();
				}
				break;
			case 38: // <up>
				sib = this.getPrevSibling();
				while( sib && sib.bExpanded && sib.childList ){
					sib = sib.childList[sib.childList.length-1];
				}
//				if( !sib && this.parent && (this.tree.options.rootVisible || this.parent.parent) )
				if( !sib && this.parent && this.parent.parent ){
					sib = this.parent;
				}
				if( sib ){
					sib.focus();
				}
				break;
			case 40: // <down>
				if( this.bExpanded && this.childList ) {
					sib = this.childList[0];
				} else {
					var parents = this._parentList(false, true);
					for(var i=parents.length-1; i>=0; i--) {
						sib = parents[i].getNextSibling();
						if( sib ){ break; }
					}
				}
				if( sib ){
					sib.focus();
				}
				break;
			default:
				handled = false;
		}
		// Return false, if handled, to prevent default processing
//		return !handled;
		if(handled){
			event.preventDefault();
		}
	},

	_onKeypress: function(event) {
		// onKeypress is only hooked to allow user callbacks.
		// We don't process it, because IE and Safari don't fire keypress for cursor keys.
//		this.tree.logDebug("dtnode.onKeypress(" + event.type + "): dtnode:" + this + ", charCode:" + event.charCode + ", keyCode: " + event.keyCode + ", which: " + event.which);
	},

	_onFocus: function(event) {
		// Handles blur and focus events.
//		this.tree.logDebug("dtnode._onFocus(%o): %o", event, this);
		var opts = this.tree.options;
		if ( event.type == "blur" || event.type == "focusout" ) {
			if ( opts.onBlur ){
				opts.onBlur.call(this.tree, this);
			}
			if( this.tree.tnFocused ){
				$(this.tree.tnFocused.span).removeClass(opts.classNames.focused);
			}
			this.tree.tnFocused = null;
			if( opts.persist ){
				$.cookie(opts.cookieId+"-focus", "", opts.cookie);
			}
		} else if ( event.type=="focus" || event.type=="focusin") {
			// Fix: sometimes the blur event is not generated
			if( this.tree.tnFocused && this.tree.tnFocused !== this ) {
				this.tree.logDebug("dtnode.onFocus: out of sync: curFocus: %o", this.tree.tnFocused);
				$(this.tree.tnFocused.span).removeClass(opts.classNames.focused);
			}
			this.tree.tnFocused = this;
			if ( opts.onFocus ){
				opts.onFocus.call(this.tree, this);
			}
			$(this.tree.tnFocused.span).addClass(opts.classNames.focused);
			if( opts.persist ){
				$.cookie(opts.cookieId+"-focus", this.data.key, opts.cookie);
			}
		}
		// TODO: return anything?
//		return false;
	},

	visit: function(fn, includeSelf) {
		// Call fn(node) for all child nodes. Stop iteration, if fn() returns false.
		var res = true;
		if( includeSelf === true ) {
			res = fn(this);
			if( res === false || res == "skip" ){
				return res;
			}
		}
		if(this.childList){
			for(var i=0, l=this.childList.length; i<l; i++){
				res = this.childList[i].visit(fn, true);
				if( res === false ){
					break;
				}
			}
		}
		return res;
	},

	visitParents: function(fn, includeSelf) {
		// Visit parent nodes (bottom up)
		if(includeSelf && fn(this) === false){
			return false;
		}
		var p = this.parent;
		while( p ) {
			if(fn(p) === false){
				return false;
			}
			p = p.parent;
		}
		return true;
	},

	remove: function() {
		// Remove this node
//		this.tree.logDebug ("%s.remove()", this);
		if ( this === this.tree.root ){
			throw "Cannot remove system root";
		}
		return this.parent.removeChild(this);
	},

	removeChild: function(tn) {
		// Remove tn from list of direct children.
		var ac = this.childList;
		if( ac.length == 1 ) {
			if( tn !== ac[0] ){
				throw "removeChild: invalid child";
			}
			return this.removeChildren();
		}
		if( tn === this.tree.activeNode ){
			tn.deactivate();
		}
		if( this.tree.options.persist ) {
			if( tn.bSelected ){
				this.tree.persistence.clearSelect(tn.data.key);
			}
			if ( tn.bExpanded ){
				this.tree.persistence.clearExpand(tn.data.key);
			}
		}
		tn.removeChildren(true);
		if(this.ul){
//			$("li", $(this.ul)).remove(); // issue 399
			this.ul.removeChild(tn.li); // issue 402
		}
		for(var i=0, l=ac.length; i<l; i++) {
			if( ac[i] === tn ) {
				this.childList.splice(i, 1);
//				delete tn;  // JSLint complained
				break;
			}
		}
	},

	removeChildren: function(isRecursiveCall, retainPersistence) {
		// Remove all child nodes (more efficiently than recursive remove())
		this.tree.logDebug("%s.removeChildren(%o)", this, isRecursiveCall);
		var tree = this.tree;
		var ac = this.childList;
		if( ac ) {
			for(var i=0, l=ac.length; i<l; i++) {
				var tn = ac[i];
				if ( tn === tree.activeNode && !retainPersistence ){
					tn.deactivate();
				}
				if( this.tree.options.persist && !retainPersistence ) {
					if( tn.bSelected ){
						this.tree.persistence.clearSelect(tn.data.key);
					}
					if ( tn.bExpanded ){
						this.tree.persistence.clearExpand(tn.data.key);
					}
				}
				tn.removeChildren(true, retainPersistence);
				if(this.ul){
//					this.ul.removeChild(tn.li);
					$("li", $(this.ul)).remove(); // issue 231
				}
//				delete tn;  JSLint complained
			}
			// Set to 'null' which is interpreted as 'not yet loaded' for lazy
			// nodes
			this.childList = null;
		}
		if( ! isRecursiveCall ) {
//			this._expand(false);
//			this.isRead = false;
			this._isLoading = false;
			this.render();
		}
	},

	setTitle: function(title) {
		this.fromDict({title: title});
	},

	reload: function(force) {
		throw "Use reloadChildren() instead";
	},

	reloadChildren: function(callback) {
		// Reload lazy content (expansion state is maintained).
		if( this.parent === null ){
			throw "Use tree.reload() instead";
		}else if( ! this.data.isLazy ){
			throw "node.reloadChildren() requires lazy nodes.";
		}
		// appendAjax triggers 'nodeLoaded' event.
		// We listen to this, if a callback was passed to reloadChildren
		if(callback){
			var self = this;
			var eventType = "nodeLoaded.dynatree." + this.tree.$tree.attr("id")
				+ "." + this.data.key;
			this.tree.$tree.bind(eventType, function(e, node, isOk){
				self.tree.$tree.unbind(eventType);
				self.tree.logDebug("loaded %o, %o, %o", e, node, isOk);
				if(node !== self){
					throw "got invalid load event";
				}
				callback.call(self.tree, node, isOk);
			});
		}
		// The expansion state is maintained
		this.removeChildren();
		this._loadContent();
//		if( this.bExpanded ) {
//			// Remove children first, to prevent effects being applied
//			this.removeChildren();
//			// then force re-expand to trigger lazy loading
////			this.expand(false);
////			this.expand(true);
//			this._loadContent();
//		} else {
//			this.removeChildren();
//			this._loadContent();
//		}
	},

	/**
	 * Make sure the node with a given key path is available in the tree.
	 */
	_loadKeyPath: function(keyPath, callback) {
		var tree = this.tree;
		tree.logDebug("%s._loadKeyPath(%s)", this, keyPath);
		if(keyPath === ""){
			throw "Key path must not be empty";
		}
		var segList = keyPath.split(tree.options.keyPathSeparator);
		if(segList[0] === ""){
			throw "Key path must be relative (don't start with '/')";
		}
		var seg = segList.shift();
		if(this.childList){
			for(var i=0, l=this.childList.length; i < l; i++){
				var child = this.childList[i];
				if( child.data.key === seg ){
					if(segList.length === 0) {
						// Found the end node
						callback.call(tree, child, "ok");

					}else if(child.data.isLazy && (child.childList === null || child.childList === undefined)){
						tree.logDebug("%s._loadKeyPath(%s) -> reloading %s...", this, keyPath, child);
						var self = this;
						// Note: this line gives a JSLint warning (Don't make functions within a loop)
						/*jshint loopfunc:true */
						child.reloadChildren(function(node, isOk){
							// After loading, look for direct child with that key
							if(isOk){
								tree.logDebug("%s._loadKeyPath(%s) -> reloaded %s.", node, keyPath, node);
								callback.call(tree, child, "loaded");
								node._loadKeyPath(segList.join(tree.options.keyPathSeparator), callback);
							}else{
								tree.logWarning("%s._loadKeyPath(%s) -> reloadChildren() failed.", self, keyPath);
								callback.call(tree, child, "error");
							}
						});
						// we can ignore it, since it will only be exectuted once, the the loop is ended
						// See also http://stackoverflow.com/questions/3037598/how-to-get-around-the-jslint-error-dont-make-functions-within-a-loop
					} else {
						callback.call(tree, child, "loaded");
						// Look for direct child with that key
						child._loadKeyPath(segList.join(tree.options.keyPathSeparator), callback);
					}
					return;
				}
			}
		}
		// Could not find key
		// Callback params: child: undefined, the segment, isEndNode (segList.length === 0)
		callback.call(tree, undefined, "notfound", seg, segList.length === 0);
		tree.logWarning("Node not found: " + seg);
		return;
	},

	resetLazy: function() {
		// Discard lazy content.
		if( this.parent === null ){
			throw "Use tree.reload() instead";
		}else if( ! this.data.isLazy ){
			throw "node.resetLazy() requires lazy nodes.";
		}
		this.expand(false);
		this.removeChildren();
	},

	_addChildNode: function(dtnode, beforeNode) {
		/**
		 * Internal function to add one single DynatreeNode as a child.
		 *
		 */
		var tree = this.tree,
			opts = tree.options,
			pers = tree.persistence;

//		tree.logDebug("%s._addChildNode(%o)", this, dtnode);

		// --- Update and fix dtnode attributes if necessary
		dtnode.parent = this;
//		if( beforeNode && (beforeNode.parent !== this || beforeNode === dtnode ) )
//			throw "<beforeNode> must be another child of <this>";

		// --- Add dtnode as a child
		if ( this.childList === null ) {
			this.childList = [];
		} else if( ! beforeNode ) {
			// Fix 'lastsib'
			if(this.childList.length > 0) {
				$(this.childList[this.childList.length-1].span).removeClass(opts.classNames.lastsib);
			}
		}
		if( beforeNode ) {
			var iBefore = $.inArray(beforeNode, this.childList);
			if( iBefore < 0 ){
				throw "<beforeNode> must be a child of <this>";
			}
			this.childList.splice(iBefore, 0, dtnode);
		} else {
			// Append node
			this.childList.push(dtnode);
		}

		// --- Handle persistence
		// Initial status is read from cookies, if persistence is active and
		// cookies are already present.
		// Otherwise the status is read from the data attributes and then persisted.
		var isInitializing = tree.isInitializing();
		if( opts.persist && pers.cookiesFound && isInitializing ) {
			// Init status from cookies
//			tree.logDebug("init from cookie, pa=%o, dk=%o", pers.activeKey, dtnode.data.key);
			if( pers.activeKey === dtnode.data.key ){
				tree.activeNode = dtnode;
			}
			if( pers.focusedKey === dtnode.data.key ){
				tree.focusNode = dtnode;
			}
			dtnode.bExpanded = ($.inArray(dtnode.data.key, pers.expandedKeyList) >= 0);
			dtnode.bSelected = ($.inArray(dtnode.data.key, pers.selectedKeyList) >= 0);
//			tree.logDebug("    key=%o, bSelected=%o", dtnode.data.key, dtnode.bSelected);
		} else {
			// Init status from data (Note: we write the cookies after the init phase)
//			tree.logDebug("init from data");
			if( dtnode.data.activate ) {
				tree.activeNode = dtnode;
				if( opts.persist ){
					pers.activeKey = dtnode.data.key;
				}
			}
			if( dtnode.data.focus ) {
				tree.focusNode = dtnode;
				if( opts.persist ){
					pers.focusedKey = dtnode.data.key;
				}
			}
			dtnode.bExpanded = ( dtnode.data.expand === true ); // Collapsed by default
			if( dtnode.bExpanded && opts.persist ){
				pers.addExpand(dtnode.data.key);
			}
			dtnode.bSelected = ( dtnode.data.select === true ); // Deselected by default
/*
			Doesn't work, cause pers.selectedKeyList may be null
			if( dtnode.bSelected && opts.selectMode==1
				&& pers.selectedKeyList && pers.selectedKeyList.length>0 ) {
				tree.logWarning("Ignored multi-selection in single-mode for %o", dtnode);
				dtnode.bSelected = false; // Fixing bad input data (multi selection for mode:1)
			}
*/
			if( dtnode.bSelected && opts.persist ){
				pers.addSelect(dtnode.data.key);
			}
		}

		// Always expand, if it's below minExpandLevel
//		tree.logDebug ("%s._addChildNode(%o), l=%o", this, dtnode, dtnode.getLevel());
		if ( opts.minExpandLevel >= dtnode.getLevel() ) {
//			tree.logDebug ("Force expand for %o", dtnode);
			this.bExpanded = true;
		}

		// In multi-hier mode, update the parents selection state
		// issue #82: only if not initializing, because the children may not exist yet
//		if( !dtnode.data.isStatusNode && opts.selectMode==3 && !isInitializing )
//			dtnode._fixSelectionState();

		// In multi-hier mode, update the parents selection state
		if( dtnode.bSelected && opts.selectMode==3 ) {
			var p = this;
			while( p ) {
				if( !p.hasSubSel ){
					p._setSubSel(true);
				}
				p = p.parent;
			}
		}
		// render this node and the new child
		if ( tree.bEnableUpdate ){
			this.render();
		}
		return dtnode;
	},

	addChild: function(obj, beforeNode) {
		/**
		 * Add a node object as child.
		 *
		 * This should be the only place, where a DynaTreeNode is constructed!
		 * (Except for the root node creation in the tree constructor)
		 *
		 * @param obj A JS object (may be recursive) or an array of those.
		 * @param {DynaTreeNode} beforeNode (optional) sibling node.
		 *
		 * Data format: array of node objects, with optional 'children' attributes.
		 * [
		 *	{ title: "t1", isFolder: true, ... }
		 *	{ title: "t2", isFolder: true, ...,
		 *		children: [
		 *			{title: "t2.1", ..},
		 *			{..}
		 *			]
		 *	}
		 * ]
		 * A simple object is also accepted instead of an array.
		 *
		 */
//		this.tree.logDebug("%s.addChild(%o, %o)", this, obj, beforeNode);
		if(typeof(obj) == "string"){
			throw "Invalid data type for " + obj;
		}else if( !obj || obj.length === 0 ){ // Passed null or undefined or empty array
			return;
		}else if( obj instanceof DynaTreeNode ){
			return this._addChildNode(obj, beforeNode);
		}

		if( !obj.length ){ // Passed a single data object
			obj = [ obj ];
		}
		var prevFlag = this.tree.enableUpdate(false);

		var tnFirst = null;
		for (var i=0, l=obj.length; i<l; i++) {
			var data = obj[i];
			var dtnode = this._addChildNode(new DynaTreeNode(this, this.tree, data), beforeNode);
			if( !tnFirst ){
				tnFirst = dtnode;
			}
			// Add child nodes recursively
			if( data.children ){
				dtnode.addChild(data.children, null);
			}
		}
		this.tree.enableUpdate(prevFlag);
		return tnFirst;
	},

	append: function(obj) {
		this.tree.logWarning("node.append() is deprecated (use node.addChild() instead).");
		return this.addChild(obj, null);
	},

	appendAjax: function(ajaxOptions) {
		var self = this;
		this.removeChildren(false, true);
		this.setLazyNodeStatus(DTNodeStatus_Loading);
		// Debug feature: force a delay, to simulate slow loading...
		if(ajaxOptions.debugLazyDelay){
			var ms = ajaxOptions.debugLazyDelay;
			ajaxOptions.debugLazyDelay = 0;
			this.tree.logInfo("appendAjax: waiting for debugLazyDelay " + ms);
			setTimeout(function(){self.appendAjax(ajaxOptions);}, ms);
			return;
		}
		// Ajax option inheritance: $.ajaxSetup < $.ui.dynatree.prototype.options.ajaxDefaults < tree.options.ajaxDefaults < ajaxOptions
		var orgSuccess = ajaxOptions.success,
			orgError = ajaxOptions.error,
			eventType = "nodeLoaded.dynatree." + this.tree.$tree.attr("id") + "." + this.data.key;
		var options = $.extend({}, this.tree.options.ajaxDefaults, ajaxOptions, {
			success: function(data, textStatus, jqXHR){
				// <this> is the request options
//				self.tree.logDebug("appendAjax().success");
				var prevPhase = self.tree.phase;
				self.tree.phase = "init";
				// postProcess is similar to the standard dataFilter hook,
				// but it is also called for JSONP
				if( options.postProcess ){
					data = options.postProcess.call(this, data, this.dataType);
				}
				// Process ASPX WebMethod JSON object inside "d" property
				// http://code.google.com/p/dynatree/issues/detail?id=202
				else if (data && data.hasOwnProperty("d")) {
				   data = (typeof data.d) == "string" ? $.parseJSON(data.d) : data.d;
				}
				if(!$.isArray(data) || data.length !== 0){
					self.addChild(data, null);
				}
				self.tree.phase = "postInit";
				if( orgSuccess ){
					orgSuccess.call(options, self, data, textStatus);
				}
				self.tree.logDebug("trigger " + eventType);
				self.tree.$tree.trigger(eventType, [self, true]);
				self.tree.phase = prevPhase;
				// This should be the last command, so node._isLoading is true
				// while the callbacks run
				self.setLazyNodeStatus(DTNodeStatus_Ok);
				if($.isArray(data) && data.length === 0){
					// Set to [] which is interpreted as 'no children' for lazy
					// nodes
					self.childList = [];
					self.render();
				}
				},
			error: function(jqXHR, textStatus, errorThrown){
				// <this> is the request options
				self.tree.logWarning("appendAjax failed:", textStatus, ":\n", jqXHR, "\n", errorThrown);
				if( orgError ){
					orgError.call(options, self, jqXHR, textStatus, errorThrown);
				}
				self.tree.$tree.trigger(eventType, [self, false]);
				self.setLazyNodeStatus(DTNodeStatus_Error, {info: textStatus, tooltip: "" + errorThrown});
				}
		});
		$.ajax(options);
	},

	move: function(targetNode, mode) {
		/**Move this node to targetNode.
		 *  mode 'child': append this node as last child of targetNode.
		 *                This is the default. To be compatble with the D'n'd
		 *                hitMode, we also accept 'over'.
		 *  mode 'before': add this node as sibling before targetNode.
		 *  mode 'after': add this node as sibling after targetNode.
		 */
		var pos;
		if(this === targetNode){
			return;
		}
		if( !this.parent  ){
			throw "Cannot move system root";
		}
		if(mode === undefined || mode == "over"){
			mode = "child";
		}
		var prevParent = this.parent;
		var targetParent = (mode === "child") ? targetNode : targetNode.parent;
		if( targetParent.isDescendantOf(this) ){
			throw "Cannot move a node to it's own descendant";
		}
		// Unlink this node from current parent
		if( this.parent.childList.length == 1 ) {
			this.parent.childList = this.parent.data.isLazy ? [] : null;
			this.parent.bExpanded = false;
		} else {
			pos = $.inArray(this, this.parent.childList);
			if( pos < 0 ){
				throw "Internal error";
			}
			this.parent.childList.splice(pos, 1);
		}
		// Remove from source DOM parent
		if(this.parent.ul){
			this.parent.ul.removeChild(this.li);
		}

		// Insert this node to target parent's child list
		this.parent = targetParent;
		if( targetParent.hasChildren() ) {
			switch(mode) {
			case "child":
				// Append to existing target children
				targetParent.childList.push(this);
				break;
			case "before":
				// Insert this node before target node
				pos = $.inArray(targetNode, targetParent.childList);
				if( pos < 0 ){
					throw "Internal error";
				}
				targetParent.childList.splice(pos, 0, this);
				break;
			case "after":
				// Insert this node after target node
				pos = $.inArray(targetNode, targetParent.childList);
				if( pos < 0 ){
					throw "Internal error";
				}
				targetParent.childList.splice(pos+1, 0, this);
				break;
			default:
				throw "Invalid mode " + mode;
			}
		} else {
			targetParent.childList = [ this ];
		}
		// Parent has no <ul> tag yet:
		if( !targetParent.ul ) {
			// This is the parent's first child: create UL tag
			// (Hidden, because it will be
			targetParent.ul = document.createElement("ul");
			targetParent.ul.style.display = "none";
			targetParent.li.appendChild(targetParent.ul);
		}
		// Issue 319: Add to target DOM parent (only if node was already rendered(expanded))
		if(this.li){
			targetParent.ul.appendChild(this.li);
		}

		if( this.tree !== targetNode.tree ) {
			// Fix node.tree for all source nodes
			this.visit(function(node){
				node.tree = targetNode.tree;
			}, null, true);
			throw "Not yet implemented.";
		}
		// TODO: fix selection state
		// TODO: fix active state
		if( !prevParent.isDescendantOf(targetParent)) {
			prevParent.render();
		}
		if( !targetParent.isDescendantOf(prevParent) ) {
			targetParent.render();
		}
//		this.tree.redraw();
/*
		var tree = this.tree;
		var opts = tree.options;
		var pers = tree.persistence;


		// Always expand, if it's below minExpandLevel
//		tree.logDebug ("%s._addChildNode(%o), l=%o", this, dtnode, dtnode.getLevel());
		if ( opts.minExpandLevel >= dtnode.getLevel() ) {
//			tree.logDebug ("Force expand for %o", dtnode);
			this.bExpanded = true;
		}

		// In multi-hier mode, update the parents selection state
		// issue #82: only if not initializing, because the children may not exist yet
//		if( !dtnode.data.isStatusNode && opts.selectMode==3 && !isInitializing )
//			dtnode._fixSelectionState();

		// In multi-hier mode, update the parents selection state
		if( dtnode.bSelected && opts.selectMode==3 ) {
			var p = this;
			while( p ) {
				if( !p.hasSubSel )
					p._setSubSel(true);
				p = p.parent;
			}
		}
		// render this node and the new child
		if ( tree.bEnableUpdate )
			this.render();

		return dtnode;

*/
	},

	// --- end of class
	lastentry: undefined
};

/*************************************************************************
 * class DynaTreeStatus
 */

var DynaTreeStatus = Class.create();


DynaTreeStatus._getTreePersistData = function(cookieId, cookieOpts) {
	// Static member: Return persistence information from cookies
	var ts = new DynaTreeStatus(cookieId, cookieOpts);
	ts.read();
	return ts.toDict();
};
// Make available in global scope
getDynaTreePersistData = DynaTreeStatus._getTreePersistData; // TODO: deprecated


DynaTreeStatus.prototype = {
	// Constructor
	initialize: function(cookieId, cookieOpts) {
//		this._log("DynaTreeStatus: initialize");
		if( cookieId === undefined ){
			cookieId = $.ui.dynatree.prototype.options.cookieId;
		}
		cookieOpts = $.extend({}, $.ui.dynatree.prototype.options.cookie, cookieOpts);

		this.cookieId = cookieId;
		this.cookieOpts = cookieOpts;
		this.cookiesFound = undefined;
		this.activeKey = null;
		this.focusedKey = null;
		this.expandedKeyList = null;
		this.selectedKeyList = null;
	},
	// member functions
	_log: function(msg) {
		//	this.logDebug("_changeNodeList(%o): nodeList:%o, idx:%o", mode, nodeList, idx);
		Array.prototype.unshift.apply(arguments, ["debug"]);
		_log.apply(this, arguments);
	},
	read: function() {
//		this._log("DynaTreeStatus: read");
		// Read or init cookies.
		this.cookiesFound = false;

		var cookie = $.cookie(this.cookieId + "-active");
		this.activeKey = ( cookie === null ) ? "" : cookie;
		if( cookie !== null ){
			this.cookiesFound = true;
		}
		cookie = $.cookie(this.cookieId + "-focus");
		this.focusedKey = ( cookie === null ) ? "" : cookie;
		if( cookie !== null ){
			this.cookiesFound = true;
		}
		cookie = $.cookie(this.cookieId + "-expand");
		this.expandedKeyList = ( cookie === null ) ? [] : cookie.split(",");
		if( cookie !== null ){
			this.cookiesFound = true;
		}
		cookie = $.cookie(this.cookieId + "-select");
		this.selectedKeyList = ( cookie === null ) ? [] : cookie.split(",");
		if( cookie !== null ){
			this.cookiesFound = true;
		}
	},
	write: function() {
//		this._log("DynaTreeStatus: write");
		$.cookie(this.cookieId + "-active", ( this.activeKey === null ) ? "" : this.activeKey, this.cookieOpts);
		$.cookie(this.cookieId + "-focus", ( this.focusedKey === null ) ? "" : this.focusedKey, this.cookieOpts);
		$.cookie(this.cookieId + "-expand", ( this.expandedKeyList === null ) ? "" : this.expandedKeyList.join(","), this.cookieOpts);
		$.cookie(this.cookieId + "-select", ( this.selectedKeyList === null ) ? "" : this.selectedKeyList.join(","), this.cookieOpts);
	},
	addExpand: function(key) {
//		this._log("addExpand(%o)", key);
		if( $.inArray(key, this.expandedKeyList) < 0 ) {
			this.expandedKeyList.push(key);
			$.cookie(this.cookieId + "-expand", this.expandedKeyList.join(","), this.cookieOpts);
		}
	},
	clearExpand: function(key) {
//		this._log("clearExpand(%o)", key);
		var idx = $.inArray(key, this.expandedKeyList);
		if( idx >= 0 ) {
			this.expandedKeyList.splice(idx, 1);
			$.cookie(this.cookieId + "-expand", this.expandedKeyList.join(","), this.cookieOpts);
		}
	},
	addSelect: function(key) {
//		this._log("addSelect(%o)", key);
		if( $.inArray(key, this.selectedKeyList) < 0 ) {
			this.selectedKeyList.push(key);
			$.cookie(this.cookieId + "-select", this.selectedKeyList.join(","), this.cookieOpts);
		}
	},
	clearSelect: function(key) {
//		this._log("clearSelect(%o)", key);
		var idx = $.inArray(key, this.selectedKeyList);
		if( idx >= 0 ) {
			this.selectedKeyList.splice(idx, 1);
			$.cookie(this.cookieId + "-select", this.selectedKeyList.join(","), this.cookieOpts);
		}
	},
	isReloading: function() {
		return this.cookiesFound === true;
	},
	toDict: function() {
		return {
			cookiesFound: this.cookiesFound,
			activeKey: this.activeKey,
			focusedKey: this.activeKey,
			expandedKeyList: this.expandedKeyList,
			selectedKeyList: this.selectedKeyList
		};
	},
	// --- end of class
	lastentry: undefined
};


/*************************************************************************
 * class DynaTree
 */

var DynaTree = Class.create();

// --- Static members ----------------------------------------------------------

DynaTree.version = "$Version: 1.2.4$";

/*
DynaTree._initTree = function() {
};

DynaTree._bind = function() {
};
*/
//--- Class members ------------------------------------------------------------

DynaTree.prototype = {
	// Constructor
//	initialize: function(divContainer, options) {
	initialize: function($widget) {
		// instance members
		this.phase = "init";
		this.$widget = $widget;
		this.options = $widget.options;
		this.$tree = $widget.element;
		this.timer = null;
		// find container element
		this.divTree = this.$tree.get(0);

//		var parentPos = $(this.divTree).parent().offset();
//		this.parentTop = parentPos.top;
//		this.parentLeft = parentPos.left;

		_initDragAndDrop(this);
	},

	// member functions

	_load: function(callback) {
		var $widget = this.$widget;
		var opts = this.options,
			self = this;
		this.bEnableUpdate = true;
		this._nodeCount = 1;
		this.activeNode = null;
		this.focusNode = null;

		// Some deprecation warnings to help with migration
		if( opts.rootVisible !== undefined ){
			this.logWarning("Option 'rootVisible' is no longer supported.");
		}
		if( opts.minExpandLevel < 1 ) {
			this.logWarning("Option 'minExpandLevel' must be >= 1.");
			opts.minExpandLevel = 1;
		}
//		_log("warn", "jQuery.support.boxModel " + jQuery.support.boxModel);

		// If a 'options.classNames' dictionary was passed, still use defaults
		// for undefined classes:
		if( opts.classNames !== $.ui.dynatree.prototype.options.classNames ) {
			opts.classNames = $.extend({}, $.ui.dynatree.prototype.options.classNames, opts.classNames);
		}
		if( opts.ajaxDefaults !== $.ui.dynatree.prototype.options.ajaxDefaults ) {
			opts.ajaxDefaults = $.extend({}, $.ui.dynatree.prototype.options.ajaxDefaults, opts.ajaxDefaults);
		}
		if( opts.dnd !== $.ui.dynatree.prototype.options.dnd ) {
			opts.dnd = $.extend({}, $.ui.dynatree.prototype.options.dnd, opts.dnd);
		}
		// Guess skin path, if not specified
		if(!opts.imagePath) {
			$("script").each( function () {
				var _rexDtLibName = /.*dynatree[^\/]*\.js$/i;
				if( this.src.search(_rexDtLibName) >= 0 ) {
					if( this.src.indexOf("/")>=0 ){ // issue #47
						opts.imagePath = this.src.slice(0, this.src.lastIndexOf("/")) + "/skin/";
					}else{
						opts.imagePath = "skin/";
					}
					self.logDebug("Guessing imagePath from '%s': '%s'", this.src, opts.imagePath);
					return false; // first match
				}
			});
		}

		this.persistence = new DynaTreeStatus(opts.cookieId, opts.cookie);
		if( opts.persist ) {
			if( !$.cookie ){
				_log("warn", "Please include jquery.cookie.js to use persistence.");
			}
			this.persistence.read();
		}
		this.logDebug("DynaTree.persistence: %o", this.persistence.toDict());

		// Cached tag strings
		this.cache = {
			tagEmpty: "<span class='" + opts.classNames.empty + "'></span>",
			tagVline: "<span class='" + opts.classNames.vline + "'></span>",
			tagExpander: "<span class='" + opts.classNames.expander + "'></span>",
			tagConnector: "<span class='" + opts.classNames.connector + "'></span>",
			tagNodeIcon: "<span class='" + opts.classNames.nodeIcon + "'></span>",
			tagCheckbox: "<span class='" + opts.classNames.checkbox + "'></span>",
			lastentry: undefined
		};

		// Clear container, in case it contained some 'waiting' or 'error' text
		// for clients that don't support JS.
		// We don't do this however, if we try to load from an embedded UL element.
		if( opts.children || (opts.initAjax && opts.initAjax.url) || opts.initId ){
			$(this.divTree).empty();
		}
		var $ulInitialize = this.$tree.find(">ul:first").hide();

		// Create the root element
		this.tnRoot = new DynaTreeNode(null, this, {});
		this.tnRoot.bExpanded = true;
		this.tnRoot.render();
		this.divTree.appendChild(this.tnRoot.ul);

		var root = this.tnRoot,
			isReloading = ( opts.persist && this.persistence.isReloading() ),
			isLazy = false,
			prevFlag = this.enableUpdate(false);

		this.logDebug("Dynatree._load(): read tree structure...");

		// Init tree structure
		if( opts.children ) {
			// Read structure from node array
			root.addChild(opts.children);

		} else if( opts.initAjax && opts.initAjax.url ) {
			// Init tree from AJAX request
			isLazy = true;
			root.data.isLazy = true;
			this._reloadAjax(callback);

		} else if( opts.initId ) {
			// Init tree from another UL element
			this._createFromTag(root, $("#"+opts.initId));

		} else {
			// Init tree from the first UL element inside the container <div>
//			var $ul = this.$tree.find(">ul:first").hide();
			this._createFromTag(root, $ulInitialize);
			$ulInitialize.remove();
		}

		this._checkConsistency();
		// Fix part-sel flags
		if(!isLazy && opts.selectMode == 3){
			root._updatePartSelectionState();
		}
		// Render html markup
		this.logDebug("Dynatree._load(): render nodes...");
		this.enableUpdate(prevFlag);

		// bind event handlers
		this.logDebug("Dynatree._load(): bind events...");
		this.$widget.bind();

		// --- Post-load processing
		this.logDebug("Dynatree._load(): postInit...");
		this.phase = "postInit";

		// In persist mode, make sure that cookies are written, even if they are empty
		if( opts.persist ) {
			this.persistence.write();
		}
		// Set focus, if possible (this will also fire an event and write a cookie)
		if( this.focusNode && this.focusNode.isVisible() ) {
			this.logDebug("Focus on init: %o", this.focusNode);
			this.focusNode.focus();
		}
		if( !isLazy ) {
			if( opts.onPostInit ) {
				opts.onPostInit.call(this, isReloading, false);
			}
			if( callback ){
				callback.call(this, "ok");
			}
		}
		this.phase = "idle";
	},

	_reloadAjax: function(callback) {
		// Reload
		var opts = this.options;
		if( ! opts.initAjax || ! opts.initAjax.url ){
			throw "tree.reload() requires 'initAjax' mode.";
		}
		var pers = this.persistence;
		var ajaxOpts = $.extend({}, opts.initAjax);
		// Append cookie info to the request
//		this.logDebug("reloadAjax: key=%o, an.key:%o", pers.activeKey, this.activeNode?this.activeNode.data.key:"?");
		if( ajaxOpts.addActiveKey ){
			ajaxOpts.data.activeKey = pers.activeKey;
		}
		if( ajaxOpts.addFocusedKey ){
			ajaxOpts.data.focusedKey = pers.focusedKey;
		}
		if( ajaxOpts.addExpandedKeyList ){
			ajaxOpts.data.expandedKeyList = pers.expandedKeyList.join(",");
		}
		if( ajaxOpts.addSelectedKeyList ){
			ajaxOpts.data.selectedKeyList = pers.selectedKeyList.join(",");
		}
		// Set up onPostInit callback to be called when Ajax returns
		if( ajaxOpts.success ){
			this.logWarning("initAjax: success callback is ignored; use onPostInit instead.");
		}
		if( ajaxOpts.error ){
			this.logWarning("initAjax: error callback is ignored; use onPostInit instead.");
		}
		var isReloading = pers.isReloading();
		ajaxOpts.success = function(dtnode, data, textStatus) {
			if(opts.selectMode == 3){
				dtnode.tree.tnRoot._updatePartSelectionState();
			}
			if(opts.onPostInit){
				opts.onPostInit.call(dtnode.tree, isReloading, false);
			}
			if(callback){
				callback.call(dtnode.tree, "ok");
			}
		};
		ajaxOpts.error = function(dtnode, XMLHttpRequest, textStatus, errorThrown) {
			if(opts.onPostInit){
				opts.onPostInit.call(dtnode.tree, isReloading, true, XMLHttpRequest, textStatus, errorThrown);
			}
			if(callback){
				callback.call(dtnode.tree, "error", XMLHttpRequest, textStatus, errorThrown);
			}
		};
//		}
		this.logDebug("Dynatree._init(): send Ajax request...");
		this.tnRoot.appendAjax(ajaxOpts);
	},

	toString: function() {
//		return "DynaTree '" + this.options.title + "'";
		return "Dynatree '" + this.$tree.attr("id") + "'";
	},

	toDict: function() {
		return this.tnRoot.toDict(true);
	},

	serializeArray: function(stopOnParents) {
		// Return a JavaScript array of objects, ready to be encoded as a JSON
		// string for selected nodes
		var nodeList = this.getSelectedNodes(stopOnParents),
			name = this.$tree.attr("name") || this.$tree.attr("id"),
			arr = [];
		for(var i=0, l=nodeList.length; i<l; i++){
			arr.push({name: name, value: nodeList[i].data.key});
		}
		return arr;
	},

	getPersistData: function() {
		return this.persistence.toDict();
	},

	logDebug: function(msg) {
		if( this.options.debugLevel >= 2 ) {
			Array.prototype.unshift.apply(arguments, ["debug"]);
			_log.apply(this, arguments);
		}
	},

	logInfo: function(msg) {
		if( this.options.debugLevel >= 1 ) {
			Array.prototype.unshift.apply(arguments, ["info"]);
			_log.apply(this, arguments);
		}
	},

	logWarning: function(msg) {
		Array.prototype.unshift.apply(arguments, ["warn"]);
		_log.apply(this, arguments);
	},

	isInitializing: function() {
		return ( this.phase=="init" || this.phase=="postInit" );
	},
	isReloading: function() {
		return ( this.phase=="init" || this.phase=="postInit" ) && this.options.persist && this.persistence.cookiesFound;
	},
	isUserEvent: function() {
		return ( this.phase=="userEvent" );
	},

	redraw: function() {
//		this.logDebug("dynatree.redraw()...");
		this.tnRoot.render(false, false);
//		this.logDebug("dynatree.redraw() done.");
	},
	renderInvisibleNodes: function() {
		this.tnRoot.render(false, true);
	},
	reload: function(callback) {
		this._load(callback);
	},

	getRoot: function() {
		return this.tnRoot;
	},

	enable: function() {
		this.$widget.enable();
	},

	disable: function() {
		this.$widget.disable();
	},

	getNodeByKey: function(key) {
		// Search the DOM by element ID (assuming this is faster than traversing all nodes).
		// $("#...") has problems, if the key contains '.', so we use getElementById()
		var el = document.getElementById(this.options.idPrefix + key);
		if( el ){
			return el.dtnode ? el.dtnode : null;
		}
		// Not found in the DOM, but still may be in an unrendered part of tree
		var match = null;
		this.visit(function(node){
//			window.console.log("%s", node);
			if(node.data.key === key) {
				match = node;
				return false;
			}
		}, true);
		return match;
	},

	getActiveNode: function() {
		return this.activeNode;
	},

	reactivate: function(setFocus) {
		// Re-fire onQueryActivate and onActivate events.
		var node = this.activeNode;
//		this.logDebug("reactivate %o", node);
		if( node ) {
			this.activeNode = null; // Force re-activating
			node.activate();
			if( setFocus ){
				node.focus();
			}
		}
	},

	getSelectedNodes: function(stopOnParents) {
		var nodeList = [];
		this.tnRoot.visit(function(node){
			if( node.bSelected ) {
				nodeList.push(node);
				if( stopOnParents === true ){
					return "skip"; // stop processing this branch
				}
			}
		});
		return nodeList;
	},

	activateKey: function(key) {
		var dtnode = (key === null) ? null : this.getNodeByKey(key);
		if( !dtnode ) {
			if( this.activeNode ){
				this.activeNode.deactivate();
			}
			this.activeNode = null;
			return null;
		}
		dtnode.focus();
		dtnode.activate();
		return dtnode;
	},

	loadKeyPath: function(keyPath, callback) {
		var segList = keyPath.split(this.options.keyPathSeparator);
		// Remove leading '/'
		if(segList[0] === ""){
			segList.shift();
		}
		// Remove leading system root key
		if(segList[0] == this.tnRoot.data.key){
			this.logDebug("Removed leading root key.");
			segList.shift();
		}
		keyPath = segList.join(this.options.keyPathSeparator);
		return this.tnRoot._loadKeyPath(keyPath, callback);
	},

	selectKey: function(key, select) {
		var dtnode = this.getNodeByKey(key);
		if( !dtnode ){
			return null;
		}
		dtnode.select(select);
		return dtnode;
	},

	enableUpdate: function(bEnable) {
		if ( this.bEnableUpdate==bEnable ){
			return bEnable;
		}
		this.bEnableUpdate = bEnable;
		if ( bEnable ){
			this.redraw();
		}
		return !bEnable; // return previous value
	},

	count: function() {
		return this.tnRoot.countChildren();
	},

	visit: function(fn, includeRoot) {
		return this.tnRoot.visit(fn, includeRoot);
	},

	_createFromTag: function(parentTreeNode, $ulParent) {
		// Convert a <UL>...</UL> list into children of the parent tree node.
		var self = this;
/*
TODO: better?
		this.$lis = $("li:has(a[href])", this.element);
		this.$tabs = this.$lis.map(function() { return $("a", this)[0]; });
 */
		$ulParent.find(">li").each(function() {
			var $li = $(this),
				$liSpan = $li.find(">span:first"),
				$liA = $li.find(">a:first"),
				title,
				href = null,
				target = null,
				tooltip;
			if( $liSpan.length ) {
				// If a <li><span> tag is specified, use it literally.
				title = $liSpan.html();
			} else if( $liA.length ) {
				title = $liA.html();
				href = $liA.attr("href");
				target = $liA.attr("target");
				tooltip = $liA.attr("title");
			} else {
				// If only a <li> tag is specified, use the trimmed string up to
				// the next child <ul> tag.
				title = $li.html();
				var iPos = title.search(/<ul/i);
				if( iPos >= 0 ){
					title = $.trim(title.substring(0, iPos));
				}else{
					title = $.trim(title);
				}
//				self.logDebug("%o", title);
			}
			// Parse node options from ID, title and class attributes
			var data = {
				title: title,
				tooltip: tooltip,
				isFolder: $li.hasClass("folder"),
				isLazy: $li.hasClass("lazy"),
				expand: $li.hasClass("expanded"),
				select: $li.hasClass("selected"),
				activate: $li.hasClass("active"),
				focus: $li.hasClass("focused"),
				noLink: $li.hasClass("noLink")
			};
			if( href ){
				data.href = href;
				data.target = target;
			}
			if( $li.attr("title") ){
				data.tooltip = $li.attr("title"); // overrides <a title='...'>
			}
			if( $li.attr("id") ){
				data.key = "" + $li.attr("id");
			}
			// If a data attribute is present, evaluate as a JavaScript object
			if( $li.attr("data") ) {
				var dataAttr = $.trim($li.attr("data"));
				if( dataAttr ) {
					if( dataAttr.charAt(0) != "{" ){
						dataAttr = "{" + dataAttr + "}";
					}
					try {
						$.extend(data, eval("(" + dataAttr + ")"));
					} catch(e) {
						throw ("Error parsing node data: " + e + "\ndata:\n'" + dataAttr + "'");
					}
				}
			}
			var childNode = parentTreeNode.addChild(data);
			// Recursive reading of child nodes, if LI tag contains an UL tag
			var $ul = $li.find(">ul:first");
			if( $ul.length ) {
				self._createFromTag(childNode, $ul); // must use 'self', because 'this' is the each() context
			}
		});
	},

	_checkConsistency: function() {
//		this.logDebug("tree._checkConsistency() NOT IMPLEMENTED - %o", this);
	},

	_setDndStatus: function(sourceNode, targetNode, helper, hitMode, accept) {
		// hitMode: 'after', 'before', 'over', 'out', 'start', 'stop'
		var $source = sourceNode ? $(sourceNode.span) : null,
			$target = $(targetNode.span);
		if( !this.$dndMarker ) {
			this.$dndMarker = $("<div id='dynatree-drop-marker'></div>")
				.hide()
				.css({"z-index": 1000})
				.prependTo($(this.divTree).parent());

//			logMsg("Creating marker: %o", this.$dndMarker);
		}
/*
		if(hitMode === "start"){
		}
		if(hitMode === "stop"){
//			sourceNode.removeClass("dynatree-drop-target");
		}
*/
		if(hitMode === "after" || hitMode === "before" || hitMode === "over"){
//			$source && $source.addClass("dynatree-drag-source");
//			$target.addClass("dynatree-drop-target");

			var markerOffset = "0 0";

			switch(hitMode){
			case "before":
				this.$dndMarker.removeClass("dynatree-drop-after dynatree-drop-over");
				this.$dndMarker.addClass("dynatree-drop-before");
				markerOffset = "0 -8";
				break;
			case "after":
				this.$dndMarker.removeClass("dynatree-drop-before dynatree-drop-over");
				this.$dndMarker.addClass("dynatree-drop-after");
				markerOffset = "0 8";
				break;
			default:
				this.$dndMarker.removeClass("dynatree-drop-after dynatree-drop-before");
				this.$dndMarker.addClass("dynatree-drop-over");
				$target.addClass("dynatree-drop-target");
				markerOffset = "8 0";
			}
//			logMsg("Creating marker: %o", this.$dndMarker);
//			logMsg("    $target.offset=%o", $target);
//			logMsg("    pos/$target.offset=%o", pos);
//			logMsg("    $target.position=%o", $target.position());
//			logMsg("    $target.offsetParent=%o, ot:%o", $target.offsetParent(), $target.offsetParent().offset());
//			logMsg("    $(this.divTree).offset=%o", $(this.divTree).offset());
//			logMsg("    $(this.divTree).parent=%o", $(this.divTree).parent());
//			var pos = $target.offset();
//			var parentPos = $target.offsetParent().offset();
//			var bodyPos = $target.offsetParent().offset();

			this.$dndMarker
				.show()
				.position({
					my: "left top",
					at: "left top",
					of: $target,
					offset: markerOffset
				});

//			helper.addClass("dynatree-drop-hover");
		} else {
//			$source && $source.removeClass("dynatree-drag-source");
			$target.removeClass("dynatree-drop-target");
			this.$dndMarker.hide();
//			helper.removeClass("dynatree-drop-hover");
		}
		if(hitMode === "after"){
			$target.addClass("dynatree-drop-after");
		} else {
			$target.removeClass("dynatree-drop-after");
		}
		if(hitMode === "before"){
			$target.addClass("dynatree-drop-before");
		} else {
			$target.removeClass("dynatree-drop-before");
		}
		if(accept === true){
			if($source){
				$source.addClass("dynatree-drop-accept");
			}
			$target.addClass("dynatree-drop-accept");
			helper.addClass("dynatree-drop-accept");
		}else{
			if($source){
				$source.removeClass("dynatree-drop-accept");
			}
			$target.removeClass("dynatree-drop-accept");
			helper.removeClass("dynatree-drop-accept");
		}
		if(accept === false){
			if($source){
				$source.addClass("dynatree-drop-reject");
			}
			$target.addClass("dynatree-drop-reject");
			helper.addClass("dynatree-drop-reject");
		}else{
			if($source){
				$source.removeClass("dynatree-drop-reject");
			}
			$target.removeClass("dynatree-drop-reject");
			helper.removeClass("dynatree-drop-reject");
		}
	},

	_onDragEvent: function(eventName, node, otherNode, event, ui, draggable) {
		/**
		 * Handles drag'n'drop functionality.
		 *
		 * A standard jQuery drag-and-drop process may generate these calls:
		 *
		 * draggable helper():
		 *     _onDragEvent("helper", sourceNode, null, event, null, null);
		 * start:
		 *     _onDragEvent("start", sourceNode, null, event, ui, draggable);
		 * drag:
		 *     _onDragEvent("leave", prevTargetNode, sourceNode, event, ui, draggable);
		 *     _onDragEvent("over", targetNode, sourceNode, event, ui, draggable);
		 *     _onDragEvent("enter", targetNode, sourceNode, event, ui, draggable);
		 * stop:
		 *     _onDragEvent("drop", targetNode, sourceNode, event, ui, draggable);
		 *     _onDragEvent("leave", targetNode, sourceNode, event, ui, draggable);
		 *     _onDragEvent("stop", sourceNode, null, event, ui, draggable);
		 */
//		if(eventName !== "over"){
//			this.logDebug("tree._onDragEvent(%s, %o, %o) - %o", eventName, node, otherNode, this);
//		}
		var opts = this.options,
			dnd = this.options.dnd,
			res = null,
			nodeTag = $(node.span),
			hitMode,
			enterResponse;

		switch (eventName) {
		case "helper":
			// Only event and node argument is available
			var $helper = $("<div class='dynatree-drag-helper'><span class='dynatree-drag-helper-img' /></div>")
				.append($(event.target).closest(".dynatree-title").clone());
//			    .append($(event.target).closest('a').clone());
			// issue 244: helper should be child of scrollParent
			$("ul.dynatree-container", node.tree.divTree).append($helper);
//			$(node.tree.divTree).append($helper);
			// Attach node reference to helper object
			$helper.data("dtSourceNode", node);
//			this.logDebug("helper=%o", $helper);
//			this.logDebug("helper.sourceNode=%o", $helper.data("dtSourceNode"));
			res = $helper;
			break;
		case "start":
			if(node.isStatusNode()) {
				res = false;
			} else if(dnd.onDragStart) {
				res = dnd.onDragStart(node);
			}
			if(res === false) {
				this.logDebug("tree.onDragStart() cancelled");
				//draggable._clear();
				// NOTE: the return value seems to be ignored (drag is not canceled, when false is returned)
				ui.helper.trigger("mouseup");
				ui.helper.hide();
			} else {
				nodeTag.addClass("dynatree-drag-source");
			}
			break;
		case "enter":
			res = dnd.onDragEnter ? dnd.onDragEnter(node, otherNode) : null;
			if(!res){
				// convert null, undefined, false to false
				res = false;
			}else{
				res = {
					over: ((res === true) || (res === "over") || $.inArray("over", res) >= 0),
					before: ((res === true) || (res === "before") || $.inArray("before", res) >= 0),
					after: ((res === true) || (res === "after") || $.inArray("after", res) >= 0)
				};
			}
			ui.helper.data("enterResponse", res);
//			this.logDebug("helper.enterResponse: %o", res);
			break;
		case "over":
			enterResponse = ui.helper.data("enterResponse");
			hitMode = null;
			if(enterResponse === false){
				// Don't call onDragOver if onEnter returned false.
				// issue 332
//				break;
			} else if(typeof enterResponse === "string") {
				// Use hitMode from onEnter if provided.
				hitMode = enterResponse;
			} else {
				// Calculate hitMode from relative cursor position.
				var nodeOfs = nodeTag.offset();
//				var relPos = { x: event.clientX - nodeOfs.left,
//							y: event.clientY - nodeOfs.top };
//				nodeOfs.top += this.parentTop;
//				nodeOfs.left += this.parentLeft;
				var relPos = { x: event.pageX - nodeOfs.left,
							   y: event.pageY - nodeOfs.top };
				var relPos2 = { x: relPos.x / nodeTag.width(),
								y: relPos.y / nodeTag.height() };
//				this.logDebug("event.page: %s/%s", event.pageX, event.pageY);
//				this.logDebug("event.client: %s/%s", event.clientX, event.clientY);
//				this.logDebug("nodeOfs: %s/%s", nodeOfs.left, nodeOfs.top);
////				this.logDebug("parent: %s/%s", this.parentLeft, this.parentTop);
//				this.logDebug("relPos: %s/%s", relPos.x, relPos.y);
//				this.logDebug("relPos2: %s/%s", relPos2.x, relPos2.y);
				if( enterResponse.after && relPos2.y > 0.75 ){
					hitMode = "after";
				} else if(!enterResponse.over && enterResponse.after && relPos2.y > 0.5 ){
					hitMode = "after";
				} else if(enterResponse.before && relPos2.y <= 0.25) {
					hitMode = "before";
				} else if(!enterResponse.over && enterResponse.before && relPos2.y <= 0.5) {
					hitMode = "before";
				} else if(enterResponse.over) {
					hitMode = "over";
				}
				// Prevent no-ops like 'before source node'
				// TODO: these are no-ops when moving nodes, but not in copy mode
				if( dnd.preventVoidMoves ){
					if(node === otherNode){
//						this.logDebug("    drop over source node prevented");
						hitMode = null;
					}else if(hitMode === "before" && otherNode && node === otherNode.getNextSibling()){
//						this.logDebug("    drop after source node prevented");
						hitMode = null;
					}else if(hitMode === "after" && otherNode && node === otherNode.getPrevSibling()){
//						this.logDebug("    drop before source node prevented");
						hitMode = null;
					}else if(hitMode === "over" && otherNode
							&& otherNode.parent === node && otherNode.isLastSibling() ){
//						this.logDebug("    drop last child over own parent prevented");
						hitMode = null;
					}
				}
//				this.logDebug("hitMode: %s - %s - %s", hitMode, (node.parent === otherNode), node.isLastSibling());
				ui.helper.data("hitMode", hitMode);
			}
			// Auto-expand node (only when 'over' the node, not 'before', or 'after')
			if(hitMode === "over"
				&& dnd.autoExpandMS && node.hasChildren() !== false && !node.bExpanded) {
				node.scheduleAction("expand", dnd.autoExpandMS);
			}
			if(hitMode && dnd.onDragOver){
				res = dnd.onDragOver(node, otherNode, hitMode);
				if(res === "over" || res === "before" || res === "after") {
					hitMode = res;
				}
			}
			// issue 332
//			this._setDndStatus(otherNode, node, ui.helper, hitMode, res!==false);
			this._setDndStatus(otherNode, node, ui.helper, hitMode, res!==false && hitMode !== null);
			break;
		case "drop":
			// issue 286: don't trigger onDrop, if DnD status is 'reject'
			var isForbidden = ui.helper.hasClass("dynatree-drop-reject");
			hitMode = ui.helper.data("hitMode");
			if(hitMode && dnd.onDrop && !isForbidden){
				dnd.onDrop(node, otherNode, hitMode, ui, draggable);
			}
			break;
		case "leave":
			// Cancel pending expand request
			node.scheduleAction("cancel");
			ui.helper.data("enterResponse", null);
			ui.helper.data("hitMode", null);
			this._setDndStatus(otherNode, node, ui.helper, "out", undefined);
			if(dnd.onDragLeave){
				dnd.onDragLeave(node, otherNode);
			}
			break;
		case "stop":
			nodeTag.removeClass("dynatree-drag-source");
			if(dnd.onDragStop){
				dnd.onDragStop(node);
			}
			break;
		default:
			throw "Unsupported drag event: " + eventName;
		}
		return res;
	},

	cancelDrag: function() {
		 var dd = $.ui.ddmanager.current;
		 if(dd){
			 dd.cancel();
		 }
	},

	// --- end of class
	lastentry: undefined
};

/*************************************************************************
 * Widget $(..).dynatree
 */

$.widget("ui.dynatree", {
/*
	init: function() {
		// ui.core 1.6 renamed init() to _init(): this stub assures backward compatibility
		_log("warn", "ui.dynatree.init() was called; you should upgrade to jquery.ui.core.js v1.8 or higher.");
		return this._init();
	},
 */
	_init: function() {
//		if( parseFloat($.ui.version) < 1.8 ) {
		if(versionCompare($.ui.version, "1.8") < 0){
			// jquery.ui.core 1.8 renamed _init() to _create(): this stub assures backward compatibility
			if(this.options.debugLevel >= 0){
				_log("warn", "ui.dynatree._init() was called; you should upgrade to jquery.ui.core.js v1.8 or higher.");
			}
			return this._create();
		}
		// jquery.ui.core 1.8 still uses _init() to perform "default functionality"
		if(this.options.debugLevel >= 2){
			_log("debug", "ui.dynatree._init() was called; no current default functionality.");
		}
	},

	_create: function() {
		var opts = this.options;
		if(opts.debugLevel >= 1){
			logMsg("Dynatree._create(): version='%s', debugLevel=%o.", $.ui.dynatree.version, this.options.debugLevel);
		}
		// The widget framework supplies this.element and this.options.
		this.options.event += ".dynatree"; // namespace event

		var divTree = this.element.get(0);
/*		// Clear container, in case it contained some 'waiting' or 'error' text
		// for clients that don't support JS
		if( opts.children || (opts.initAjax && opts.initAjax.url) || opts.initId )
			$(divTree).empty();
*/
		// Create the DynaTree object
		this.tree = new DynaTree(this);
		this.tree._load();
		this.tree.logDebug("Dynatree._init(): done.");
	},

	bind: function() {
		// Prevent duplicate binding
		this.unbind();

		var eventNames = "click.dynatree dblclick.dynatree";
		if( this.options.keyboard ){
			// Note: leading ' '!
			eventNames += " keypress.dynatree keydown.dynatree";
		}
		this.element.bind(eventNames, function(event){
			var dtnode = $.ui.dynatree.getNode(event.target);
			if( !dtnode ){
				return true;  // Allow bubbling of other events
			}
			var tree = dtnode.tree;
			var o = tree.options;
			tree.logDebug("event(%s): dtnode: %s", event.type, dtnode);
			var prevPhase = tree.phase;
			tree.phase = "userEvent";
			try {
				switch(event.type) {
				case "click":
					return ( o.onClick && o.onClick.call(tree, dtnode, event)===false ) ? false : dtnode._onClick(event);
				case "dblclick":
					return ( o.onDblClick && o.onDblClick.call(tree, dtnode, event)===false ) ? false : dtnode._onDblClick(event);
				case "keydown":
					return ( o.onKeydown && o.onKeydown.call(tree, dtnode, event)===false ) ? false : dtnode._onKeydown(event);
				case "keypress":
					return ( o.onKeypress && o.onKeypress.call(tree, dtnode, event)===false ) ? false : dtnode._onKeypress(event);
				}
			} catch(e) {
				var _ = null; // issue 117
				tree.logWarning("bind(%o): dtnode: %o, error: %o", event, dtnode, e);
			} finally {
				tree.phase = prevPhase;
			}
		});

		// focus/blur don't bubble, i.e. are not delegated to parent <div> tags,
		// so we use the addEventListener capturing phase.
		// See http://www.howtocreate.co.uk/tutorials/javascript/domevents
		function __focusHandler(event) {
			// Handles blur and focus.
			// Fix event for IE:
			// doesn't pass JSLint:
//			event = arguments[0] = $.event.fix( event || window.event );
			// what jQuery does:
//			var args = jQuery.makeArray( arguments );
//			event = args[0] = jQuery.event.fix( event || window.event );
			event = $.event.fix( event || window.event );
			var dtnode = $.ui.dynatree.getNode(event.target);
			return dtnode ? dtnode._onFocus(event) : false;
		}
		var div = this.tree.divTree;

		if( div.addEventListener ) {
			div.addEventListener("focus", __focusHandler, true);
			div.addEventListener("blur", __focusHandler, true);
		} else {
			div.onfocusin = div.onfocusout = __focusHandler;
		}
		// EVENTS
		// disable click if event is configured to something else
//		if (!(/^click/).test(o.event))
//			this.$tabs.bind("click.tabs", function() { return false; });

	},

	unbind: function() {
		this.element.unbind(".dynatree");
	},

/* TODO: we could handle option changes during runtime here (maybe to re-render, ...)
	setData: function(key, value) {
		this.tree.logDebug("dynatree.setData('" + key + "', '" + value + "')");
	},
*/
	enable: function() {
		this.bind();
		// Call default disable(): remove -disabled from css:
		$.Widget.prototype.enable.apply(this, arguments);
	},

	disable: function() {
		this.unbind();
		// Call default disable(): add -disabled to css:
		$.Widget.prototype.disable.apply(this, arguments);
	},

	// --- getter methods (i.e. NOT returning a reference to $)
	getTree: function() {
		return this.tree;
	},

	getRoot: function() {
		return this.tree.getRoot();
	},

	getActiveNode: function() {
		return this.tree.getActiveNode();
	},

	getSelectedNodes: function() {
		return this.tree.getSelectedNodes();
	},

	// ------------------------------------------------------------------------
	lastentry: undefined
});


// The following methods return a value (thus breaking the jQuery call chain):
if(versionCompare($.ui.version, "1.8") < 0){
//if( parseFloat($.ui.version) < 1.8 ) {
	$.ui.dynatree.getter = "getTree getRoot getActiveNode getSelectedNodes";
}

/*******************************************************************************
 * Tools in ui.dynatree namespace
 */
$.ui.dynatree.version = "$Version: 1.2.4$";

/**
 * Return a DynaTreeNode object for a given DOM element
 */
$.ui.dynatree.getNode = function(el) {
	if(el instanceof DynaTreeNode){
		return el; // el already was a DynaTreeNode
	}
	if(el.selector !== undefined){
		el = el[0]; // el was a jQuery object: use the DOM element
	}
	// TODO: for some reason $el.parents("[dtnode]") does not work (jQuery 1.6.1)
	// maybe, because dtnode is a property, not an attribute
	while( el ) {
		if(el.dtnode) {
			return el.dtnode;
		}
		el = el.parentNode;
	}
	return null;
/*
	var $el = el.selector === undefined ? $(el) : el,
//		parent = $el.closest("[dtnode]"),
//		parent = $el.parents("[dtnode]").first(),
		useProp = (typeof $el.prop == "function"),
		node;
	$el.parents().each(function(){
		node = useProp ? $(this).prop("dtnode") : $(this).attr("dtnode");
		if(node){
			return false;
		}
	});
	return node;
*/
};

/**Return persistence information from cookies.*/
$.ui.dynatree.getPersistData = DynaTreeStatus._getTreePersistData;

/*******************************************************************************
 * Plugin default options:
 */
$.ui.dynatree.prototype.options = {
	title: "Dynatree", // Tree's name (only used for debug output)
	minExpandLevel: 1, // 1: root node is not collapsible
	imagePath: null, // Path to a folder containing icons. Defaults to 'skin/' subdirectory.
	children: null, // Init tree structure from this object array.
	initId: null, // Init tree structure from a <ul> element with this ID.
	initAjax: null, // Ajax options used to initialize the tree strucuture.
	autoFocus: true, // Set focus to first child, when expanding or lazy-loading.
	keyboard: true, // Support keyboard navigation.
	persist: false, // Persist expand-status to a cookie
	autoCollapse: false, // Automatically collapse all siblings, when a node is expanded.
	clickFolderMode: 3, // 1:activate, 2:expand, 3:activate and expand
	activeVisible: true, // Make sure, active nodes are visible (expanded).
	checkbox: false, // Show checkboxes.
	selectMode: 2, // 1:single, 2:multi, 3:multi-hier
	fx: null, // Animations, e.g. null or { height: "toggle", duration: 200 }
	noLink: false, // Use <span> instead of <a> tags for all nodes
	// Low level event handlers: onEvent(dtnode, event): return false, to stop default processing
	onClick: null, // null: generate focus, expand, activate, select events.
	onDblClick: null, // (No default actions.)
	onKeydown: null, // null: generate keyboard navigation (focus, expand, activate).
	onKeypress: null, // (No default actions.)
	onFocus: null, // null: set focus to node.
	onBlur: null, // null: remove focus from node.

	// Pre-event handlers onQueryEvent(flag, dtnode): return false, to stop processing
	onQueryActivate: null, // Callback(flag, dtnode) before a node is (de)activated.
	onQuerySelect: null, // Callback(flag, dtnode) before a node is (de)selected.
	onQueryExpand: null, // Callback(flag, dtnode) before a node is expanded/collpsed.

	// High level event handlers
	onPostInit: null, // Callback(isReloading, isError) when tree was (re)loaded.
	onActivate: null, // Callback(dtnode) when a node is activated.
	onDeactivate: null, // Callback(dtnode) when a node is deactivated.
	onSelect: null, // Callback(flag, dtnode) when a node is (de)selected.
	onExpand: null, // Callback(flag, dtnode) when a node is expanded/collapsed.
	onLazyRead: null, // Callback(dtnode) when a lazy node is expanded for the first time.
	onCustomRender: null, // Callback(dtnode) before a node is rendered. Return a HTML string to override.
	onCreate: null, // Callback(dtnode, nodeSpan) after a node was rendered for the first time.
	onRender: null, // Callback(dtnode, nodeSpan) after a node was rendered.
				// postProcess is similar to the standard dataFilter hook,
				// but it is also called for JSONP
	postProcess: null, // Callback(data, dataType) before an Ajax result is passed to dynatree

	// Drag'n'drop support
	dnd: {
		// Make tree nodes draggable:
		onDragStart: null, // Callback(sourceNode), return true, to enable dnd
		onDragStop: null, // Callback(sourceNode)
//		helper: null,
		// Make tree nodes accept draggables
		autoExpandMS: 1000, // Expand nodes after n milliseconds of hovering.
		preventVoidMoves: true, // Prevent dropping nodes 'before self', etc.
		onDragEnter: null, // Callback(targetNode, sourceNode)
		onDragOver: null, // Callback(targetNode, sourceNode, hitMode)
		onDrop: null, // Callback(targetNode, sourceNode, hitMode)
		onDragLeave: null // Callback(targetNode, sourceNode)
	},
	ajaxDefaults: { // Used by initAjax option
		cache: false, // false: Append random '_' argument to the request url to prevent caching.
		timeout: 0, // >0: Make sure we get an ajax error for invalid URLs
		dataType: "json" // Expect json format and pass json object to callbacks.
	},
	strings: {
		loading: "Loading&#8230;",
		loadError: "Load error!"
	},
	generateIds: false, // Generate id attributes like <span id='dynatree-id-KEY'>
	idPrefix: "dynatree-id-", // Used to generate node id's like <span id="dynatree-id-<key>">.
	keyPathSeparator: "/", // Used by node.getKeyPath() and tree.loadKeyPath().
//    cookieId: "dynatree-cookie", // Choose a more unique name, to allow multiple trees.
	cookieId: "dynatree", // Choose a more unique name, to allow multiple trees.
	cookie: {
		expires: null //7, // Days or Date; null: session cookie
//		path: "/", // Defaults to current page
//		domain: "jquery.com",
//		secure: true
	},
	// Class names used, when rendering the HTML markup.
	// Note: if only single entries are passed for options.classNames, all other
	// values are still set to default.
	classNames: {
		container: "dynatree-container",
		node: "dynatree-node",
		folder: "dynatree-folder",
//		document: "dynatree-document",

		empty: "dynatree-empty",
		vline: "dynatree-vline",
		expander: "dynatree-expander",
		connector: "dynatree-connector",
		checkbox: "dynatree-checkbox",
		nodeIcon: "dynatree-icon",
		title: "dynatree-title",
		noConnector: "dynatree-no-connector",

		nodeError: "dynatree-statusnode-error",
		nodeWait: "dynatree-statusnode-wait",
		hidden: "dynatree-hidden",
		combinedExpanderPrefix: "dynatree-exp-",
		combinedIconPrefix: "dynatree-ico-",
		nodeLoading: "dynatree-loading",
//		disabled: "dynatree-disabled",
		hasChildren: "dynatree-has-children",
		active: "dynatree-active",
		selected: "dynatree-selected",
		expanded: "dynatree-expanded",
		lazy: "dynatree-lazy",
		focused: "dynatree-focused",
		partsel: "dynatree-partsel",
		lastsib: "dynatree-lastsib"
	},
	debugLevel: 1,

	// ------------------------------------------------------------------------
	lastentry: undefined
};
//
if(versionCompare($.ui.version, "1.8") < 0){
//if( parseFloat($.ui.version) < 1.8 ) {
	$.ui.dynatree.defaults = $.ui.dynatree.prototype.options;
}

/*******************************************************************************
 * Reserved data attributes for a tree node.
 */
$.ui.dynatree.nodedatadefaults = {
	title: null, // (required) Displayed name of the node (html is allowed here)
	key: null, // May be used with activate(), select(), find(), ...
	isFolder: false, // Use a folder icon. Also the node is expandable but not selectable.
	isLazy: false, // Call onLazyRead(), when the node is expanded for the first time to allow for delayed creation of children.
	tooltip: null, // Show this popup text.
	href: null, // Added to the generated <a> tag.
	icon: null, // Use a custom image (filename relative to tree.options.imagePath). 'null' for default icon, 'false' for no icon.
	addClass: null, // Class name added to the node's span tag.
	noLink: false, // Use <span> instead of <a> tag for this node
	activate: false, // Initial active status.
	focus: false, // Initial focused status.
	expand: false, // Initial expanded status.
	select: false, // Initial selected status.
	hideCheckbox: false, // Suppress checkbox display for this node.
	unselectable: false, // Prevent selection.
//  disabled: false,
	// The following attributes are only valid if passed to some functions:
	children: null, // Array of child nodes.
	// NOTE: we can also add custom attributes here.
	// This may then also be used in the onActivate(), onSelect() or onLazyTree() callbacks.
	// ------------------------------------------------------------------------
	lastentry: undefined
};

/*******************************************************************************
 * Drag and drop support
 */
function _initDragAndDrop(tree) {
	var dnd = tree.options.dnd || null;
	// Register 'connectToDynatree' option with ui.draggable
	if(dnd && (dnd.onDragStart || dnd.onDrop)) {
		_registerDnd();
	}
	// Attach ui.draggable to this Dynatree instance
	if(dnd && dnd.onDragStart ) {
		tree.$tree.draggable({
			addClasses: false,
			appendTo: "body",
			containment: false,
			delay: 0,
			distance: 4,
			revert: false,
			scroll: true, // issue 244: enable scrolling (if ul.dynatree-container)
			scrollSpeed: 7,
			scrollSensitivity: 10,
			// Delegate draggable.start, drag, and stop events to our handler
			connectToDynatree: true,
			// Let source tree create the helper element
			helper: function(event) {
				var sourceNode = $.ui.dynatree.getNode(event.target);
				if(!sourceNode){ // issue 211
					return "<div></div>";
				}
				return sourceNode.tree._onDragEvent("helper", sourceNode, null, event, null, null);
			},
			start: function(event, ui) {
				// See issues 211, 268, 278
//				var sourceNode = $.ui.dynatree.getNode(event.target);
				var sourceNode = ui.helper.data("dtSourceNode");
				return !!sourceNode; // Abort dragging if no Node could be found
			},
			_last: null
		});
	}
	// Attach ui.droppable to this Dynatree instance
	if(dnd && dnd.onDrop) {
		tree.$tree.droppable({
			addClasses: false,
			tolerance: "intersect",
			greedy: false,
			_last: null
		});
	}
}

//--- Extend ui.draggable event handling --------------------------------------
var didRegisterDnd = false;
var _registerDnd = function() {
	if(didRegisterDnd){
		return;
	}
	// Register proxy-functions for draggable.start/drag/stop
	$.ui.plugin.add("draggable", "connectToDynatree", {
		start: function(event, ui) {
			// issue 386
			var draggable = $(this).data("ui-draggable") || $(this).data("draggable"),
				sourceNode = ui.helper.data("dtSourceNode") || null;
//			logMsg("draggable-connectToDynatree.start, %s", sourceNode);
//			logMsg("    this: %o", this);
//			logMsg("    event: %o", event);
//			logMsg("    draggable: %o", draggable);
//			logMsg("    ui: %o", ui);

			if(sourceNode) {
				// Adjust helper offset, so cursor is slightly outside top/left corner
//				draggable.offset.click.top -= event.target.offsetTop;
//				draggable.offset.click.left -= event.target.offsetLeft;
				draggable.offset.click.top = -2;
				draggable.offset.click.left = + 16;
//				logMsg("    draggable2: %o", draggable);
//				logMsg("    draggable.offset.click FIXED: %s/%s", draggable.offset.click.left, draggable.offset.click.top);
				// Trigger onDragStart event
				// TODO: when called as connectTo..., the return value is ignored(?)
				return sourceNode.tree._onDragEvent("start", sourceNode, null, event, ui, draggable);
			}
		},
		drag: function(event, ui) {
			// issue 386
			var draggable = $(this).data("ui-draggable") || $(this).data("draggable"),
				sourceNode = ui.helper.data("dtSourceNode") || null,
				prevTargetNode = ui.helper.data("dtTargetNode") || null,
				targetNode = $.ui.dynatree.getNode(event.target);
//			logMsg("$.ui.dynatree.getNode(%o): %s", event.target, targetNode);
//			logMsg("connectToDynatree.drag: helper: %o", ui.helper[0]);
			if(event.target && !targetNode){
				// We got a drag event, but the targetNode could not be found
				// at the event location. This may happen,
				// 1. if the mouse jumped over the drag helper,
				// 2. or if non-dynatree element is dragged
				// We ignore it:
				var isHelper = $(event.target).closest("div.dynatree-drag-helper,#dynatree-drop-marker").length > 0;
				if(isHelper){
//					logMsg("Drag event over helper: ignored.");
					return;
				}
			}
//			logMsg("draggable-connectToDynatree.drag: targetNode(from event): %s, dtTargetNode: %s", targetNode, ui.helper.data("dtTargetNode"));
			ui.helper.data("dtTargetNode", targetNode);
			// Leaving a tree node
			if(prevTargetNode && prevTargetNode !== targetNode ) {
				prevTargetNode.tree._onDragEvent("leave", prevTargetNode, sourceNode, event, ui, draggable);
			}
			if(targetNode){
				if(!targetNode.tree.options.dnd.onDrop) {
					// not enabled as drop target
//					noop(); // Keep JSLint happy
				} else if(targetNode === prevTargetNode) {
					// Moving over same node
					targetNode.tree._onDragEvent("over", targetNode, sourceNode, event, ui, draggable);
				}else{
					// Entering this node first time
					targetNode.tree._onDragEvent("enter", targetNode, sourceNode, event, ui, draggable);
				}
			}
			// else go ahead with standard event handling
		},
		stop: function(event, ui) {
			// issue 386
			var draggable = $(this).data("ui-draggable") || $(this).data("draggable"),
				sourceNode = ui.helper.data("dtSourceNode") || null,
				targetNode = ui.helper.data("dtTargetNode") || null,
				mouseDownEvent = draggable._mouseDownEvent,
				eventType = event.type,
				dropped = (eventType == "mouseup" && event.which == 1);
			logMsg("draggable-connectToDynatree.stop: targetNode(from event): %s, dtTargetNode: %s", targetNode, ui.helper.data("dtTargetNode"));
//			logMsg("draggable-connectToDynatree.stop, %s", sourceNode);
//			logMsg("    type: %o, downEvent: %o, upEvent: %o", eventType, mouseDownEvent, event);
//			logMsg("    targetNode: %o", targetNode);
			if(!dropped){
				logMsg("Drag was cancelled");
			}
			if(targetNode) {
				if(dropped){
					targetNode.tree._onDragEvent("drop", targetNode, sourceNode, event, ui, draggable);
				}
				targetNode.tree._onDragEvent("leave", targetNode, sourceNode, event, ui, draggable);
			}
			if(sourceNode){
				sourceNode.tree._onDragEvent("stop", sourceNode, null, event, ui, draggable);
			}
		}
	});
	didRegisterDnd = true;
};

// ---------------------------------------------------------------------------
}(jQuery));
/*
* jQuery listnav plugin
*
* Add a slick "letter-based" navigation bar to all of your lists.
* Click a letter to quickly filter the list to items that match that letter.
*
* Dual licensed under the MIT and GPL licenses:
*   http://www.opensource.org/licenses/mit-license.php
*   http://www.gnu.org/licenses/gpl.html
*
* Version 2.4.3 (02/11/14)
* Author: Eric Steinborn
* Compatibility: jQuery 1.3.x through 1.11.0 and jQuery 2
* Browser Compatibility: IE6+, FF, Chrome & Safari
* CSS is a little wonky in IE6, just set your listnav class to be 100% width and it works fine.
*
*/
(function ($) {

    $.fn.listnav = function (options) {

        var opts = $.extend({}, $.fn.listnav.defaults, options),
            letters = ['_', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '-'],
            firstClick = false,
            //detect if you are on a touch device easily.
            clickEventType=((document.ontouchstart!==null)?'click':'touchstart');

        opts.prefixes = $.map(opts.prefixes, function (n) {

            return n.toLowerCase();

        });

        return this.each(function () {

            var $wrapper, $letters, $letterCount,
                id = this.id,
                $list = $(this),
                counts = {},
                allCount = 0,
                isAll = true,
                prevLetter = '';

            if ( !$('#' + id + '-nav').length ) {

                $('<div id="' + id + '-nav" class="listNav"/>').insertBefore($list);
                // Insert the nav if its not been inserted already (preferred method)
                // Legacy method was to add the nav yourself in HTML, I didn't like that requirement

            }

            $wrapper = $('#' + id + '-nav');
            // <ul id="myList"> for list and <div id="myList-nav"> for nav wrapper

            function init() {

                $wrapper.append(createLettersHtml());

                $letters = $('.ln-letters', $wrapper).slice(0, 1);

                if ( opts.showCounts ) {

                    $letterCount = $('.ln-letter-count', $wrapper).slice(0, 1);

                }

                addClasses();

                addNoMatchLI();

                bindHandlers();

                if (opts.flagDisabled) {

                    addDisabledClass();

                }

                // remove nav items we don't need

                if ( !opts.includeAll ) {

                    $('.all', $letters).remove();

                }
                if ( !opts.includeNums ) {

                    $('._', $letters).remove();

                }
                if ( !opts.includeOther ) {

                    $('.-', $letters).remove();

                }
                if ( opts.removeDisabled ) {

                    $('.ln-disabled', $letters).remove();

                }

                $(':last', $letters).addClass('ln-last');

                if ( $.cookie && (opts.cookieName !== null) ) {

                    var cookieLetter = $.cookie(opts.cookieName);

                    if ( cookieLetter !== null ) {

                        opts.initLetter = cookieLetter;

                    }

                }

                // decide what to show first

                // Is there an initLetter set, if so, show that letter first
                if ( opts.initLetter !== '' ) {

                    firstClick = true;

                    // click the initLetter if there was one
                    $('.' + opts.initLetter.toLowerCase(), $letters).slice(0, 1).trigger(clickEventType);

                } else {

                    // If no init letter is set, and you included All, then show it
                    if ( opts.includeAll ) {

                        // make the All link look clicked, but don't actually click it
                        $('.all', $letters).addClass('ln-selected');

                    } else {

                        // All was not included, lets find the first letter with a count and show it
                        for ( var i = ((opts.includeNums) ? 0 : 1); i < letters.length; i++) {

                            if ( counts[letters[i]] > 0 ) {

                                firstClick = true;

                                $('.' + letters[i], $letters).slice(0, 1).trigger(clickEventType);

                                break;

                            }
                        }
                    }
                }
            }

            // position the letter count above the letter links
            function setLetterCountTop() {

                // we're going to need to subtract this from the top value of the wrapper to accomodate changes in font-size in CSS.
                var letterCountHeight = $letterCount.outerHeight();

                $letterCount.css({
                    top: $('a:first', $wrapper).slice(0, 1).position().top - letterCountHeight
                    // we're going to grab the first anchor in the list
                    // We can no longer guarantee that a specific letter will be present
                    // since adding the "removeDisabled" option

                });

            }

            // adds a class to each LI that has text content inside of it (ie, inside an <a>, a <div>, nested DOM nodes, etc)
            function addClasses() {

                var str, spl, $this,
                    firstChar = '',
                    hasPrefixes = (opts.prefixes.length > 0),
                    hasFilterSelector = (opts.filterSelector.length > 0);

                // Iterate over the list and set a class on each one and use that to filter by
                $($list).children().each(function () {

                    $this = $(this);

                    // I'm assuming you didn't choose a filterSelector, hopefully saving some cycles
                    if ( !hasFilterSelector ) {

                        //Grab the first text content of the LI, we'll use this to filter by
                        str = $.trim($this.text()).toLowerCase();

                    } else {

                        // You set a filterSelector so lets find it and use that to search by instead
                        str = $.trim($this.find(opts.filterSelector).text()).toLowerCase();

                    }

                    // This will run only if there is something to filter by, skipping over images and non-filterable content.
                    if (str !== '') {

                        // Apply the non-prefix class to LIs that have prefixed content in them
                        if (hasPrefixes) {
                            var prefixes = $.map(opts.prefixes, function(value) {
                                return value.indexOf(' ') <= 0 ? value + ' ' : value;
                            });
                            var matches = $.grep(prefixes, function(value) {
                                return str.indexOf(value) === 0;
                            });
                            if (matches.length > 0) {
                                var afterMatch = str.toLowerCase().split(matches[0])[1];
                                if(afterMatch != null) {
                                    firstChar = $.trim(afterMatch).charAt(0);
                                } else {
                                    firstChar = str.charAt(0);
                                }
                                addLetterClass(firstChar, $this, true);
                                return;
                            }
                        }
                        // Find the first letter in the LI, including prefixes
                        firstChar = str.charAt(0);

                        // Doesn't send true to function, which will ++ the All count on prefixed items
                        addLetterClass(firstChar, $this);
                    }
                });
            }

            // Add the appropriate letter class to the current element
            function addLetterClass(firstChar, $el, isPrefix) {

                if ( /\W/.test(firstChar) ) {

                    firstChar = '-'; // not A-Z, a-z or 0-9, so considered "other"

                }

                if ( !isNaN(firstChar) ) {

                    firstChar = '_'; // use '_' if the first char is a number

                }

                $el.addClass('ln-' + firstChar);

                if ( counts[firstChar] === undefined ) {

                    counts[firstChar] = 0;

                }

                counts[firstChar]++;

                if (!isPrefix) {

                    allCount++;

                }

            }

            function addDisabledClass() {

                for ( var i = 0; i < letters.length; i++ ) {

                    if ( counts[letters[i]] === undefined ) {

                        $('.' + letters[i], $letters).addClass('ln-disabled');

                    }
                }
            }

            function addNoMatchLI() {
                $list.append('<li class="ln-no-match listNavHide">' + opts.noMatchText + '</li>');
            }

            function getLetterCount(el) {
                if ($(el).hasClass('all')) {
                    return allCount;
                } else {
                    var count = counts[$(el).attr('class').split(' ')[0]];
                    return (count !== undefined) ? count : 0; // some letters may not have a count in the hash
                }
            }

            function bindHandlers() {

                if (opts.showCounts) {
                    // sets the top position of the count div in case something above it on the page has resized
                    $wrapper.mouseover(function () {
                        setLetterCountTop();
                    });

                    //shows the count above the letter
                    //
                    $('.ln-letters a', $wrapper).mouseover(function () {
                        var left = $(this).position().left,
                            width = ($(this).outerWidth()) + 'px',
                            count = getLetterCount(this);

                        $letterCount.css({
                            left: left,
                            width: width
                        }).text(count).addClass("letterCountShow").removeClass("listNavHide"); // set left position and width of letter count, set count text and show it
                    }).mouseout(function () { // mouseout for each letter: hide the count
                        $letterCount.addClass("listNavHide").removeClass("letterCountShow");
                    });
                }

                // click handler for letters: shows/hides relevant LI's
                //
                $('a', $letters).bind(clickEventType, function (e) {
                    e.preventDefault();
                    var $this = $(this),
                        letter = $this.attr('class').split(' ')[0],
                        noMatches = $list.children('.ln-no-match');

                    if ( prevLetter !== letter ) {
                    // Only to run this once for each click, won't double up if they clicked the same letter
                    // Won't hinder firstRun

                        $('a.ln-selected', $letters).removeClass('ln-selected');

                        if ( letter === 'all' ) {
                            // If ALL button is clicked:

                            $list.children().addClass("listNavShow").removeClass("listNavHide"); // Show ALL

                            noMatches.addClass("listNavHide").removeClass("listNavShow"); // Hide the list item for no matches

                            isAll = true; // set this to quickly check later

                        } else {
                            // If you didn't click ALL

                            if ( isAll ) {
                                // since you clicked ALL last time:

                                $list.children().addClass("listNavHide").removeClass("listNavShow");

                                isAll = false;

                            } else if (prevLetter !== '') {

                                $list.children('.ln-' + prevLetter).addClass("listNavHide").removeClass("listNavShow");

                            }

                            var count = getLetterCount(this);

                            if (count > 0) {
                                $list.children('.ln-' + letter).addClass("listNavShow").removeClass("listNavHide");
                                noMatches.addClass("listNavHide").removeClass("listNavShow"); // in case it's showing
                            } else {
                                noMatches.addClass("listNavShow").removeClass("listNavHide");
                            }


                        }

                        prevLetter = letter;

                        if ($.cookie && (opts.cookieName !== null)) {
                            $.cookie(opts.cookieName, letter, {
                                expires: 999
                            });
                        }

                        $this.addClass('ln-selected');

                        $this.blur();

                        if (!firstClick && (opts.onClick !== null)) {

                            opts.onClick(letter);

                        } else {

                            firstClick = false; //return false;

                        }

                    } // end if prevLetter !== letter

                }); // end click()

            } // end BindHandlers()

            // creates the HTML for the letter links
            //
            function createLettersHtml() {
                var html = [];
                for (var i = 1; i < letters.length; i++) {
                    if (html.length === 0) {
                        html.push('<a class="all" href="#">'+ opts.allText + '</a><a class="_" href="#">0-9</a>');
                    }
                    html.push('<a class="' + letters[i] + '" href="#">' + ((letters[i] === '-') ? '...' : letters[i].toUpperCase()) + '</a>');
                }
                return '<div class="ln-letters">' + html.join('') + '</div>' + ((opts.showCounts) ? '<div class="ln-letter-count listNavHide">0</div>' : '');
                // Remove inline styles, replace with css class
                // Element will be repositioned when made visible
            }
            init();
        });
    };

    $.fn.listnav.defaults = {
        initLetter: '',
        includeAll: true,
        allText: 'All',
        incudeOther: false,
        includeNums: true,
        flagDisabled: true,
        removeDisabled: false,
        noMatchText: 'No matching entries',
        showCounts: true,
        cookieName: null,
        onClick: null,
        prefixes: [],
        filterSelector: ''
    };
})(jQuery);
